{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/postgresql-optimizer-outline-1.md","hash":"ccb4d8a426b4ca8a11da8960cf456c605796ee69","modified":1596329852000},{"_id":"source/_posts/postgresql-optimizer-outline-2.md","hash":"caff7c412fb258307664f7bc5d1f678f80d78fa7","modified":1596332606000},{"_id":"source/_posts/postgresql-optimizer-outline-3.md","hash":"da8bb9ec39a5f72843a2e9a571aa7a1bb4028c94","modified":1596333291000},{"_id":"source/about/index.md","hash":"7a257740541573fc2f9c6abcc7e462ab812c9fb4","modified":1596334091000},{"_id":"source/.DS_Store","hash":"f9dfd147da3191e0538ff38932d7750678a51917","modified":1596335381000},{"_id":"source/_posts/.DS_Store","hash":"a58f2eea596d69653ce12f6a7d3a57f158d7ce23","modified":1601687019000},{"_id":"source/CNAME","hash":"1abf4ed9424d03bbf169fb354620f024705bde24","modified":1596323598000},{"_id":"source/_posts/postgresql-optimizer-outline-2/1.jpg","hash":"7dd5636eac16621f1e2923c163c18983a64bf590","modified":1596331070000},{"_id":"source/_posts/postgresql-optimizer-outline-2/2.jpg","hash":"8f1628d4fd45d15e91cf12ae9f5793cacbb0423c","modified":1596331070000},{"_id":"themes/next/.DS_Store","hash":"6f39545d23238ca172c9d376617d499345ff4f6e","modified":1596335943000},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1596297190000},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1596297190000},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1596297190000},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1596297190000},{"_id":"themes/next/_config.yml","hash":"ce09b154d140763df464cdb536ac01b2f3f2ea3e","modified":1596931447000},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1596297190000},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1596297190000},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1596297190000},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1596297190000},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1596297190000},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1596297190000},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1596297190000},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1596297190000},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1596297190000},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1596297190000},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1596297190000},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1596297190000},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1596297190000},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1596297190000},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1596297190000},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1596297190000},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1596297190000},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1596297190000},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1596297190000},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1596297190000},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1596297190000},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1596297190000},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1596297190000},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1596297190000},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1596297190000},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1596297190000},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1596297190000},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1596297190000},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1596297190000},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1596297190000},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1596297190000},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1596297190000},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1596297190000},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1596297190000},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1596297190000},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1596297190000},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1596297190000},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1596297190000},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1596297190000},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1596297190000},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1596297190000},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1596297190000},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1596297190000},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1596297190000},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1596297190000},{"_id":"themes/next/source/.DS_Store","hash":"42a735759b4eff69f4200db39d8094082ee38bf7","modified":1596335943000},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1596297190000},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1596297190000},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1596297190000},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1596297190000},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1596297190000},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1596297190000},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1596297190000},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1596297190000},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1596297190000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1596297190000},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1596297190000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1596297190000},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1596297190000},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1596297190000},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1596297190000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1596297190000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"e5a2bdf45fde7cea9cb03993f5a0fd960326ed5d","modified":1596297190000},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1596297190000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1596297190000},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1596297190000},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1596297190000},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1596297190000},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1596297190000},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1596297190000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1596297190000},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1596297190000},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1596297190000},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1596297190000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1596297190000},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1596297190000},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1596297190000},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1596297190000},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1596297190000},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1596297190000},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1596297190000},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1596297190000},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1596297190000},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1596297190000},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1596297190000},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1596297190000},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1596297190000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1596297190000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1596297190000},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1596297190000},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1596297190000},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1596297190000},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1596297190000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1596297190000},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1596297190000},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1596297190000},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1596297190000},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1596297190000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"c98146a0f81666956272fe692c1958fd1cf3d9a1","modified":1596335419000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1596297190000},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1596297190000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1596297190000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1596297190000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1596297190000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1596297190000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1596297190000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"ab599db2348f43f2cd71995e4d27e784847605aa","modified":1596335571000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1596297190000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1596297190000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"25dffea8b5603caf2ea77feb90bd9c1e86738713","modified":1596335608000},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1596297190000},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1596297190000},{"_id":"themes/next/source/js/utils.js","hash":"2c6e6b4d9a592fbb4bf04689524db2cdfcd94ca7","modified":1596297190000},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1596297190000},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1596297190000},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1596297190000},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1596297190000},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1596297190000},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1596297190000},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1596297190000},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1596297190000},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1596297190000},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1596297190000},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1596297190000},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1596297190000},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1596297190000},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1596297190000},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1596297190000},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1596297190000},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1596297190000},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1596297190000},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1596297190000},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1596297190000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1596297190000},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1596297190000},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1596297190000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1596297190000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1596297190000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1596297190000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1596297190000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1596297190000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1596297190000},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1596297190000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1596297190000},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1596297190000},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1596297190000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1596297190000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1596297190000},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1596297190000},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1596297190000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1596297190000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1596297190000},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1596297190000},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1596297190000},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1596297190000},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1596297190000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1596297190000},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1596297190000},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1596297190000},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1596297190000},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1596297190000},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1596297190000},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1596297190000},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1596297190000},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1596297190000},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1596297190000},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1596297190000},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1596297190000},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1596297190000},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1596297190000},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1596297190000},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1596297190000},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1596297190000},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1596297190000},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1596297190000},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1596297190000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1596297190000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1596297190000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1596297190000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1596297190000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1596297190000},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1596297190000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1596297190000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1596297190000},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1596297190000},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1596297190000},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1596297190000},{"_id":"themes/next/source/images/avatar.jpg","hash":"bd42bc2f990d78707c488b99d0d21c3dc587d30e","modified":1596328101000},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1596297190000},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1596297190000},{"_id":"themes/next/source/images/logo.svg","hash":"5a4f99b6915fe7f59e4d1f197ce0d979c57872b2","modified":1596336066000},{"_id":"public/about/index.html","hash":"54f75e3611d8678cbbe5f852de88de7ded567054","modified":1601687930316},{"_id":"public/archives/index.html","hash":"128224a9fdefedd6679aa84abb10a7c120a0934e","modified":1601687930316},{"_id":"public/archives/2020/index.html","hash":"90f80ffadbb79f63e823e51320c7eb0107977774","modified":1601687930316},{"_id":"public/archives/2020/08/index.html","hash":"e77233e772e7880868227ae5c3ba268d9e754749","modified":1601687930316},{"_id":"public/index.html","hash":"2c9bf0a73ea28b48c32cbaa0bbc60a51ded230c8","modified":1601688577061},{"_id":"public/2020/08/02/postgresql-optimizer-outline-3/index.html","hash":"bf16fac834ebca17d58f32ae19b3f3e3447d58f3","modified":1601687930316},{"_id":"public/2020/08/02/postgresql-optimizer-outline-2/index.html","hash":"b50d79015bb035bae470acda3382208d8b56e708","modified":1601687930316},{"_id":"public/2020/08/02/postgresql-optimizer-outline-1/index.html","hash":"dda43c6f794c02ae5e5903650305821351ec0087","modified":1601687930316},{"_id":"public/CNAME","hash":"1abf4ed9424d03bbf169fb354620f024705bde24","modified":1596336357102},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1596336357102},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1596336357102},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1596336357102},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1596336357102},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1596336357102},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1596336357102},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1596336357102},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1596336357102},{"_id":"public/images/favicon-16x16-next.png","hash":"25dffea8b5603caf2ea77feb90bd9c1e86738713","modified":1596336357102},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1596336357102},{"_id":"public/images/favicon-32x32-next.png","hash":"ab599db2348f43f2cd71995e4d27e784847605aa","modified":1596336357102},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1596336357102},{"_id":"public/2020/08/02/postgresql-optimizer-outline-2/1.jpg","hash":"7dd5636eac16621f1e2923c163c18983a64bf590","modified":1596336357102},{"_id":"public/2020/08/02/postgresql-optimizer-outline-2/2.jpg","hash":"8f1628d4fd45d15e91cf12ae9f5793cacbb0423c","modified":1596336357102},{"_id":"public/images/apple-touch-icon-next.png","hash":"c98146a0f81666956272fe692c1958fd1cf3d9a1","modified":1596336357102},{"_id":"public/images/avatar.jpg","hash":"bd42bc2f990d78707c488b99d0d21c3dc587d30e","modified":1596336357102},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1596336357102},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1596336357102},{"_id":"public/images/logo.svg","hash":"5a4f99b6915fe7f59e4d1f197ce0d979c57872b2","modified":1596336357102},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1596336357102},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1596336357102},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1596336357102},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1596336357102},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1596336357102},{"_id":"public/js/utils.js","hash":"2c6e6b4d9a592fbb4bf04689524db2cdfcd94ca7","modified":1596336357102},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1596336357102},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1596336357102},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1596336357102},{"_id":"public/css/main.css","hash":"38afd92942bc1de414d27567b614c311d1083e5c","modified":1596336357102},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1596336357102},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1596336357102},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1596336357102},{"_id":"source/_posts/postgresql-optimizer-outline-4.md","hash":"2db530cffe38825f62b67ca207b720f17ec5b799","modified":1596583097000},{"_id":"source/_posts/postgresql-optimizer-outline-4/1.png","hash":"8c8c6bf54553e00c4721d0312d99053203076e86","modified":1596582921000},{"_id":"source/_posts/postgresql-optimizer-outline-4/2.png","hash":"fb15c7b6a05bd9b50f72e37899a1e23aada14e9b","modified":1596582921000},{"_id":"public/2020/08/05/postgresql-optimizer-outline-4/index.html","hash":"77a354a58ed2e9bc37194853cdcaf47c3f63e1d5","modified":1601687930316},{"_id":"public/2020/08/05/postgresql-optimizer-outline-4/2.png","hash":"fb15c7b6a05bd9b50f72e37899a1e23aada14e9b","modified":1596583024481},{"_id":"public/2020/08/05/postgresql-optimizer-outline-4/1.png","hash":"8c8c6bf54553e00c4721d0312d99053203076e86","modified":1596583024481},{"_id":"source/_posts/postgresql-optimizer-outline-5.md","hash":"1db7bc5a33099f38a0ab397ce25287fd20a2aa3a","modified":1597419918000},{"_id":"public/2020/08/14/postgresql-optimizer-outline-5/index.html","hash":"d26c845b4536b35344c5b0bb0ee7f0f47b2710a8","modified":1601687930316},{"_id":"source/_posts/postgresql-optimizer-outline-6.md","hash":"e1ef8bcea928e0252cac28a5f199b17ab7eeba07","modified":1601685354000},{"_id":"public/2020/10/03/postgresql-optimizer-outline-6/index.html","hash":"05ba0328b0c3cb00a2a6a94824a517e60ad1465e","modified":1601687930316},{"_id":"public/archives/2020/10/index.html","hash":"dc61451103ba16081fe3abe5e3e8ecb7d487c557","modified":1601687930316},{"_id":"source/_posts/postgresql-optimizer-outline-8.md","hash":"7138a2d74d8b8b92372ee6a6f84ca302a9e056d2","modified":1601686863000},{"_id":"source/_posts/postgresql-optimizer-outline-9.md","hash":"5cbd63018518f572d6cd8d1100972f54686ba4cc","modified":1601687609000},{"_id":"source/_posts/postgresql-optimizer-outline-7/1.jpg","hash":"50c5074e7dbf176d1ebd5b45b5e5a941147126e8","modified":1527260674000},{"_id":"source/_posts/postgresql-optimizer-outline-7/3.png","hash":"6a34d81f9a58d35f6656d8b30ff603afc13eb151","modified":1527260687000},{"_id":"source/_posts/postgresql-optimizer-outline-9/1.png","hash":"7c1477a5ee41d9d541cceaf59f278b1460a857ee","modified":1527260717000},{"_id":"source/_posts/postgresql-optimizer-outline-9/2.png","hash":"1f58087cc2c9f30dba34d0bc6abe6ad34f5fb345","modified":1527260724000},{"_id":"source/_posts/postgresql-optimizer-outline-9/4.png","hash":"404e59978b659c9cf7d56d8dd456851480d0017d","modified":1527260736000},{"_id":"source/_posts/postgresql-optimizer-outline-7/.DS_Store","hash":"872a5b56a7f41a1fc54298a25149a150f2078d00","modified":1601686554000},{"_id":"source/_posts/postgresql-optimizer-outline-9/.DS_Store","hash":"764ae0cbe6b3609133570242eaa44dde709424d4","modified":1601687624000},{"_id":"source/_posts/postgresql-optimizer-outline-7.md","hash":"12b80578f6b1336a487c5ffa3f79d81926ba9f36","modified":1601687567000},{"_id":"source/_posts/postgresql-optimizer-outline-7/2.png","hash":"a73527127e774ddeae33912214b7f04052e7476a","modified":1527260681000},{"_id":"source/_posts/postgresql-optimizer-outline-7/4.png","hash":"e37eef8c2a5e6186fb13c32473984531afcd3301","modified":1527260695000},{"_id":"source/_posts/postgresql-optimizer-outline-7/5.png","hash":"fdc70d5ddabe15a5e324a26944fec62b3a8a3c38","modified":1527260701000},{"_id":"source/_posts/postgresql-optimizer-outline-7/6.png","hash":"16838273101e54a62b7c194c439976c04c031ced","modified":1527260707000},{"_id":"source/_posts/postgresql-optimizer-outline-9/3.png","hash":"84b7b9c69cc069c542bec3c6a48bf9efc6a356da","modified":1527260730000},{"_id":"public/tags/路径-Path-顺序扫描-索引扫描-位图扫描-Join/index.html","hash":"8d46d1389ef600bd2fd3d4dd8037f5de34c8a2a3","modified":1601687930316},{"_id":"public/tags/代价-启动代价-IO代价-CPU代价/index.html","hash":"42bb62c8564404218a731acd7d24512d574317c0","modified":1601687930316},{"_id":"public/tags/动态规划-自底向上-自顶向下/index.html","hash":"76a45a0f2f8de211e019555a11766a221dc853b0","modified":1601687930316},{"_id":"public/2020/10/03/postgresql-optimizer-outline-9/index.html","hash":"b3b2cb3c5fb90eb4bb625ebdc86c55652cb0d178","modified":1601687930316},{"_id":"public/2020/10/03/postgresql-optimizer-outline-8/index.html","hash":"73ef75e37e9fd169a0411a36640c660c27e1ed69","modified":1601687930316},{"_id":"public/2020/10/03/postgresql-optimizer-outline-7/index.html","hash":"1d17031c37ba646ac2416e543610d3af70cd5d62","modified":1601687930316},{"_id":"public/2020/10/03/postgresql-optimizer-outline-7/1.jpg","hash":"50c5074e7dbf176d1ebd5b45b5e5a941147126e8","modified":1601687415870},{"_id":"public/2020/10/03/postgresql-optimizer-outline-9/1.png","hash":"7c1477a5ee41d9d541cceaf59f278b1460a857ee","modified":1601687415870},{"_id":"public/2020/10/03/postgresql-optimizer-outline-9/2.png","hash":"1f58087cc2c9f30dba34d0bc6abe6ad34f5fb345","modified":1601687415870},{"_id":"public/2020/10/03/postgresql-optimizer-outline-9/4.png","hash":"404e59978b659c9cf7d56d8dd456851480d0017d","modified":1601687415870},{"_id":"public/2020/10/03/postgresql-optimizer-outline-9/3.png","hash":"84b7b9c69cc069c542bec3c6a48bf9efc6a356da","modified":1601687415870},{"_id":"public/2020/10/03/postgresql-optimizer-outline-7/3.png","hash":"6a34d81f9a58d35f6656d8b30ff603afc13eb151","modified":1601687415870},{"_id":"public/2020/10/03/postgresql-optimizer-outline-7/4.png","hash":"e37eef8c2a5e6186fb13c32473984531afcd3301","modified":1601687415870},{"_id":"public/2020/10/03/postgresql-optimizer-outline-7/5.png","hash":"fdc70d5ddabe15a5e324a26944fec62b3a8a3c38","modified":1601687415870},{"_id":"public/2020/10/03/postgresql-optimizer-outline-7/6.png","hash":"16838273101e54a62b7c194c439976c04c031ced","modified":1601687415870},{"_id":"public/2020/10/03/postgresql-optimizer-outline-7/2.png","hash":"a73527127e774ddeae33912214b7f04052e7476a","modified":1601687415870},{"_id":"source/_posts/postgresql-optimizer-outline-10.md","hash":"49dfab0578d37dd292f589d6c6014f0dc6e067f0","modified":1601688572000},{"_id":"public/2020/10/03/postgresql-optimizer-outline-10/index.html","hash":"0580539bb620d74f3e541e346cde2e49562513dd","modified":1601688577061}],"Category":[],"Data":[],"Page":[{"title":"张树杰","date":"2020-08-02T02:00:11.000Z","_content":"\n\n* 《PostgreSQL技术内幕：查询优化深度探索》\n* 《PostgreSQL技术内幕：事务处理深度探索》创作中","source":"about/index.md","raw":"---\ntitle: 张树杰\ndate: 2020-08-02 10:00:11\n---\n\n\n* 《PostgreSQL技术内幕：查询优化深度探索》\n* 《PostgreSQL技术内幕：事务处理深度探索》创作中","updated":"2020-08-02T02:08:11.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckdchg8j80000r2s6dnmidrbh","content":"<ul>\n<li>《PostgreSQL技术内幕：查询优化深度探索》</li>\n<li>《PostgreSQL技术内幕：事务处理深度探索》创作中</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>《PostgreSQL技术内幕：查询优化深度探索》</li>\n<li>《PostgreSQL技术内幕：事务处理深度探索》创作中</li>\n</ul>\n"}],"Post":[{"title":"PostgreSQL优化器白话(1) - 为什么优化","date":"2020-08-02T00:35:06.000Z","_content":"\n\n小明考上了北清大学的计算机研究生，今年学校开了数据库原理的课程，小明对查询优化的部分不是很理解，虽然已经使出了洪荒之力，仍然觉得其中的部分原理有些晦涩难懂，于是小明打算问一下自己的哥哥大明，大明是一位资深的数据库内核开发的老码农，对Greenplum/HAWQ数据库有多年的内核开发经验<!-- more -->，厚厚眼镜片上的圈圈像年轮一样深深的见证着大明十多年的从业经历，知道小明要来问问题，大明有点紧张，虽然自己做数据库内核好多年了，但是对优化器研究却不深入，如果被小明这样的小菜鸟问倒就尴尬了，于是大明只好临时抱佛脚，拿出了好多年不看的《数据库系统实现》啃了起来。\n\n小明提出的第一个问题是：“为什么数据库要进行查询优化？”\n\n大明推了推鼻梁上的眼镜，点上了一根中华深吸一口，火红的烟头奋力燃烧，由明及暗，几片烟灰飘飘渺渺的散落下来，又和大明吐出的云雾交缠在一起，即轻盈又律动，大明弹了弹烟灰，慢条斯理的说：“不止是数据库要进行优化，基本上所有的编程语言在编译的时候都会优化，比如你在编译C语言的时候，可以通过编译选项-o来指定进行哪个级别的优化，但是查询数据库的查询优化和C语言的优化还有些区别。”\n\n“有哪些区别呢？”大明停顿了一下，凝视着小明，仿佛期望小明给出答案，或者是给小明腾挪出足够思考的空间，三五秒之后大明又自问自答道：“C语言是过程化语言，你已经指定好了需要执行的每一个步骤，但是SQL是描述性语言，它只指定了WHAT，而没有指定HOW，这样它的优化空间就大了，你说是不是？”\n\n小明点了点头说：“对，也就是说条条大路通罗马，它比过程语言的选择更多，是不是这样？”大明笑道：“孺子可教也。虽然我们知道它的优化空间大，但具体如何优化呢？”\n\n说着大明将身子向沙发里靠以靠，翘上二郎腿继续说：“通常来说分成两个层面，一个是基于规则的优化，另一个是基于代价的优化，基于规则的优化也可以叫逻辑优化或者规则优化，基于代价的优化也可以叫物理优化或者代价优化。”大明边说边用手比划着，手里的烟火也欢快的跳跃着。\n\n“那为什么要进行这样的区分呢？优化就优化嘛，何必还分什么规则和代价呢？”，小明问道。\n\n“分层不分层不是重点，有些优化器层次分的清楚点，有些优化器层次分的就不那么清楚，都只是优化手段而已。”大明感到有点心虚，再这么问下去恐怕要被问住，于是试图引开话题：“我们继续说说SQL语言吧，我们说它是一种介于关系演算和关系代数之间的语言，关系演算和关系代数你看过吧？”\n\n小明想了想，好像自己上课的时候老师说过关系代数，但是没有说关系演算，于是说：“接触过一点，但也不是特别明白。”大明得意的说：“关系演算是纯描述性的语言，而关系代数呢，则包含了一些基本的关系操作，SQL主要借鉴的是关系演算，也包含了关系代数的一部分特点。”\n\n大明看小明有点懵，顿了一下，然后继续说道：“你们上课的时候老师有没有说过关系代数的基本操作？”小明想了一下说：“好像说了，有投影、选择、连接、交集、差集这几个。”大明点点头说：“对的，还可以有一个叫重命名的，一共6个基本操作，另外结合实际应用在这些基本操作之上又扩展出了外连接、半连接、聚集操作、分组操作等等。”\n\n大明又深吸了一口烟，优雅的吐了个烟圈，继续说道：“SQL语句虽然是描述性的，但是我们可以把它转化成一个关系代数表达式，而关系代数中呢，又有一些等价的规则，这样我们就能结合这些等价规则对关系代数表达式进行等价的转换。”\n\n“进行等价转换的目的是找到性能更好的代数表达式吧？”小明问。\n\n“对，就是这样。”大明投来赞许的目光。\n\n“那么如何确定等价变换之后的表达式就能变得比变换之前性能更好呢？或者说为什么我们要进行这样的等价变换，而不是使用原来的表达式呢？”\n\n大明愣了一下，仿佛没有想到小明会提出这样的问题，但是基于自己多年的忽悠经验，他定了定神，回答道：“这既有经验的成分，也有量化的考虑。例如将选择操作下推，就能优先过滤数据，那么表达式的上层计算结点就能降低计算量，因此很容易可以知道是能降低代价的。再例如我们通常会对相关的子查询进行提升，这是因为如果不提升这种子查询，那么它执行的时候就会产生一个嵌套循环，这种嵌套循环的执行代价是O(N^2)，这种复杂度已经是最坏的情况了，提升上来至少不会比它差，因此提升上来是有价值的。”大明心里对自己的临危不乱暗暗点了个赞。\n\n大明看小明没有提问，继续说道：“这些基于关系代数等价规则做等价变换的优化，就是基于规则的优化，当然数据库本身也会结合实际的经验，产生一些优化规则，比如外连接消除，因为外连接优化起来不太方便，如果能把它消除掉，我们就有了更大的优化空间，这些统统都是基于规则的优化。同时这些都是建立在逻辑操作符上的优化，这也是为什么基于规则的优化也叫做逻辑优化。”\n\n小明想了想，自己好像对逻辑操作符不太理解，连忙问：“逻辑操作符是啥？既然有物理优化，难道还有物理操作符吗？”\n\n大明看自己的烟已经烧的只剩下过滤嘴了，连忙把烟头扔到烟灰缸，伸个懒腰继续说：“比如说吧，你在SQL语句里写上了两个表要做一个左外连接，那么数据库怎么来做这个左外连接呢？”\n\n小明一头雾水的摇摇头，对大明投出了期待的眼神。\n\n大明自问自答的继续说道：“数据库说我也不知道啊，你说的左外连接意思我懂，但我也不知道怎么实现啊？你需要告诉我实现方法啊，因此优化器还承担了一个任务，就是告诉执行器，怎么来实现一个左外连接。”\n\n大明一边说，一边从茶几上把烟拿起来，准备再抽一根，却尴尬的发现，烟盒里一根烟都没有了，大明把空烟盒弹进垃圾桶，继续说：“数据库有哪些方法来实现一个左外连接呢？它可以用嵌套循环连接、哈希连接、归并连接等等，注意了，重要的事情说三遍，你看内连接、外连接是连接操作，嵌套循环连接、归并连接等也叫连接，但内连接、外连接这些就是逻辑操作符，而嵌套循环连接、归并连接这些就是物理操作符。所以你说对了，物理优化就是建立在物理操作符上的优化。”\n\n大明又问小明：“你要从北京去上海，你说你怎么去？”\n\n小明说：“坐高铁啊，又快又方便。”\n\n大明继续问：“做高铁先去广州，然后倒车到上海行不行？”\n\n小明说：“有点扎心了，这不是吃饱了撑的吗？”\n\n大明追问：“为什么？”\n\n小明说：“很明显，我有直达的高铁，即节省时间，又节省费用，先去广州再倒车？我脑子瓦特了？！”\n\n大明笑了笑说：“不知不觉之间，你的大脑就建立了一个代价模型，那就是性价比，优化器作为数据库的大脑，也需要建立代价模型，对物理操作符计算代价，然后筛选出最优的物理操作符来，因此基于代价的优化是建立在物理操作符上的优化，所以也叫物理优化。”\n\n小明觉得似乎懂了：“公司派我去上海出差就是一个逻辑操作符，它和我们写一个SQL语句要求数据库对两个表做左外连接类似，而去上海的实际路径有很多种，这些就像是物理操作符，我们对这些实际的物理路径计算代价之后，就可以选出来最好的路径了。”\n\n大明掏出手机，分别打开了白兔地图APP和高达地图APP，输入了北京到上海的信息，然后拿给小明看，小明发现两家APP给出的最优路径是不一样的。小明若有所思的说：“看来代价模型很重要，代价模型是不是准确决定了最优路径选择的是不是准确。”\n大明一拍大腿，笑着说：“太对了，所以我作为一个数据库内核的资深开发人员，需要不断的调整优化器的代价模型，以期望获得一个相对稳定的代价模型，不过仍然是任重道远啊。”\n","source":"_posts/postgresql-optimizer-outline-1.md","raw":"---\ntitle: PostgreSQL优化器白话(1) - 为什么优化\ndate: 2020-08-02 08:35:06\n---\n\n\n小明考上了北清大学的计算机研究生，今年学校开了数据库原理的课程，小明对查询优化的部分不是很理解，虽然已经使出了洪荒之力，仍然觉得其中的部分原理有些晦涩难懂，于是小明打算问一下自己的哥哥大明，大明是一位资深的数据库内核开发的老码农，对Greenplum/HAWQ数据库有多年的内核开发经验<!-- more -->，厚厚眼镜片上的圈圈像年轮一样深深的见证着大明十多年的从业经历，知道小明要来问问题，大明有点紧张，虽然自己做数据库内核好多年了，但是对优化器研究却不深入，如果被小明这样的小菜鸟问倒就尴尬了，于是大明只好临时抱佛脚，拿出了好多年不看的《数据库系统实现》啃了起来。\n\n小明提出的第一个问题是：“为什么数据库要进行查询优化？”\n\n大明推了推鼻梁上的眼镜，点上了一根中华深吸一口，火红的烟头奋力燃烧，由明及暗，几片烟灰飘飘渺渺的散落下来，又和大明吐出的云雾交缠在一起，即轻盈又律动，大明弹了弹烟灰，慢条斯理的说：“不止是数据库要进行优化，基本上所有的编程语言在编译的时候都会优化，比如你在编译C语言的时候，可以通过编译选项-o来指定进行哪个级别的优化，但是查询数据库的查询优化和C语言的优化还有些区别。”\n\n“有哪些区别呢？”大明停顿了一下，凝视着小明，仿佛期望小明给出答案，或者是给小明腾挪出足够思考的空间，三五秒之后大明又自问自答道：“C语言是过程化语言，你已经指定好了需要执行的每一个步骤，但是SQL是描述性语言，它只指定了WHAT，而没有指定HOW，这样它的优化空间就大了，你说是不是？”\n\n小明点了点头说：“对，也就是说条条大路通罗马，它比过程语言的选择更多，是不是这样？”大明笑道：“孺子可教也。虽然我们知道它的优化空间大，但具体如何优化呢？”\n\n说着大明将身子向沙发里靠以靠，翘上二郎腿继续说：“通常来说分成两个层面，一个是基于规则的优化，另一个是基于代价的优化，基于规则的优化也可以叫逻辑优化或者规则优化，基于代价的优化也可以叫物理优化或者代价优化。”大明边说边用手比划着，手里的烟火也欢快的跳跃着。\n\n“那为什么要进行这样的区分呢？优化就优化嘛，何必还分什么规则和代价呢？”，小明问道。\n\n“分层不分层不是重点，有些优化器层次分的清楚点，有些优化器层次分的就不那么清楚，都只是优化手段而已。”大明感到有点心虚，再这么问下去恐怕要被问住，于是试图引开话题：“我们继续说说SQL语言吧，我们说它是一种介于关系演算和关系代数之间的语言，关系演算和关系代数你看过吧？”\n\n小明想了想，好像自己上课的时候老师说过关系代数，但是没有说关系演算，于是说：“接触过一点，但也不是特别明白。”大明得意的说：“关系演算是纯描述性的语言，而关系代数呢，则包含了一些基本的关系操作，SQL主要借鉴的是关系演算，也包含了关系代数的一部分特点。”\n\n大明看小明有点懵，顿了一下，然后继续说道：“你们上课的时候老师有没有说过关系代数的基本操作？”小明想了一下说：“好像说了，有投影、选择、连接、交集、差集这几个。”大明点点头说：“对的，还可以有一个叫重命名的，一共6个基本操作，另外结合实际应用在这些基本操作之上又扩展出了外连接、半连接、聚集操作、分组操作等等。”\n\n大明又深吸了一口烟，优雅的吐了个烟圈，继续说道：“SQL语句虽然是描述性的，但是我们可以把它转化成一个关系代数表达式，而关系代数中呢，又有一些等价的规则，这样我们就能结合这些等价规则对关系代数表达式进行等价的转换。”\n\n“进行等价转换的目的是找到性能更好的代数表达式吧？”小明问。\n\n“对，就是这样。”大明投来赞许的目光。\n\n“那么如何确定等价变换之后的表达式就能变得比变换之前性能更好呢？或者说为什么我们要进行这样的等价变换，而不是使用原来的表达式呢？”\n\n大明愣了一下，仿佛没有想到小明会提出这样的问题，但是基于自己多年的忽悠经验，他定了定神，回答道：“这既有经验的成分，也有量化的考虑。例如将选择操作下推，就能优先过滤数据，那么表达式的上层计算结点就能降低计算量，因此很容易可以知道是能降低代价的。再例如我们通常会对相关的子查询进行提升，这是因为如果不提升这种子查询，那么它执行的时候就会产生一个嵌套循环，这种嵌套循环的执行代价是O(N^2)，这种复杂度已经是最坏的情况了，提升上来至少不会比它差，因此提升上来是有价值的。”大明心里对自己的临危不乱暗暗点了个赞。\n\n大明看小明没有提问，继续说道：“这些基于关系代数等价规则做等价变换的优化，就是基于规则的优化，当然数据库本身也会结合实际的经验，产生一些优化规则，比如外连接消除，因为外连接优化起来不太方便，如果能把它消除掉，我们就有了更大的优化空间，这些统统都是基于规则的优化。同时这些都是建立在逻辑操作符上的优化，这也是为什么基于规则的优化也叫做逻辑优化。”\n\n小明想了想，自己好像对逻辑操作符不太理解，连忙问：“逻辑操作符是啥？既然有物理优化，难道还有物理操作符吗？”\n\n大明看自己的烟已经烧的只剩下过滤嘴了，连忙把烟头扔到烟灰缸，伸个懒腰继续说：“比如说吧，你在SQL语句里写上了两个表要做一个左外连接，那么数据库怎么来做这个左外连接呢？”\n\n小明一头雾水的摇摇头，对大明投出了期待的眼神。\n\n大明自问自答的继续说道：“数据库说我也不知道啊，你说的左外连接意思我懂，但我也不知道怎么实现啊？你需要告诉我实现方法啊，因此优化器还承担了一个任务，就是告诉执行器，怎么来实现一个左外连接。”\n\n大明一边说，一边从茶几上把烟拿起来，准备再抽一根，却尴尬的发现，烟盒里一根烟都没有了，大明把空烟盒弹进垃圾桶，继续说：“数据库有哪些方法来实现一个左外连接呢？它可以用嵌套循环连接、哈希连接、归并连接等等，注意了，重要的事情说三遍，你看内连接、外连接是连接操作，嵌套循环连接、归并连接等也叫连接，但内连接、外连接这些就是逻辑操作符，而嵌套循环连接、归并连接这些就是物理操作符。所以你说对了，物理优化就是建立在物理操作符上的优化。”\n\n大明又问小明：“你要从北京去上海，你说你怎么去？”\n\n小明说：“坐高铁啊，又快又方便。”\n\n大明继续问：“做高铁先去广州，然后倒车到上海行不行？”\n\n小明说：“有点扎心了，这不是吃饱了撑的吗？”\n\n大明追问：“为什么？”\n\n小明说：“很明显，我有直达的高铁，即节省时间，又节省费用，先去广州再倒车？我脑子瓦特了？！”\n\n大明笑了笑说：“不知不觉之间，你的大脑就建立了一个代价模型，那就是性价比，优化器作为数据库的大脑，也需要建立代价模型，对物理操作符计算代价，然后筛选出最优的物理操作符来，因此基于代价的优化是建立在物理操作符上的优化，所以也叫物理优化。”\n\n小明觉得似乎懂了：“公司派我去上海出差就是一个逻辑操作符，它和我们写一个SQL语句要求数据库对两个表做左外连接类似，而去上海的实际路径有很多种，这些就像是物理操作符，我们对这些实际的物理路径计算代价之后，就可以选出来最好的路径了。”\n\n大明掏出手机，分别打开了白兔地图APP和高达地图APP，输入了北京到上海的信息，然后拿给小明看，小明发现两家APP给出的最优路径是不一样的。小明若有所思的说：“看来代价模型很重要，代价模型是不是准确决定了最优路径选择的是不是准确。”\n大明一拍大腿，笑着说：“太对了，所以我作为一个数据库内核的资深开发人员，需要不断的调整优化器的代价模型，以期望获得一个相对稳定的代价模型，不过仍然是任重道远啊。”\n","slug":"postgresql-optimizer-outline-1","published":1,"updated":"2020-08-02T00:57:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdchg8jc0001r2s695jh2xip","content":"<p>小明考上了北清大学的计算机研究生，今年学校开了数据库原理的课程，小明对查询优化的部分不是很理解，虽然已经使出了洪荒之力，仍然觉得其中的部分原理有些晦涩难懂，于是小明打算问一下自己的哥哥大明，大明是一位资深的数据库内核开发的老码农，对Greenplum/HAWQ数据库有多年的内核开发经验<a id=\"more\"></a>，厚厚眼镜片上的圈圈像年轮一样深深的见证着大明十多年的从业经历，知道小明要来问问题，大明有点紧张，虽然自己做数据库内核好多年了，但是对优化器研究却不深入，如果被小明这样的小菜鸟问倒就尴尬了，于是大明只好临时抱佛脚，拿出了好多年不看的《数据库系统实现》啃了起来。</p>\n<p>小明提出的第一个问题是：“为什么数据库要进行查询优化？”</p>\n<p>大明推了推鼻梁上的眼镜，点上了一根中华深吸一口，火红的烟头奋力燃烧，由明及暗，几片烟灰飘飘渺渺的散落下来，又和大明吐出的云雾交缠在一起，即轻盈又律动，大明弹了弹烟灰，慢条斯理的说：“不止是数据库要进行优化，基本上所有的编程语言在编译的时候都会优化，比如你在编译C语言的时候，可以通过编译选项-o来指定进行哪个级别的优化，但是查询数据库的查询优化和C语言的优化还有些区别。”</p>\n<p>“有哪些区别呢？”大明停顿了一下，凝视着小明，仿佛期望小明给出答案，或者是给小明腾挪出足够思考的空间，三五秒之后大明又自问自答道：“C语言是过程化语言，你已经指定好了需要执行的每一个步骤，但是SQL是描述性语言，它只指定了WHAT，而没有指定HOW，这样它的优化空间就大了，你说是不是？”</p>\n<p>小明点了点头说：“对，也就是说条条大路通罗马，它比过程语言的选择更多，是不是这样？”大明笑道：“孺子可教也。虽然我们知道它的优化空间大，但具体如何优化呢？”</p>\n<p>说着大明将身子向沙发里靠以靠，翘上二郎腿继续说：“通常来说分成两个层面，一个是基于规则的优化，另一个是基于代价的优化，基于规则的优化也可以叫逻辑优化或者规则优化，基于代价的优化也可以叫物理优化或者代价优化。”大明边说边用手比划着，手里的烟火也欢快的跳跃着。</p>\n<p>“那为什么要进行这样的区分呢？优化就优化嘛，何必还分什么规则和代价呢？”，小明问道。</p>\n<p>“分层不分层不是重点，有些优化器层次分的清楚点，有些优化器层次分的就不那么清楚，都只是优化手段而已。”大明感到有点心虚，再这么问下去恐怕要被问住，于是试图引开话题：“我们继续说说SQL语言吧，我们说它是一种介于关系演算和关系代数之间的语言，关系演算和关系代数你看过吧？”</p>\n<p>小明想了想，好像自己上课的时候老师说过关系代数，但是没有说关系演算，于是说：“接触过一点，但也不是特别明白。”大明得意的说：“关系演算是纯描述性的语言，而关系代数呢，则包含了一些基本的关系操作，SQL主要借鉴的是关系演算，也包含了关系代数的一部分特点。”</p>\n<p>大明看小明有点懵，顿了一下，然后继续说道：“你们上课的时候老师有没有说过关系代数的基本操作？”小明想了一下说：“好像说了，有投影、选择、连接、交集、差集这几个。”大明点点头说：“对的，还可以有一个叫重命名的，一共6个基本操作，另外结合实际应用在这些基本操作之上又扩展出了外连接、半连接、聚集操作、分组操作等等。”</p>\n<p>大明又深吸了一口烟，优雅的吐了个烟圈，继续说道：“SQL语句虽然是描述性的，但是我们可以把它转化成一个关系代数表达式，而关系代数中呢，又有一些等价的规则，这样我们就能结合这些等价规则对关系代数表达式进行等价的转换。”</p>\n<p>“进行等价转换的目的是找到性能更好的代数表达式吧？”小明问。</p>\n<p>“对，就是这样。”大明投来赞许的目光。</p>\n<p>“那么如何确定等价变换之后的表达式就能变得比变换之前性能更好呢？或者说为什么我们要进行这样的等价变换，而不是使用原来的表达式呢？”</p>\n<p>大明愣了一下，仿佛没有想到小明会提出这样的问题，但是基于自己多年的忽悠经验，他定了定神，回答道：“这既有经验的成分，也有量化的考虑。例如将选择操作下推，就能优先过滤数据，那么表达式的上层计算结点就能降低计算量，因此很容易可以知道是能降低代价的。再例如我们通常会对相关的子查询进行提升，这是因为如果不提升这种子查询，那么它执行的时候就会产生一个嵌套循环，这种嵌套循环的执行代价是O(N^2)，这种复杂度已经是最坏的情况了，提升上来至少不会比它差，因此提升上来是有价值的。”大明心里对自己的临危不乱暗暗点了个赞。</p>\n<p>大明看小明没有提问，继续说道：“这些基于关系代数等价规则做等价变换的优化，就是基于规则的优化，当然数据库本身也会结合实际的经验，产生一些优化规则，比如外连接消除，因为外连接优化起来不太方便，如果能把它消除掉，我们就有了更大的优化空间，这些统统都是基于规则的优化。同时这些都是建立在逻辑操作符上的优化，这也是为什么基于规则的优化也叫做逻辑优化。”</p>\n<p>小明想了想，自己好像对逻辑操作符不太理解，连忙问：“逻辑操作符是啥？既然有物理优化，难道还有物理操作符吗？”</p>\n<p>大明看自己的烟已经烧的只剩下过滤嘴了，连忙把烟头扔到烟灰缸，伸个懒腰继续说：“比如说吧，你在SQL语句里写上了两个表要做一个左外连接，那么数据库怎么来做这个左外连接呢？”</p>\n<p>小明一头雾水的摇摇头，对大明投出了期待的眼神。</p>\n<p>大明自问自答的继续说道：“数据库说我也不知道啊，你说的左外连接意思我懂，但我也不知道怎么实现啊？你需要告诉我实现方法啊，因此优化器还承担了一个任务，就是告诉执行器，怎么来实现一个左外连接。”</p>\n<p>大明一边说，一边从茶几上把烟拿起来，准备再抽一根，却尴尬的发现，烟盒里一根烟都没有了，大明把空烟盒弹进垃圾桶，继续说：“数据库有哪些方法来实现一个左外连接呢？它可以用嵌套循环连接、哈希连接、归并连接等等，注意了，重要的事情说三遍，你看内连接、外连接是连接操作，嵌套循环连接、归并连接等也叫连接，但内连接、外连接这些就是逻辑操作符，而嵌套循环连接、归并连接这些就是物理操作符。所以你说对了，物理优化就是建立在物理操作符上的优化。”</p>\n<p>大明又问小明：“你要从北京去上海，你说你怎么去？”</p>\n<p>小明说：“坐高铁啊，又快又方便。”</p>\n<p>大明继续问：“做高铁先去广州，然后倒车到上海行不行？”</p>\n<p>小明说：“有点扎心了，这不是吃饱了撑的吗？”</p>\n<p>大明追问：“为什么？”</p>\n<p>小明说：“很明显，我有直达的高铁，即节省时间，又节省费用，先去广州再倒车？我脑子瓦特了？！”</p>\n<p>大明笑了笑说：“不知不觉之间，你的大脑就建立了一个代价模型，那就是性价比，优化器作为数据库的大脑，也需要建立代价模型，对物理操作符计算代价，然后筛选出最优的物理操作符来，因此基于代价的优化是建立在物理操作符上的优化，所以也叫物理优化。”</p>\n<p>小明觉得似乎懂了：“公司派我去上海出差就是一个逻辑操作符，它和我们写一个SQL语句要求数据库对两个表做左外连接类似，而去上海的实际路径有很多种，这些就像是物理操作符，我们对这些实际的物理路径计算代价之后，就可以选出来最好的路径了。”</p>\n<p>大明掏出手机，分别打开了白兔地图APP和高达地图APP，输入了北京到上海的信息，然后拿给小明看，小明发现两家APP给出的最优路径是不一样的。小明若有所思的说：“看来代价模型很重要，代价模型是不是准确决定了最优路径选择的是不是准确。”<br>大明一拍大腿，笑着说：“太对了，所以我作为一个数据库内核的资深开发人员，需要不断的调整优化器的代价模型，以期望获得一个相对稳定的代价模型，不过仍然是任重道远啊。”</p>\n","site":{"data":{}},"excerpt":"<p>小明考上了北清大学的计算机研究生，今年学校开了数据库原理的课程，小明对查询优化的部分不是很理解，虽然已经使出了洪荒之力，仍然觉得其中的部分原理有些晦涩难懂，于是小明打算问一下自己的哥哥大明，大明是一位资深的数据库内核开发的老码农，对Greenplum/HAWQ数据库有多年的内核开发经验</p>","more":"，厚厚眼镜片上的圈圈像年轮一样深深的见证着大明十多年的从业经历，知道小明要来问问题，大明有点紧张，虽然自己做数据库内核好多年了，但是对优化器研究却不深入，如果被小明这样的小菜鸟问倒就尴尬了，于是大明只好临时抱佛脚，拿出了好多年不看的《数据库系统实现》啃了起来。<p></p>\n<p>小明提出的第一个问题是：“为什么数据库要进行查询优化？”</p>\n<p>大明推了推鼻梁上的眼镜，点上了一根中华深吸一口，火红的烟头奋力燃烧，由明及暗，几片烟灰飘飘渺渺的散落下来，又和大明吐出的云雾交缠在一起，即轻盈又律动，大明弹了弹烟灰，慢条斯理的说：“不止是数据库要进行优化，基本上所有的编程语言在编译的时候都会优化，比如你在编译C语言的时候，可以通过编译选项-o来指定进行哪个级别的优化，但是查询数据库的查询优化和C语言的优化还有些区别。”</p>\n<p>“有哪些区别呢？”大明停顿了一下，凝视着小明，仿佛期望小明给出答案，或者是给小明腾挪出足够思考的空间，三五秒之后大明又自问自答道：“C语言是过程化语言，你已经指定好了需要执行的每一个步骤，但是SQL是描述性语言，它只指定了WHAT，而没有指定HOW，这样它的优化空间就大了，你说是不是？”</p>\n<p>小明点了点头说：“对，也就是说条条大路通罗马，它比过程语言的选择更多，是不是这样？”大明笑道：“孺子可教也。虽然我们知道它的优化空间大，但具体如何优化呢？”</p>\n<p>说着大明将身子向沙发里靠以靠，翘上二郎腿继续说：“通常来说分成两个层面，一个是基于规则的优化，另一个是基于代价的优化，基于规则的优化也可以叫逻辑优化或者规则优化，基于代价的优化也可以叫物理优化或者代价优化。”大明边说边用手比划着，手里的烟火也欢快的跳跃着。</p>\n<p>“那为什么要进行这样的区分呢？优化就优化嘛，何必还分什么规则和代价呢？”，小明问道。</p>\n<p>“分层不分层不是重点，有些优化器层次分的清楚点，有些优化器层次分的就不那么清楚，都只是优化手段而已。”大明感到有点心虚，再这么问下去恐怕要被问住，于是试图引开话题：“我们继续说说SQL语言吧，我们说它是一种介于关系演算和关系代数之间的语言，关系演算和关系代数你看过吧？”</p>\n<p>小明想了想，好像自己上课的时候老师说过关系代数，但是没有说关系演算，于是说：“接触过一点，但也不是特别明白。”大明得意的说：“关系演算是纯描述性的语言，而关系代数呢，则包含了一些基本的关系操作，SQL主要借鉴的是关系演算，也包含了关系代数的一部分特点。”</p>\n<p>大明看小明有点懵，顿了一下，然后继续说道：“你们上课的时候老师有没有说过关系代数的基本操作？”小明想了一下说：“好像说了，有投影、选择、连接、交集、差集这几个。”大明点点头说：“对的，还可以有一个叫重命名的，一共6个基本操作，另外结合实际应用在这些基本操作之上又扩展出了外连接、半连接、聚集操作、分组操作等等。”</p>\n<p>大明又深吸了一口烟，优雅的吐了个烟圈，继续说道：“SQL语句虽然是描述性的，但是我们可以把它转化成一个关系代数表达式，而关系代数中呢，又有一些等价的规则，这样我们就能结合这些等价规则对关系代数表达式进行等价的转换。”</p>\n<p>“进行等价转换的目的是找到性能更好的代数表达式吧？”小明问。</p>\n<p>“对，就是这样。”大明投来赞许的目光。</p>\n<p>“那么如何确定等价变换之后的表达式就能变得比变换之前性能更好呢？或者说为什么我们要进行这样的等价变换，而不是使用原来的表达式呢？”</p>\n<p>大明愣了一下，仿佛没有想到小明会提出这样的问题，但是基于自己多年的忽悠经验，他定了定神，回答道：“这既有经验的成分，也有量化的考虑。例如将选择操作下推，就能优先过滤数据，那么表达式的上层计算结点就能降低计算量，因此很容易可以知道是能降低代价的。再例如我们通常会对相关的子查询进行提升，这是因为如果不提升这种子查询，那么它执行的时候就会产生一个嵌套循环，这种嵌套循环的执行代价是O(N^2)，这种复杂度已经是最坏的情况了，提升上来至少不会比它差，因此提升上来是有价值的。”大明心里对自己的临危不乱暗暗点了个赞。</p>\n<p>大明看小明没有提问，继续说道：“这些基于关系代数等价规则做等价变换的优化，就是基于规则的优化，当然数据库本身也会结合实际的经验，产生一些优化规则，比如外连接消除，因为外连接优化起来不太方便，如果能把它消除掉，我们就有了更大的优化空间，这些统统都是基于规则的优化。同时这些都是建立在逻辑操作符上的优化，这也是为什么基于规则的优化也叫做逻辑优化。”</p>\n<p>小明想了想，自己好像对逻辑操作符不太理解，连忙问：“逻辑操作符是啥？既然有物理优化，难道还有物理操作符吗？”</p>\n<p>大明看自己的烟已经烧的只剩下过滤嘴了，连忙把烟头扔到烟灰缸，伸个懒腰继续说：“比如说吧，你在SQL语句里写上了两个表要做一个左外连接，那么数据库怎么来做这个左外连接呢？”</p>\n<p>小明一头雾水的摇摇头，对大明投出了期待的眼神。</p>\n<p>大明自问自答的继续说道：“数据库说我也不知道啊，你说的左外连接意思我懂，但我也不知道怎么实现啊？你需要告诉我实现方法啊，因此优化器还承担了一个任务，就是告诉执行器，怎么来实现一个左外连接。”</p>\n<p>大明一边说，一边从茶几上把烟拿起来，准备再抽一根，却尴尬的发现，烟盒里一根烟都没有了，大明把空烟盒弹进垃圾桶，继续说：“数据库有哪些方法来实现一个左外连接呢？它可以用嵌套循环连接、哈希连接、归并连接等等，注意了，重要的事情说三遍，你看内连接、外连接是连接操作，嵌套循环连接、归并连接等也叫连接，但内连接、外连接这些就是逻辑操作符，而嵌套循环连接、归并连接这些就是物理操作符。所以你说对了，物理优化就是建立在物理操作符上的优化。”</p>\n<p>大明又问小明：“你要从北京去上海，你说你怎么去？”</p>\n<p>小明说：“坐高铁啊，又快又方便。”</p>\n<p>大明继续问：“做高铁先去广州，然后倒车到上海行不行？”</p>\n<p>小明说：“有点扎心了，这不是吃饱了撑的吗？”</p>\n<p>大明追问：“为什么？”</p>\n<p>小明说：“很明显，我有直达的高铁，即节省时间，又节省费用，先去广州再倒车？我脑子瓦特了？！”</p>\n<p>大明笑了笑说：“不知不觉之间，你的大脑就建立了一个代价模型，那就是性价比，优化器作为数据库的大脑，也需要建立代价模型，对物理操作符计算代价，然后筛选出最优的物理操作符来，因此基于代价的优化是建立在物理操作符上的优化，所以也叫物理优化。”</p>\n<p>小明觉得似乎懂了：“公司派我去上海出差就是一个逻辑操作符，它和我们写一个SQL语句要求数据库对两个表做左外连接类似，而去上海的实际路径有很多种，这些就像是物理操作符，我们对这些实际的物理路径计算代价之后，就可以选出来最好的路径了。”</p>\n<p>大明掏出手机，分别打开了白兔地图APP和高达地图APP，输入了北京到上海的信息，然后拿给小明看，小明发现两家APP给出的最优路径是不一样的。小明若有所思的说：“看来代价模型很重要，代价模型是不是准确决定了最优路径选择的是不是准确。”<br>大明一拍大腿，笑着说：“太对了，所以我作为一个数据库内核的资深开发人员，需要不断的调整优化器的代价模型，以期望获得一个相对稳定的代价模型，不过仍然是任重道远啊。”</p>"},{"title":"PostgreSQL优化器白话(2) - SQL进化史","date":"2020-08-02T00:56:06.000Z","_content":"\n通过大明给小明解释了查询优化器的基本原理，小明在学校的数据库原理课堂上顺风顺水，每天吃饭睡觉打豆豆，日子过得非常悠哉，不过眼看就到了数据库原理的实践课了，老师给出的题目是分析一个数据库的某一模块的实现，小明千挑万选，终于选定了要分析PostgreSQL数据库的查询优化器的实现，因为据说PostgreSQL数据库的查询优化器层（相）次（当）清（复）楚（杂），具有教科书级的示范作用。<!-- more -->\n\t\n可是当小明下载了PostgreSQL数据库的源代码，顿时就懵圈了，虽然平时理论说的天花乱坠，但是到了实践的时候却发现，理论和实际对应不上，小明深深的陷入到代码的细节里面不可自拔，小明查阅了好多资料，结果是读破书万卷，下笔如有锤，一点进展就没有。于是小明又想到了自己的哥哥——大明，他作为Greenplum/HAWQ数据库的资深的数据库内核老码农，不是和PostgreSQL数据库有着不解之缘吗？想必他一定能站得更高，看的更远，于是小明蹬着自己的宝马向大明驶去。\n\t\n大明接到了小明要来“视察”的消息，早就做好了准备，大明也只是在工作中偶尔接触一下优化器，也没有对查询优化器有多熟悉，正好借着这次机会自己也对优化器进行了一番学习。看着小明大汗淋漓的走进了门，大明从冰箱里拿了一根从菜市场买的巧牙兹，意味深长的说：“小明同学，PostgreSQL数据库的查询优化器功能比较多，恐怕一次说不完，我们把它分成几次来说清楚吧。”\n\n小明虽然感觉冰棍的味道有点偏差，但觉得大明说得有道理，因为自己通过查看PostgreSQL数据库的源码的确非常复杂，于是说：“的确是的，我在看查询优化器代码的时候，觉得无从下手，虽然查询优化的一些理论我学过了，但是不知道代码和理论如何对应，而且还有一些优化规则好像我们讲数据库原理的时候也没有涉及到，毕竟理论和实践之间还有一些差距。”\n\n大明打开电脑，调出了PostgreSQL的代码，然后说：“我们先来看一下PostgreSQL数据库一个查询执行的基本流程。”，然后大明调出了一张图。\n\n![](./postgresql-optimizer-outline-2/1.jpg) \n \n小明觉得这张图似曾相识，又不知道在哪见过，于是说：“我好像见过这张图。”大明点点头说：“是的，大部分查询优化的培训都是从这张图开始的，不过这张图是我自己画的，你看到的那些图表达的意思应该是一样的，但它的形式可能略有不同，这种图已经成了优化器培训开篇的必备图了，不过我们还是有必要借助这张图来看一下PostgreSQL数据库源码的大体结构，了解查询优化器所处的位置。”\n\t\n大明一边指点着电脑屏幕，一边继续说：“我们要执行一条SQL语句，首先会进行词法分析，也就是说把SQL语句做一个分割，分成很多小段段。。。”小明连忙说：“我们在学编译原理的时候老师说了，分成的小段段可以是关键字、标识符、常量、运算符和边界符，是不是分词之后就会给这些小段段赋予上这些语义？”\n\n“对的！看来你对编译原理的第一章很熟悉嘛。”大明笑着说。\n\t\n“当然，我最擅长写Hello World。”\n\t\n“好吧，Let’s 继续，PostgreSQL的分词是在scan.l文件中完成的，它可能分的更细致一些，比如常量它就分成了SCONST、FCONST、ICONST等等，不过基本的原理是一样的。进行分词并且给每个单词以语义之后，就可以去匹配gram.y里的语法规则了，在gram.y文件里定义了所有的SQL语言的语法规则，我们的查询经过匹配之后，最终形成了一颗语法树。”\n\t\n“语法树？我还听过什么查询树、计划树，这些树要怎么区分呢？”\n\t\n“一个查询语句在不同的阶段，生成的树是不同的，这些树的顺序应该是先生成语法树，然后得到查询树，最终得到计划树，计划树就是我们说的执行计划。”\n\t\n“那么为什么要做这些转换呢？”小明不解的问。\n\t\n“我们通过词法分析、语法分析获得了语法树，但这时的语法树还和SQL语句有很紧密的关系，比如我们在语法树中保存的还是一个表的名字，一个列的名字，但实际上在PostgreSQL数据库数据库中，有很多系统表，比如PG_CLASS用来将表保存成数据库的内部结构，当我们创建一个表的时候，会在PG_CLASS、PG_ATTRIBUTE等等系统表里增加新的元数据，我们要用这些元数据的信息取代语法树中的表的名字、列的名字等等。”\n\t\n小明想了想，说：“这个取代的过程就是语义分析？这样就把语法树转换成了查询树，而查询树是使用元数据来描述的，所以我们在数据库内核中使用它就更方便了？”\n\t\n“是的。”大明肯定的说。“不过语义分析还做了一个工作，那就是检查工作，在语法树是通过分析SQL语句获得的，它还不知道一个表是不是存在，一个列是不是存在，这个转换的过程，也是一个检查的过程。”大明停顿了一下，似乎是做了一下思考，然后拿出一张纸，在上边画了起来。\n\n![](postgresql-optimizer-outline-2/2.jpg) \n\n“这是SQL语句SELECT st.sname, c.cname, sc.degree FROM STUDENT st , COURSE c INNER JOIN SCORE sc ON c.cno = sc.cno WHERE st.sno = sc.sno对应的简版查询树，看着复杂吗？”大明边画边问。小明心中翻腾出千万只泥马，他似乎感觉到自己选择查询优化作为数据库原理课的实践作业是一个错误的决定，现在自己已经受到了冲动的惩罚，这个图里的大部分内容他都不知道是什么东西。\n\n看着小明迷离的眼神，大明有点发慌，说：“我们现在还不用深入到代码层面，你可以忽略这张图，现在可以把查询树认为是一个关系代数表达式。”\n\n小明定了定神，问道：“关系代数表达式？上次我咨询你查询优化原理的时候你是不是说基于规则的优化就是使用关系代数的等价规则对关系代数表达式进行等价的变换，所以查询优化器的工作就是用这个查询树做等价变换？”\n\n“恭喜你，答对了。”大明暗暗赞许小明的理解能力还有记忆力，继续说：“查询树就是查询优化器的输入，经过逻辑优化和物理优化，最终产生一颗最优的计划树，而我们要做的就会看看查询优化器是如何产生这棵最优的计划树的。”\n\n这时门铃响了，小明打开门一看，原来是吃了吗外卖到了，小明拎着外卖说：“看来我们先要饱餐战饭，然后才能看查询树的变换过程了。”说着打开送餐包装，美美的吃起了大腰子，而大明则已经从酒柜里拿出了珍藏的红酒。。。\n","source":"_posts/postgresql-optimizer-outline-2.md","raw":"---\ntitle: PostgreSQL优化器白话(2) - SQL进化史\ndate: 2020-08-02 08:56:06\n---\n\n通过大明给小明解释了查询优化器的基本原理，小明在学校的数据库原理课堂上顺风顺水，每天吃饭睡觉打豆豆，日子过得非常悠哉，不过眼看就到了数据库原理的实践课了，老师给出的题目是分析一个数据库的某一模块的实现，小明千挑万选，终于选定了要分析PostgreSQL数据库的查询优化器的实现，因为据说PostgreSQL数据库的查询优化器层（相）次（当）清（复）楚（杂），具有教科书级的示范作用。<!-- more -->\n\t\n可是当小明下载了PostgreSQL数据库的源代码，顿时就懵圈了，虽然平时理论说的天花乱坠，但是到了实践的时候却发现，理论和实际对应不上，小明深深的陷入到代码的细节里面不可自拔，小明查阅了好多资料，结果是读破书万卷，下笔如有锤，一点进展就没有。于是小明又想到了自己的哥哥——大明，他作为Greenplum/HAWQ数据库的资深的数据库内核老码农，不是和PostgreSQL数据库有着不解之缘吗？想必他一定能站得更高，看的更远，于是小明蹬着自己的宝马向大明驶去。\n\t\n大明接到了小明要来“视察”的消息，早就做好了准备，大明也只是在工作中偶尔接触一下优化器，也没有对查询优化器有多熟悉，正好借着这次机会自己也对优化器进行了一番学习。看着小明大汗淋漓的走进了门，大明从冰箱里拿了一根从菜市场买的巧牙兹，意味深长的说：“小明同学，PostgreSQL数据库的查询优化器功能比较多，恐怕一次说不完，我们把它分成几次来说清楚吧。”\n\n小明虽然感觉冰棍的味道有点偏差，但觉得大明说得有道理，因为自己通过查看PostgreSQL数据库的源码的确非常复杂，于是说：“的确是的，我在看查询优化器代码的时候，觉得无从下手，虽然查询优化的一些理论我学过了，但是不知道代码和理论如何对应，而且还有一些优化规则好像我们讲数据库原理的时候也没有涉及到，毕竟理论和实践之间还有一些差距。”\n\n大明打开电脑，调出了PostgreSQL的代码，然后说：“我们先来看一下PostgreSQL数据库一个查询执行的基本流程。”，然后大明调出了一张图。\n\n![](./postgresql-optimizer-outline-2/1.jpg) \n \n小明觉得这张图似曾相识，又不知道在哪见过，于是说：“我好像见过这张图。”大明点点头说：“是的，大部分查询优化的培训都是从这张图开始的，不过这张图是我自己画的，你看到的那些图表达的意思应该是一样的，但它的形式可能略有不同，这种图已经成了优化器培训开篇的必备图了，不过我们还是有必要借助这张图来看一下PostgreSQL数据库源码的大体结构，了解查询优化器所处的位置。”\n\t\n大明一边指点着电脑屏幕，一边继续说：“我们要执行一条SQL语句，首先会进行词法分析，也就是说把SQL语句做一个分割，分成很多小段段。。。”小明连忙说：“我们在学编译原理的时候老师说了，分成的小段段可以是关键字、标识符、常量、运算符和边界符，是不是分词之后就会给这些小段段赋予上这些语义？”\n\n“对的！看来你对编译原理的第一章很熟悉嘛。”大明笑着说。\n\t\n“当然，我最擅长写Hello World。”\n\t\n“好吧，Let’s 继续，PostgreSQL的分词是在scan.l文件中完成的，它可能分的更细致一些，比如常量它就分成了SCONST、FCONST、ICONST等等，不过基本的原理是一样的。进行分词并且给每个单词以语义之后，就可以去匹配gram.y里的语法规则了，在gram.y文件里定义了所有的SQL语言的语法规则，我们的查询经过匹配之后，最终形成了一颗语法树。”\n\t\n“语法树？我还听过什么查询树、计划树，这些树要怎么区分呢？”\n\t\n“一个查询语句在不同的阶段，生成的树是不同的，这些树的顺序应该是先生成语法树，然后得到查询树，最终得到计划树，计划树就是我们说的执行计划。”\n\t\n“那么为什么要做这些转换呢？”小明不解的问。\n\t\n“我们通过词法分析、语法分析获得了语法树，但这时的语法树还和SQL语句有很紧密的关系，比如我们在语法树中保存的还是一个表的名字，一个列的名字，但实际上在PostgreSQL数据库数据库中，有很多系统表，比如PG_CLASS用来将表保存成数据库的内部结构，当我们创建一个表的时候，会在PG_CLASS、PG_ATTRIBUTE等等系统表里增加新的元数据，我们要用这些元数据的信息取代语法树中的表的名字、列的名字等等。”\n\t\n小明想了想，说：“这个取代的过程就是语义分析？这样就把语法树转换成了查询树，而查询树是使用元数据来描述的，所以我们在数据库内核中使用它就更方便了？”\n\t\n“是的。”大明肯定的说。“不过语义分析还做了一个工作，那就是检查工作，在语法树是通过分析SQL语句获得的，它还不知道一个表是不是存在，一个列是不是存在，这个转换的过程，也是一个检查的过程。”大明停顿了一下，似乎是做了一下思考，然后拿出一张纸，在上边画了起来。\n\n![](postgresql-optimizer-outline-2/2.jpg) \n\n“这是SQL语句SELECT st.sname, c.cname, sc.degree FROM STUDENT st , COURSE c INNER JOIN SCORE sc ON c.cno = sc.cno WHERE st.sno = sc.sno对应的简版查询树，看着复杂吗？”大明边画边问。小明心中翻腾出千万只泥马，他似乎感觉到自己选择查询优化作为数据库原理课的实践作业是一个错误的决定，现在自己已经受到了冲动的惩罚，这个图里的大部分内容他都不知道是什么东西。\n\n看着小明迷离的眼神，大明有点发慌，说：“我们现在还不用深入到代码层面，你可以忽略这张图，现在可以把查询树认为是一个关系代数表达式。”\n\n小明定了定神，问道：“关系代数表达式？上次我咨询你查询优化原理的时候你是不是说基于规则的优化就是使用关系代数的等价规则对关系代数表达式进行等价的变换，所以查询优化器的工作就是用这个查询树做等价变换？”\n\n“恭喜你，答对了。”大明暗暗赞许小明的理解能力还有记忆力，继续说：“查询树就是查询优化器的输入，经过逻辑优化和物理优化，最终产生一颗最优的计划树，而我们要做的就会看看查询优化器是如何产生这棵最优的计划树的。”\n\n这时门铃响了，小明打开门一看，原来是吃了吗外卖到了，小明拎着外卖说：“看来我们先要饱餐战饭，然后才能看查询树的变换过程了。”说着打开送餐包装，美美的吃起了大腰子，而大明则已经从酒柜里拿出了珍藏的红酒。。。\n","slug":"postgresql-optimizer-outline-2","published":1,"updated":"2020-08-02T01:43:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdchg8je0002r2s686meddyz","content":"<p>通过大明给小明解释了查询优化器的基本原理，小明在学校的数据库原理课堂上顺风顺水，每天吃饭睡觉打豆豆，日子过得非常悠哉，不过眼看就到了数据库原理的实践课了，老师给出的题目是分析一个数据库的某一模块的实现，小明千挑万选，终于选定了要分析PostgreSQL数据库的查询优化器的实现，因为据说PostgreSQL数据库的查询优化器层（相）次（当）清（复）楚（杂），具有教科书级的示范作用。<a id=\"more\"></a></p>\n<p>可是当小明下载了PostgreSQL数据库的源代码，顿时就懵圈了，虽然平时理论说的天花乱坠，但是到了实践的时候却发现，理论和实际对应不上，小明深深的陷入到代码的细节里面不可自拔，小明查阅了好多资料，结果是读破书万卷，下笔如有锤，一点进展就没有。于是小明又想到了自己的哥哥——大明，他作为Greenplum/HAWQ数据库的资深的数据库内核老码农，不是和PostgreSQL数据库有着不解之缘吗？想必他一定能站得更高，看的更远，于是小明蹬着自己的宝马向大明驶去。</p>\n<p>大明接到了小明要来“视察”的消息，早就做好了准备，大明也只是在工作中偶尔接触一下优化器，也没有对查询优化器有多熟悉，正好借着这次机会自己也对优化器进行了一番学习。看着小明大汗淋漓的走进了门，大明从冰箱里拿了一根从菜市场买的巧牙兹，意味深长的说：“小明同学，PostgreSQL数据库的查询优化器功能比较多，恐怕一次说不完，我们把它分成几次来说清楚吧。”</p>\n<p>小明虽然感觉冰棍的味道有点偏差，但觉得大明说得有道理，因为自己通过查看PostgreSQL数据库的源码的确非常复杂，于是说：“的确是的，我在看查询优化器代码的时候，觉得无从下手，虽然查询优化的一些理论我学过了，但是不知道代码和理论如何对应，而且还有一些优化规则好像我们讲数据库原理的时候也没有涉及到，毕竟理论和实践之间还有一些差距。”</p>\n<p>大明打开电脑，调出了PostgreSQL的代码，然后说：“我们先来看一下PostgreSQL数据库一个查询执行的基本流程。”，然后大明调出了一张图。</p>\n<p><img src=\"/2020/08/02/postgresql-optimizer-outline-2/1.jpg\"> </p>\n<p>小明觉得这张图似曾相识，又不知道在哪见过，于是说：“我好像见过这张图。”大明点点头说：“是的，大部分查询优化的培训都是从这张图开始的，不过这张图是我自己画的，你看到的那些图表达的意思应该是一样的，但它的形式可能略有不同，这种图已经成了优化器培训开篇的必备图了，不过我们还是有必要借助这张图来看一下PostgreSQL数据库源码的大体结构，了解查询优化器所处的位置。”</p>\n<p>大明一边指点着电脑屏幕，一边继续说：“我们要执行一条SQL语句，首先会进行词法分析，也就是说把SQL语句做一个分割，分成很多小段段。。。”小明连忙说：“我们在学编译原理的时候老师说了，分成的小段段可以是关键字、标识符、常量、运算符和边界符，是不是分词之后就会给这些小段段赋予上这些语义？”</p>\n<p>“对的！看来你对编译原理的第一章很熟悉嘛。”大明笑着说。</p>\n<p>“当然，我最擅长写Hello World。”</p>\n<p>“好吧，Let’s 继续，PostgreSQL的分词是在scan.l文件中完成的，它可能分的更细致一些，比如常量它就分成了SCONST、FCONST、ICONST等等，不过基本的原理是一样的。进行分词并且给每个单词以语义之后，就可以去匹配gram.y里的语法规则了，在gram.y文件里定义了所有的SQL语言的语法规则，我们的查询经过匹配之后，最终形成了一颗语法树。”</p>\n<p>“语法树？我还听过什么查询树、计划树，这些树要怎么区分呢？”</p>\n<p>“一个查询语句在不同的阶段，生成的树是不同的，这些树的顺序应该是先生成语法树，然后得到查询树，最终得到计划树，计划树就是我们说的执行计划。”</p>\n<p>“那么为什么要做这些转换呢？”小明不解的问。</p>\n<p>“我们通过词法分析、语法分析获得了语法树，但这时的语法树还和SQL语句有很紧密的关系，比如我们在语法树中保存的还是一个表的名字，一个列的名字，但实际上在PostgreSQL数据库数据库中，有很多系统表，比如PG_CLASS用来将表保存成数据库的内部结构，当我们创建一个表的时候，会在PG_CLASS、PG_ATTRIBUTE等等系统表里增加新的元数据，我们要用这些元数据的信息取代语法树中的表的名字、列的名字等等。”</p>\n<p>小明想了想，说：“这个取代的过程就是语义分析？这样就把语法树转换成了查询树，而查询树是使用元数据来描述的，所以我们在数据库内核中使用它就更方便了？”</p>\n<p>“是的。”大明肯定的说。“不过语义分析还做了一个工作，那就是检查工作，在语法树是通过分析SQL语句获得的，它还不知道一个表是不是存在，一个列是不是存在，这个转换的过程，也是一个检查的过程。”大明停顿了一下，似乎是做了一下思考，然后拿出一张纸，在上边画了起来。</p>\n<p><img src=\"/2020/08/02/postgresql-optimizer-outline-2/2.jpg\"> </p>\n<p>“这是SQL语句SELECT st.sname, c.cname, sc.degree FROM STUDENT st , COURSE c INNER JOIN SCORE sc ON c.cno = sc.cno WHERE st.sno = sc.sno对应的简版查询树，看着复杂吗？”大明边画边问。小明心中翻腾出千万只泥马，他似乎感觉到自己选择查询优化作为数据库原理课的实践作业是一个错误的决定，现在自己已经受到了冲动的惩罚，这个图里的大部分内容他都不知道是什么东西。</p>\n<p>看着小明迷离的眼神，大明有点发慌，说：“我们现在还不用深入到代码层面，你可以忽略这张图，现在可以把查询树认为是一个关系代数表达式。”</p>\n<p>小明定了定神，问道：“关系代数表达式？上次我咨询你查询优化原理的时候你是不是说基于规则的优化就是使用关系代数的等价规则对关系代数表达式进行等价的变换，所以查询优化器的工作就是用这个查询树做等价变换？”</p>\n<p>“恭喜你，答对了。”大明暗暗赞许小明的理解能力还有记忆力，继续说：“查询树就是查询优化器的输入，经过逻辑优化和物理优化，最终产生一颗最优的计划树，而我们要做的就会看看查询优化器是如何产生这棵最优的计划树的。”</p>\n<p>这时门铃响了，小明打开门一看，原来是吃了吗外卖到了，小明拎着外卖说：“看来我们先要饱餐战饭，然后才能看查询树的变换过程了。”说着打开送餐包装，美美的吃起了大腰子，而大明则已经从酒柜里拿出了珍藏的红酒。。。</p>\n","site":{"data":{}},"excerpt":"<p>通过大明给小明解释了查询优化器的基本原理，小明在学校的数据库原理课堂上顺风顺水，每天吃饭睡觉打豆豆，日子过得非常悠哉，不过眼看就到了数据库原理的实践课了，老师给出的题目是分析一个数据库的某一模块的实现，小明千挑万选，终于选定了要分析PostgreSQL数据库的查询优化器的实现，因为据说PostgreSQL数据库的查询优化器层（相）次（当）清（复）楚（杂），具有教科书级的示范作用。</p>","more":"<p></p>\n<p>可是当小明下载了PostgreSQL数据库的源代码，顿时就懵圈了，虽然平时理论说的天花乱坠，但是到了实践的时候却发现，理论和实际对应不上，小明深深的陷入到代码的细节里面不可自拔，小明查阅了好多资料，结果是读破书万卷，下笔如有锤，一点进展就没有。于是小明又想到了自己的哥哥——大明，他作为Greenplum/HAWQ数据库的资深的数据库内核老码农，不是和PostgreSQL数据库有着不解之缘吗？想必他一定能站得更高，看的更远，于是小明蹬着自己的宝马向大明驶去。</p>\n<p>大明接到了小明要来“视察”的消息，早就做好了准备，大明也只是在工作中偶尔接触一下优化器，也没有对查询优化器有多熟悉，正好借着这次机会自己也对优化器进行了一番学习。看着小明大汗淋漓的走进了门，大明从冰箱里拿了一根从菜市场买的巧牙兹，意味深长的说：“小明同学，PostgreSQL数据库的查询优化器功能比较多，恐怕一次说不完，我们把它分成几次来说清楚吧。”</p>\n<p>小明虽然感觉冰棍的味道有点偏差，但觉得大明说得有道理，因为自己通过查看PostgreSQL数据库的源码的确非常复杂，于是说：“的确是的，我在看查询优化器代码的时候，觉得无从下手，虽然查询优化的一些理论我学过了，但是不知道代码和理论如何对应，而且还有一些优化规则好像我们讲数据库原理的时候也没有涉及到，毕竟理论和实践之间还有一些差距。”</p>\n<p>大明打开电脑，调出了PostgreSQL的代码，然后说：“我们先来看一下PostgreSQL数据库一个查询执行的基本流程。”，然后大明调出了一张图。</p>\n<p><img src=\"/2020/08/02/postgresql-optimizer-outline-2/1.jpg\"> </p>\n<p>小明觉得这张图似曾相识，又不知道在哪见过，于是说：“我好像见过这张图。”大明点点头说：“是的，大部分查询优化的培训都是从这张图开始的，不过这张图是我自己画的，你看到的那些图表达的意思应该是一样的，但它的形式可能略有不同，这种图已经成了优化器培训开篇的必备图了，不过我们还是有必要借助这张图来看一下PostgreSQL数据库源码的大体结构，了解查询优化器所处的位置。”</p>\n<p>大明一边指点着电脑屏幕，一边继续说：“我们要执行一条SQL语句，首先会进行词法分析，也就是说把SQL语句做一个分割，分成很多小段段。。。”小明连忙说：“我们在学编译原理的时候老师说了，分成的小段段可以是关键字、标识符、常量、运算符和边界符，是不是分词之后就会给这些小段段赋予上这些语义？”</p>\n<p>“对的！看来你对编译原理的第一章很熟悉嘛。”大明笑着说。</p>\n<p>“当然，我最擅长写Hello World。”</p>\n<p>“好吧，Let’s 继续，PostgreSQL的分词是在scan.l文件中完成的，它可能分的更细致一些，比如常量它就分成了SCONST、FCONST、ICONST等等，不过基本的原理是一样的。进行分词并且给每个单词以语义之后，就可以去匹配gram.y里的语法规则了，在gram.y文件里定义了所有的SQL语言的语法规则，我们的查询经过匹配之后，最终形成了一颗语法树。”</p>\n<p>“语法树？我还听过什么查询树、计划树，这些树要怎么区分呢？”</p>\n<p>“一个查询语句在不同的阶段，生成的树是不同的，这些树的顺序应该是先生成语法树，然后得到查询树，最终得到计划树，计划树就是我们说的执行计划。”</p>\n<p>“那么为什么要做这些转换呢？”小明不解的问。</p>\n<p>“我们通过词法分析、语法分析获得了语法树，但这时的语法树还和SQL语句有很紧密的关系，比如我们在语法树中保存的还是一个表的名字，一个列的名字，但实际上在PostgreSQL数据库数据库中，有很多系统表，比如PG_CLASS用来将表保存成数据库的内部结构，当我们创建一个表的时候，会在PG_CLASS、PG_ATTRIBUTE等等系统表里增加新的元数据，我们要用这些元数据的信息取代语法树中的表的名字、列的名字等等。”</p>\n<p>小明想了想，说：“这个取代的过程就是语义分析？这样就把语法树转换成了查询树，而查询树是使用元数据来描述的，所以我们在数据库内核中使用它就更方便了？”</p>\n<p>“是的。”大明肯定的说。“不过语义分析还做了一个工作，那就是检查工作，在语法树是通过分析SQL语句获得的，它还不知道一个表是不是存在，一个列是不是存在，这个转换的过程，也是一个检查的过程。”大明停顿了一下，似乎是做了一下思考，然后拿出一张纸，在上边画了起来。</p>\n<p><img src=\"/2020/08/02/postgresql-optimizer-outline-2/2.jpg\"> </p>\n<p>“这是SQL语句SELECT st.sname, c.cname, sc.degree FROM STUDENT st , COURSE c INNER JOIN SCORE sc ON c.cno = sc.cno WHERE st.sno = sc.sno对应的简版查询树，看着复杂吗？”大明边画边问。小明心中翻腾出千万只泥马，他似乎感觉到自己选择查询优化作为数据库原理课的实践作业是一个错误的决定，现在自己已经受到了冲动的惩罚，这个图里的大部分内容他都不知道是什么东西。</p>\n<p>看着小明迷离的眼神，大明有点发慌，说：“我们现在还不用深入到代码层面，你可以忽略这张图，现在可以把查询树认为是一个关系代数表达式。”</p>\n<p>小明定了定神，问道：“关系代数表达式？上次我咨询你查询优化原理的时候你是不是说基于规则的优化就是使用关系代数的等价规则对关系代数表达式进行等价的变换，所以查询优化器的工作就是用这个查询树做等价变换？”</p>\n<p>“恭喜你，答对了。”大明暗暗赞许小明的理解能力还有记忆力，继续说：“查询树就是查询优化器的输入，经过逻辑优化和物理优化，最终产生一颗最优的计划树，而我们要做的就会看看查询优化器是如何产生这棵最优的计划树的。”</p>\n<p>这时门铃响了，小明打开门一看，原来是吃了吗外卖到了，小明拎着外卖说：“看来我们先要饱餐战饭，然后才能看查询树的变换过程了。”说着打开送餐包装，美美的吃起了大腰子，而大明则已经从酒柜里拿出了珍藏的红酒。。。</p>"},{"title":"PostgreSQL优化器白话(3) - 提升！提升！","date":"2020-08-02T01:25:08.000Z","_content":"\n小明发现到大明家里问问题不但能收获知识，还能收获大腰子和红酒，于是更加坚定了常来问问题的决心。\n\n小明和大明吃完了午饭，打开电视看一会电视剧，大明又惬意的惬意的抽起了中华烟，小明闻着二手烟有点心烦，就问大明：“哥，你整天抽抽抽，有那么好抽吗？”大明自豪的说：“咋地，咱爷爷抽烟，咱爸爸也抽烟，到我这不能断了香火，你不抽烟是不孝知道不？”<!-- more -->\n\n小明说：“咱爷爷抽烟是在农村种的烟叶，自给自足，还省钱，你也干脆回农村种烟叶，你这中华烟和农村的自己卷的烟叶，能有什么区别？”\n\n大明看电视剧正看得起劲，心不在焉的说：“自己种的烟叶直接用报纸卷了抽，没有过滤嘴，会吸入有害颗粒物，而且烟叶的味道也不如现在改进的香烟。”说到这里大明好像想到了些什么，继续说：“这就像是查询优化器的逻辑优化，查询树输入之后，需要进行持续的改进，无论是自己用报纸卷的烟，还是在超市买的成品烟，它都是香烟，但是通过改进之后，香烟的毒害作用更低、香型更丰富了，逻辑优化也是这个道理，通过改进查询树，能够得到一个更‘好’的查询树。”\n\n“哦，那逻辑优化是如何在已有的查询树上增加香型的呢？”\n\n大明感觉电视剧没办法看下去了，于是拿起遥控器关了电视，继续说：“我总结，PostgreSQL在逻辑优化阶段有这么几个重要的优化：子查询&子连接提升、表达式预处理、外连接消除、谓词下推、连接顺序交换、等价类推理。”大明又抽了一口烟，接着说到：“从代码逻辑上来看，我们还可以把子查询&子连接提升、表达式预处理、外连接消除叫做逻辑重写优化，因为他们主要是对查询树进行改造，而后面的谓词下推、连接顺序交换、等价类推理则可以称之为逻辑分解优化，他们已经把查询树蹂躏的不成样子了，已经到了看香烟不是香烟的地步了。”\n\n“可是我们的数据库原理课上并没有说有逻辑重写优化和逻辑分解优化啊？”\n\n“嗯，是的，这是我自己根据PostgreSQL的源代码的特征自己总结的，不过它能比较形象的将现有的逻辑优化区分开来，这样就能更好的对逻辑优化进行提炼、总结、分析。”大明想了一下觉得如果把所有的逻辑优化的规则都说完有点多，决定选择其中的一两个说一下，于是对小明说道：“我们就从中挑选一两个详细的说明一下吧，我们先从子查询&子连接的提升开始说起。”\n\n“那。。。子查询和子连接有什么区别呢？我们在数据库原理课里只讲了子查询，没有子连接的概念，这该怎么解释呢？”小明不解的问。\n\n大明去书柜里拿出了《数据库系统实现》这本书，然后翻开了对应的章节，说道：“通常数据库原理书籍中说的子查询，指的是PostgreSQL数据库中的子连接。你看，《数据库系统实现》中说的是从条件中去除子查询，但是PostgreSQL把这种情况归类为子连接。”\n\n“那在PostgreSQL是如何区分子查询和子连接的呢？”大明自问自答道：“在实际应用中可以通过子句所处的位置来区分子连接和子查询，出现在FROM关键字后的子句是子查询语句，出现在WHERE/ON等约束条件中或投影中的子句是子连接语句。”说着大明快速的在电脑上打开了记事本，敲入了几个SQL语句：\n\n```\n1. SELECT * FROM STUDENT, (SELECT * FROM SCORE) as sc;\n2. SELECT (SELECT AVG(degree) FROM SCORE), sname FROM STUDENT;\n3. SELECT * FROM STUDENT WHERE EXISTS (SELECT A FROM SCORE WHERE SCORE.sno = STUDENT.sno);\n```\n\n“这些SQL语句中哪个是子查询？哪个是子连接？”\n\n小明看了一下，然后说：“1是子查询，2和3是子连接，语句1里面的子句出现在FROM后面，它是以‘表’的形式存在的，是子查询，2和3的子句出现在投影和约束条件中，是以表达式的形式存在的，是子连接。”小明不但答对了问题，而且还对问题的答案做了扩展，大明感到很一颗赛艇，于是调侃道：“腰间盘同学，你坐下，你太突出了。”\n\n然后大明正一正颜色，继续说道“从大的方向上分类，子查询还可以分为相关子连接和非相关子连接，相关子连接是指在子查询语句中引用了外层表的列属性，这就导致外层表每获得一个元组，子查询就需要重新执行一次；而非相关子查询是指在子查询语句是独立的，和外层的表没有直接的关联，子查询可以单独执行一次，外层表可以重复利用子查询的执行结果。”\n\n“那么一定是相关子连接才会提升了，因为我记得你在说逻辑优化原理的时候说过，相关子连接会产生‘嵌套循环’，这种情况的复杂度是O(N^2)，提升上来的复杂度肯定不会比O(N^2)差，所以提升是有价值的。”小明问到。\n\n听到这些，大明顿时碉堡了，道理虽然是这个道理，但是PostgreSQL偏偏不走寻常路，和自己之前说过的有些许差异，大明羞涩的说：“虽然话是这样说，但PostgreSQL有点不同，PostgreSQL提升了两种类型的子连接，一种是ANY类型的子连接，一种是EXISTS类型的子连接，对于ANY类型的子连接，只提升非相关子连接，而对于EXISTS类型的子连接，则只提升相关子连接。”\n\n小明顿时想起了自己曾和同学说过相关子连接理论，当时把宿舍同学忽悠的五迷三道的，今天大明又说这可能是错的，心里不太爽利，于是怒道：“你之前教我的都有错误，那我和同学吹过的牛岂不是要成为笑柄？我感觉我受到了一万点上海。”\n\n“小明同学不要急”，大明安抚道：“虽然PostgreSQL对于ANY类型只提升非相关的子连接，但它仍然是只提升产生嵌套循环的那种子连接，你看看这个例子。”说着大明在电脑上又敲了一个SQL语句：\n\n```\nSELECT * FROM STUDENT WHERE sno > ANY (SELECT sno from STUDENT);\n```\n\n“这是一个ANY类型的非相关子连接，但是请注意，在>前面的sno实际上产生了一个天然的相关性，这个天然的相关性就会产生嵌套循环，因此是需要提升的。我们再来看另一个语句。”大明把语句中>前面的sno换成了一个常量：\n\n```\nSELECT * FROM STUDENT WHERE 10 > ANY (SELECT sno from STUDENT);\n```\n\n“这个SQL语句中的子连接就不会提升了，因为我们把sno换成了常量，父子之间的相关性被打破了，明白了吗？”\n\n小明点点头，心里想：子连接是否提升取决于相关性，而这个相关性不只是体现在子句里，也体现在表达式里，也就是说只要能产生嵌套循环，那就有提升的必要啊，但是。。。小明灵机一动，问道：“那ANY类型的相关子连接也会产生嵌套循环啊，为什么不提升呢？”\n\n大明说：“这可能有点历史原因了，PostgreSQL提升ANY类型的子连接的方式和EXISTS类型的子连接的方式不同，他提升EXISTS类型的子连接的时候，是直接把子句中的表提上来做形成一个SemiJoin，可是提升ANY类型的子连接的时候，是把整个子句提上来，和父语句中的表做SemiJoin，这时候这个子句就变成了一个子查询，你看这个例子。”说着大明啪啪啪的在电脑上敲了3个语句：\n\n```\n1. SELECT * FROM TEST_A WHERE a > ANY (SELECT a FROM TEST_B WHERE TEST_A.b = TEST_B.b)；\n2. SELECT * FROM TEST_A, (SELECT a FROM TEST_B WHERE TEST_A.b = TEST_B.b) b WHERE TEST_A.a > b.a;\n3. SELECT * FROM TEST_A, LATERAL (SELECT a FROM TEST_B WHERE TEST_A.b = TEST_B.b) b WHERE TEST_A.a > b.a;\n```\n\n“如果按照目前ANY类型子连接先提升成子查询的方式，第1个语句提升之后会变成等价于第2个语句，而第2个语句本身是无法执行的，在比较新的版本的PostgreSQL上支持了LATERAL之后，只要在第2个语句上加上LATERAL，也就是变成第3个语句就能执行了。”大明在屏幕上比划着说。\n\n小明问道：“那岂不是说，有了LATERAL之后，ANY类型的相关子连接也能提升了？”\n\n大明说：“只能说有一部分ANY类型的相关子连接能够提升了，比如我们上面的例1本质上就是能提升的，而且一些商业数据库确实也对这种语句做了提升，但是PostgreSQL数据库目前还没有处理这种情况。”\n\t\n小明打了个哈欠说：“实在是太累了，让我们休息一下吧，查询优化器太复杂了。”\n\n大明笑着说：“坚持不懈就能成功，万一梦想实现了呢?子连接提升之后，还有子查询提升、表达式预处理、外连接消除，不过，在这之前还是让我们先吃个鸡再说吧。”\n","source":"_posts/postgresql-optimizer-outline-3.md","raw":"---\ntitle: PostgreSQL优化器白话(3) - 提升！提升！\ndate: 2020-08-02 09:25:08\n---\n\n小明发现到大明家里问问题不但能收获知识，还能收获大腰子和红酒，于是更加坚定了常来问问题的决心。\n\n小明和大明吃完了午饭，打开电视看一会电视剧，大明又惬意的惬意的抽起了中华烟，小明闻着二手烟有点心烦，就问大明：“哥，你整天抽抽抽，有那么好抽吗？”大明自豪的说：“咋地，咱爷爷抽烟，咱爸爸也抽烟，到我这不能断了香火，你不抽烟是不孝知道不？”<!-- more -->\n\n小明说：“咱爷爷抽烟是在农村种的烟叶，自给自足，还省钱，你也干脆回农村种烟叶，你这中华烟和农村的自己卷的烟叶，能有什么区别？”\n\n大明看电视剧正看得起劲，心不在焉的说：“自己种的烟叶直接用报纸卷了抽，没有过滤嘴，会吸入有害颗粒物，而且烟叶的味道也不如现在改进的香烟。”说到这里大明好像想到了些什么，继续说：“这就像是查询优化器的逻辑优化，查询树输入之后，需要进行持续的改进，无论是自己用报纸卷的烟，还是在超市买的成品烟，它都是香烟，但是通过改进之后，香烟的毒害作用更低、香型更丰富了，逻辑优化也是这个道理，通过改进查询树，能够得到一个更‘好’的查询树。”\n\n“哦，那逻辑优化是如何在已有的查询树上增加香型的呢？”\n\n大明感觉电视剧没办法看下去了，于是拿起遥控器关了电视，继续说：“我总结，PostgreSQL在逻辑优化阶段有这么几个重要的优化：子查询&子连接提升、表达式预处理、外连接消除、谓词下推、连接顺序交换、等价类推理。”大明又抽了一口烟，接着说到：“从代码逻辑上来看，我们还可以把子查询&子连接提升、表达式预处理、外连接消除叫做逻辑重写优化，因为他们主要是对查询树进行改造，而后面的谓词下推、连接顺序交换、等价类推理则可以称之为逻辑分解优化，他们已经把查询树蹂躏的不成样子了，已经到了看香烟不是香烟的地步了。”\n\n“可是我们的数据库原理课上并没有说有逻辑重写优化和逻辑分解优化啊？”\n\n“嗯，是的，这是我自己根据PostgreSQL的源代码的特征自己总结的，不过它能比较形象的将现有的逻辑优化区分开来，这样就能更好的对逻辑优化进行提炼、总结、分析。”大明想了一下觉得如果把所有的逻辑优化的规则都说完有点多，决定选择其中的一两个说一下，于是对小明说道：“我们就从中挑选一两个详细的说明一下吧，我们先从子查询&子连接的提升开始说起。”\n\n“那。。。子查询和子连接有什么区别呢？我们在数据库原理课里只讲了子查询，没有子连接的概念，这该怎么解释呢？”小明不解的问。\n\n大明去书柜里拿出了《数据库系统实现》这本书，然后翻开了对应的章节，说道：“通常数据库原理书籍中说的子查询，指的是PostgreSQL数据库中的子连接。你看，《数据库系统实现》中说的是从条件中去除子查询，但是PostgreSQL把这种情况归类为子连接。”\n\n“那在PostgreSQL是如何区分子查询和子连接的呢？”大明自问自答道：“在实际应用中可以通过子句所处的位置来区分子连接和子查询，出现在FROM关键字后的子句是子查询语句，出现在WHERE/ON等约束条件中或投影中的子句是子连接语句。”说着大明快速的在电脑上打开了记事本，敲入了几个SQL语句：\n\n```\n1. SELECT * FROM STUDENT, (SELECT * FROM SCORE) as sc;\n2. SELECT (SELECT AVG(degree) FROM SCORE), sname FROM STUDENT;\n3. SELECT * FROM STUDENT WHERE EXISTS (SELECT A FROM SCORE WHERE SCORE.sno = STUDENT.sno);\n```\n\n“这些SQL语句中哪个是子查询？哪个是子连接？”\n\n小明看了一下，然后说：“1是子查询，2和3是子连接，语句1里面的子句出现在FROM后面，它是以‘表’的形式存在的，是子查询，2和3的子句出现在投影和约束条件中，是以表达式的形式存在的，是子连接。”小明不但答对了问题，而且还对问题的答案做了扩展，大明感到很一颗赛艇，于是调侃道：“腰间盘同学，你坐下，你太突出了。”\n\n然后大明正一正颜色，继续说道“从大的方向上分类，子查询还可以分为相关子连接和非相关子连接，相关子连接是指在子查询语句中引用了外层表的列属性，这就导致外层表每获得一个元组，子查询就需要重新执行一次；而非相关子查询是指在子查询语句是独立的，和外层的表没有直接的关联，子查询可以单独执行一次，外层表可以重复利用子查询的执行结果。”\n\n“那么一定是相关子连接才会提升了，因为我记得你在说逻辑优化原理的时候说过，相关子连接会产生‘嵌套循环’，这种情况的复杂度是O(N^2)，提升上来的复杂度肯定不会比O(N^2)差，所以提升是有价值的。”小明问到。\n\n听到这些，大明顿时碉堡了，道理虽然是这个道理，但是PostgreSQL偏偏不走寻常路，和自己之前说过的有些许差异，大明羞涩的说：“虽然话是这样说，但PostgreSQL有点不同，PostgreSQL提升了两种类型的子连接，一种是ANY类型的子连接，一种是EXISTS类型的子连接，对于ANY类型的子连接，只提升非相关子连接，而对于EXISTS类型的子连接，则只提升相关子连接。”\n\n小明顿时想起了自己曾和同学说过相关子连接理论，当时把宿舍同学忽悠的五迷三道的，今天大明又说这可能是错的，心里不太爽利，于是怒道：“你之前教我的都有错误，那我和同学吹过的牛岂不是要成为笑柄？我感觉我受到了一万点上海。”\n\n“小明同学不要急”，大明安抚道：“虽然PostgreSQL对于ANY类型只提升非相关的子连接，但它仍然是只提升产生嵌套循环的那种子连接，你看看这个例子。”说着大明在电脑上又敲了一个SQL语句：\n\n```\nSELECT * FROM STUDENT WHERE sno > ANY (SELECT sno from STUDENT);\n```\n\n“这是一个ANY类型的非相关子连接，但是请注意，在>前面的sno实际上产生了一个天然的相关性，这个天然的相关性就会产生嵌套循环，因此是需要提升的。我们再来看另一个语句。”大明把语句中>前面的sno换成了一个常量：\n\n```\nSELECT * FROM STUDENT WHERE 10 > ANY (SELECT sno from STUDENT);\n```\n\n“这个SQL语句中的子连接就不会提升了，因为我们把sno换成了常量，父子之间的相关性被打破了，明白了吗？”\n\n小明点点头，心里想：子连接是否提升取决于相关性，而这个相关性不只是体现在子句里，也体现在表达式里，也就是说只要能产生嵌套循环，那就有提升的必要啊，但是。。。小明灵机一动，问道：“那ANY类型的相关子连接也会产生嵌套循环啊，为什么不提升呢？”\n\n大明说：“这可能有点历史原因了，PostgreSQL提升ANY类型的子连接的方式和EXISTS类型的子连接的方式不同，他提升EXISTS类型的子连接的时候，是直接把子句中的表提上来做形成一个SemiJoin，可是提升ANY类型的子连接的时候，是把整个子句提上来，和父语句中的表做SemiJoin，这时候这个子句就变成了一个子查询，你看这个例子。”说着大明啪啪啪的在电脑上敲了3个语句：\n\n```\n1. SELECT * FROM TEST_A WHERE a > ANY (SELECT a FROM TEST_B WHERE TEST_A.b = TEST_B.b)；\n2. SELECT * FROM TEST_A, (SELECT a FROM TEST_B WHERE TEST_A.b = TEST_B.b) b WHERE TEST_A.a > b.a;\n3. SELECT * FROM TEST_A, LATERAL (SELECT a FROM TEST_B WHERE TEST_A.b = TEST_B.b) b WHERE TEST_A.a > b.a;\n```\n\n“如果按照目前ANY类型子连接先提升成子查询的方式，第1个语句提升之后会变成等价于第2个语句，而第2个语句本身是无法执行的，在比较新的版本的PostgreSQL上支持了LATERAL之后，只要在第2个语句上加上LATERAL，也就是变成第3个语句就能执行了。”大明在屏幕上比划着说。\n\n小明问道：“那岂不是说，有了LATERAL之后，ANY类型的相关子连接也能提升了？”\n\n大明说：“只能说有一部分ANY类型的相关子连接能够提升了，比如我们上面的例1本质上就是能提升的，而且一些商业数据库确实也对这种语句做了提升，但是PostgreSQL数据库目前还没有处理这种情况。”\n\t\n小明打了个哈欠说：“实在是太累了，让我们休息一下吧，查询优化器太复杂了。”\n\n大明笑着说：“坚持不懈就能成功，万一梦想实现了呢?子连接提升之后，还有子查询提升、表达式预处理、外连接消除，不过，在这之前还是让我们先吃个鸡再说吧。”\n","slug":"postgresql-optimizer-outline-3","published":1,"updated":"2020-08-02T01:54:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdchg8jg0003r2s6aul442ma","content":"<p>小明发现到大明家里问问题不但能收获知识，还能收获大腰子和红酒，于是更加坚定了常来问问题的决心。</p>\n<p>小明和大明吃完了午饭，打开电视看一会电视剧，大明又惬意的惬意的抽起了中华烟，小明闻着二手烟有点心烦，就问大明：“哥，你整天抽抽抽，有那么好抽吗？”大明自豪的说：“咋地，咱爷爷抽烟，咱爸爸也抽烟，到我这不能断了香火，你不抽烟是不孝知道不？”<a id=\"more\"></a></p>\n<p>小明说：“咱爷爷抽烟是在农村种的烟叶，自给自足，还省钱，你也干脆回农村种烟叶，你这中华烟和农村的自己卷的烟叶，能有什么区别？”</p>\n<p>大明看电视剧正看得起劲，心不在焉的说：“自己种的烟叶直接用报纸卷了抽，没有过滤嘴，会吸入有害颗粒物，而且烟叶的味道也不如现在改进的香烟。”说到这里大明好像想到了些什么，继续说：“这就像是查询优化器的逻辑优化，查询树输入之后，需要进行持续的改进，无论是自己用报纸卷的烟，还是在超市买的成品烟，它都是香烟，但是通过改进之后，香烟的毒害作用更低、香型更丰富了，逻辑优化也是这个道理，通过改进查询树，能够得到一个更‘好’的查询树。”</p>\n<p>“哦，那逻辑优化是如何在已有的查询树上增加香型的呢？”</p>\n<p>大明感觉电视剧没办法看下去了，于是拿起遥控器关了电视，继续说：“我总结，PostgreSQL在逻辑优化阶段有这么几个重要的优化：子查询&amp;子连接提升、表达式预处理、外连接消除、谓词下推、连接顺序交换、等价类推理。”大明又抽了一口烟，接着说到：“从代码逻辑上来看，我们还可以把子查询&amp;子连接提升、表达式预处理、外连接消除叫做逻辑重写优化，因为他们主要是对查询树进行改造，而后面的谓词下推、连接顺序交换、等价类推理则可以称之为逻辑分解优化，他们已经把查询树蹂躏的不成样子了，已经到了看香烟不是香烟的地步了。”</p>\n<p>“可是我们的数据库原理课上并没有说有逻辑重写优化和逻辑分解优化啊？”</p>\n<p>“嗯，是的，这是我自己根据PostgreSQL的源代码的特征自己总结的，不过它能比较形象的将现有的逻辑优化区分开来，这样就能更好的对逻辑优化进行提炼、总结、分析。”大明想了一下觉得如果把所有的逻辑优化的规则都说完有点多，决定选择其中的一两个说一下，于是对小明说道：“我们就从中挑选一两个详细的说明一下吧，我们先从子查询&amp;子连接的提升开始说起。”</p>\n<p>“那。。。子查询和子连接有什么区别呢？我们在数据库原理课里只讲了子查询，没有子连接的概念，这该怎么解释呢？”小明不解的问。</p>\n<p>大明去书柜里拿出了《数据库系统实现》这本书，然后翻开了对应的章节，说道：“通常数据库原理书籍中说的子查询，指的是PostgreSQL数据库中的子连接。你看，《数据库系统实现》中说的是从条件中去除子查询，但是PostgreSQL把这种情况归类为子连接。”</p>\n<p>“那在PostgreSQL是如何区分子查询和子连接的呢？”大明自问自答道：“在实际应用中可以通过子句所处的位置来区分子连接和子查询，出现在FROM关键字后的子句是子查询语句，出现在WHERE/ON等约束条件中或投影中的子句是子连接语句。”说着大明快速的在电脑上打开了记事本，敲入了几个SQL语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. SELECT * FROM STUDENT, (SELECT * FROM SCORE) as sc;</span><br><span class=\"line\">2. SELECT (SELECT AVG(degree) FROM SCORE), sname FROM STUDENT;</span><br><span class=\"line\">3. SELECT * FROM STUDENT WHERE EXISTS (SELECT A FROM SCORE WHERE SCORE.sno &#x3D; STUDENT.sno);</span><br></pre></td></tr></table></figure>\n\n<p>“这些SQL语句中哪个是子查询？哪个是子连接？”</p>\n<p>小明看了一下，然后说：“1是子查询，2和3是子连接，语句1里面的子句出现在FROM后面，它是以‘表’的形式存在的，是子查询，2和3的子句出现在投影和约束条件中，是以表达式的形式存在的，是子连接。”小明不但答对了问题，而且还对问题的答案做了扩展，大明感到很一颗赛艇，于是调侃道：“腰间盘同学，你坐下，你太突出了。”</p>\n<p>然后大明正一正颜色，继续说道“从大的方向上分类，子查询还可以分为相关子连接和非相关子连接，相关子连接是指在子查询语句中引用了外层表的列属性，这就导致外层表每获得一个元组，子查询就需要重新执行一次；而非相关子查询是指在子查询语句是独立的，和外层的表没有直接的关联，子查询可以单独执行一次，外层表可以重复利用子查询的执行结果。”</p>\n<p>“那么一定是相关子连接才会提升了，因为我记得你在说逻辑优化原理的时候说过，相关子连接会产生‘嵌套循环’，这种情况的复杂度是O(N^2)，提升上来的复杂度肯定不会比O(N^2)差，所以提升是有价值的。”小明问到。</p>\n<p>听到这些，大明顿时碉堡了，道理虽然是这个道理，但是PostgreSQL偏偏不走寻常路，和自己之前说过的有些许差异，大明羞涩的说：“虽然话是这样说，但PostgreSQL有点不同，PostgreSQL提升了两种类型的子连接，一种是ANY类型的子连接，一种是EXISTS类型的子连接，对于ANY类型的子连接，只提升非相关子连接，而对于EXISTS类型的子连接，则只提升相关子连接。”</p>\n<p>小明顿时想起了自己曾和同学说过相关子连接理论，当时把宿舍同学忽悠的五迷三道的，今天大明又说这可能是错的，心里不太爽利，于是怒道：“你之前教我的都有错误，那我和同学吹过的牛岂不是要成为笑柄？我感觉我受到了一万点上海。”</p>\n<p>“小明同学不要急”，大明安抚道：“虽然PostgreSQL对于ANY类型只提升非相关的子连接，但它仍然是只提升产生嵌套循环的那种子连接，你看看这个例子。”说着大明在电脑上又敲了一个SQL语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM STUDENT WHERE sno &gt; ANY (SELECT sno from STUDENT);</span><br></pre></td></tr></table></figure>\n\n<p>“这是一个ANY类型的非相关子连接，但是请注意，在&gt;前面的sno实际上产生了一个天然的相关性，这个天然的相关性就会产生嵌套循环，因此是需要提升的。我们再来看另一个语句。”大明把语句中&gt;前面的sno换成了一个常量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM STUDENT WHERE 10 &gt; ANY (SELECT sno from STUDENT);</span><br></pre></td></tr></table></figure>\n\n<p>“这个SQL语句中的子连接就不会提升了，因为我们把sno换成了常量，父子之间的相关性被打破了，明白了吗？”</p>\n<p>小明点点头，心里想：子连接是否提升取决于相关性，而这个相关性不只是体现在子句里，也体现在表达式里，也就是说只要能产生嵌套循环，那就有提升的必要啊，但是。。。小明灵机一动，问道：“那ANY类型的相关子连接也会产生嵌套循环啊，为什么不提升呢？”</p>\n<p>大明说：“这可能有点历史原因了，PostgreSQL提升ANY类型的子连接的方式和EXISTS类型的子连接的方式不同，他提升EXISTS类型的子连接的时候，是直接把子句中的表提上来做形成一个SemiJoin，可是提升ANY类型的子连接的时候，是把整个子句提上来，和父语句中的表做SemiJoin，这时候这个子句就变成了一个子查询，你看这个例子。”说着大明啪啪啪的在电脑上敲了3个语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. SELECT * FROM TEST_A WHERE a &gt; ANY (SELECT a FROM TEST_B WHERE TEST_A.b &#x3D; TEST_B.b)；</span><br><span class=\"line\">2. SELECT * FROM TEST_A, (SELECT a FROM TEST_B WHERE TEST_A.b &#x3D; TEST_B.b) b WHERE TEST_A.a &gt; b.a;</span><br><span class=\"line\">3. SELECT * FROM TEST_A, LATERAL (SELECT a FROM TEST_B WHERE TEST_A.b &#x3D; TEST_B.b) b WHERE TEST_A.a &gt; b.a;</span><br></pre></td></tr></table></figure>\n\n<p>“如果按照目前ANY类型子连接先提升成子查询的方式，第1个语句提升之后会变成等价于第2个语句，而第2个语句本身是无法执行的，在比较新的版本的PostgreSQL上支持了LATERAL之后，只要在第2个语句上加上LATERAL，也就是变成第3个语句就能执行了。”大明在屏幕上比划着说。</p>\n<p>小明问道：“那岂不是说，有了LATERAL之后，ANY类型的相关子连接也能提升了？”</p>\n<p>大明说：“只能说有一部分ANY类型的相关子连接能够提升了，比如我们上面的例1本质上就是能提升的，而且一些商业数据库确实也对这种语句做了提升，但是PostgreSQL数据库目前还没有处理这种情况。”</p>\n<p>小明打了个哈欠说：“实在是太累了，让我们休息一下吧，查询优化器太复杂了。”</p>\n<p>大明笑着说：“坚持不懈就能成功，万一梦想实现了呢?子连接提升之后，还有子查询提升、表达式预处理、外连接消除，不过，在这之前还是让我们先吃个鸡再说吧。”</p>\n","site":{"data":{}},"excerpt":"<p>小明发现到大明家里问问题不但能收获知识，还能收获大腰子和红酒，于是更加坚定了常来问问题的决心。</p>\n<p>小明和大明吃完了午饭，打开电视看一会电视剧，大明又惬意的惬意的抽起了中华烟，小明闻着二手烟有点心烦，就问大明：“哥，你整天抽抽抽，有那么好抽吗？”大明自豪的说：“咋地，咱爷爷抽烟，咱爸爸也抽烟，到我这不能断了香火，你不抽烟是不孝知道不？”</p>","more":"<p></p>\n<p>小明说：“咱爷爷抽烟是在农村种的烟叶，自给自足，还省钱，你也干脆回农村种烟叶，你这中华烟和农村的自己卷的烟叶，能有什么区别？”</p>\n<p>大明看电视剧正看得起劲，心不在焉的说：“自己种的烟叶直接用报纸卷了抽，没有过滤嘴，会吸入有害颗粒物，而且烟叶的味道也不如现在改进的香烟。”说到这里大明好像想到了些什么，继续说：“这就像是查询优化器的逻辑优化，查询树输入之后，需要进行持续的改进，无论是自己用报纸卷的烟，还是在超市买的成品烟，它都是香烟，但是通过改进之后，香烟的毒害作用更低、香型更丰富了，逻辑优化也是这个道理，通过改进查询树，能够得到一个更‘好’的查询树。”</p>\n<p>“哦，那逻辑优化是如何在已有的查询树上增加香型的呢？”</p>\n<p>大明感觉电视剧没办法看下去了，于是拿起遥控器关了电视，继续说：“我总结，PostgreSQL在逻辑优化阶段有这么几个重要的优化：子查询&amp;子连接提升、表达式预处理、外连接消除、谓词下推、连接顺序交换、等价类推理。”大明又抽了一口烟，接着说到：“从代码逻辑上来看，我们还可以把子查询&amp;子连接提升、表达式预处理、外连接消除叫做逻辑重写优化，因为他们主要是对查询树进行改造，而后面的谓词下推、连接顺序交换、等价类推理则可以称之为逻辑分解优化，他们已经把查询树蹂躏的不成样子了，已经到了看香烟不是香烟的地步了。”</p>\n<p>“可是我们的数据库原理课上并没有说有逻辑重写优化和逻辑分解优化啊？”</p>\n<p>“嗯，是的，这是我自己根据PostgreSQL的源代码的特征自己总结的，不过它能比较形象的将现有的逻辑优化区分开来，这样就能更好的对逻辑优化进行提炼、总结、分析。”大明想了一下觉得如果把所有的逻辑优化的规则都说完有点多，决定选择其中的一两个说一下，于是对小明说道：“我们就从中挑选一两个详细的说明一下吧，我们先从子查询&amp;子连接的提升开始说起。”</p>\n<p>“那。。。子查询和子连接有什么区别呢？我们在数据库原理课里只讲了子查询，没有子连接的概念，这该怎么解释呢？”小明不解的问。</p>\n<p>大明去书柜里拿出了《数据库系统实现》这本书，然后翻开了对应的章节，说道：“通常数据库原理书籍中说的子查询，指的是PostgreSQL数据库中的子连接。你看，《数据库系统实现》中说的是从条件中去除子查询，但是PostgreSQL把这种情况归类为子连接。”</p>\n<p>“那在PostgreSQL是如何区分子查询和子连接的呢？”大明自问自答道：“在实际应用中可以通过子句所处的位置来区分子连接和子查询，出现在FROM关键字后的子句是子查询语句，出现在WHERE/ON等约束条件中或投影中的子句是子连接语句。”说着大明快速的在电脑上打开了记事本，敲入了几个SQL语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. SELECT * FROM STUDENT, (SELECT * FROM SCORE) as sc;</span><br><span class=\"line\">2. SELECT (SELECT AVG(degree) FROM SCORE), sname FROM STUDENT;</span><br><span class=\"line\">3. SELECT * FROM STUDENT WHERE EXISTS (SELECT A FROM SCORE WHERE SCORE.sno &#x3D; STUDENT.sno);</span><br></pre></td></tr></table></figure>\n\n<p>“这些SQL语句中哪个是子查询？哪个是子连接？”</p>\n<p>小明看了一下，然后说：“1是子查询，2和3是子连接，语句1里面的子句出现在FROM后面，它是以‘表’的形式存在的，是子查询，2和3的子句出现在投影和约束条件中，是以表达式的形式存在的，是子连接。”小明不但答对了问题，而且还对问题的答案做了扩展，大明感到很一颗赛艇，于是调侃道：“腰间盘同学，你坐下，你太突出了。”</p>\n<p>然后大明正一正颜色，继续说道“从大的方向上分类，子查询还可以分为相关子连接和非相关子连接，相关子连接是指在子查询语句中引用了外层表的列属性，这就导致外层表每获得一个元组，子查询就需要重新执行一次；而非相关子查询是指在子查询语句是独立的，和外层的表没有直接的关联，子查询可以单独执行一次，外层表可以重复利用子查询的执行结果。”</p>\n<p>“那么一定是相关子连接才会提升了，因为我记得你在说逻辑优化原理的时候说过，相关子连接会产生‘嵌套循环’，这种情况的复杂度是O(N^2)，提升上来的复杂度肯定不会比O(N^2)差，所以提升是有价值的。”小明问到。</p>\n<p>听到这些，大明顿时碉堡了，道理虽然是这个道理，但是PostgreSQL偏偏不走寻常路，和自己之前说过的有些许差异，大明羞涩的说：“虽然话是这样说，但PostgreSQL有点不同，PostgreSQL提升了两种类型的子连接，一种是ANY类型的子连接，一种是EXISTS类型的子连接，对于ANY类型的子连接，只提升非相关子连接，而对于EXISTS类型的子连接，则只提升相关子连接。”</p>\n<p>小明顿时想起了自己曾和同学说过相关子连接理论，当时把宿舍同学忽悠的五迷三道的，今天大明又说这可能是错的，心里不太爽利，于是怒道：“你之前教我的都有错误，那我和同学吹过的牛岂不是要成为笑柄？我感觉我受到了一万点上海。”</p>\n<p>“小明同学不要急”，大明安抚道：“虽然PostgreSQL对于ANY类型只提升非相关的子连接，但它仍然是只提升产生嵌套循环的那种子连接，你看看这个例子。”说着大明在电脑上又敲了一个SQL语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM STUDENT WHERE sno &gt; ANY (SELECT sno from STUDENT);</span><br></pre></td></tr></table></figure>\n\n<p>“这是一个ANY类型的非相关子连接，但是请注意，在&gt;前面的sno实际上产生了一个天然的相关性，这个天然的相关性就会产生嵌套循环，因此是需要提升的。我们再来看另一个语句。”大明把语句中&gt;前面的sno换成了一个常量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM STUDENT WHERE 10 &gt; ANY (SELECT sno from STUDENT);</span><br></pre></td></tr></table></figure>\n\n<p>“这个SQL语句中的子连接就不会提升了，因为我们把sno换成了常量，父子之间的相关性被打破了，明白了吗？”</p>\n<p>小明点点头，心里想：子连接是否提升取决于相关性，而这个相关性不只是体现在子句里，也体现在表达式里，也就是说只要能产生嵌套循环，那就有提升的必要啊，但是。。。小明灵机一动，问道：“那ANY类型的相关子连接也会产生嵌套循环啊，为什么不提升呢？”</p>\n<p>大明说：“这可能有点历史原因了，PostgreSQL提升ANY类型的子连接的方式和EXISTS类型的子连接的方式不同，他提升EXISTS类型的子连接的时候，是直接把子句中的表提上来做形成一个SemiJoin，可是提升ANY类型的子连接的时候，是把整个子句提上来，和父语句中的表做SemiJoin，这时候这个子句就变成了一个子查询，你看这个例子。”说着大明啪啪啪的在电脑上敲了3个语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. SELECT * FROM TEST_A WHERE a &gt; ANY (SELECT a FROM TEST_B WHERE TEST_A.b &#x3D; TEST_B.b)；</span><br><span class=\"line\">2. SELECT * FROM TEST_A, (SELECT a FROM TEST_B WHERE TEST_A.b &#x3D; TEST_B.b) b WHERE TEST_A.a &gt; b.a;</span><br><span class=\"line\">3. SELECT * FROM TEST_A, LATERAL (SELECT a FROM TEST_B WHERE TEST_A.b &#x3D; TEST_B.b) b WHERE TEST_A.a &gt; b.a;</span><br></pre></td></tr></table></figure>\n\n<p>“如果按照目前ANY类型子连接先提升成子查询的方式，第1个语句提升之后会变成等价于第2个语句，而第2个语句本身是无法执行的，在比较新的版本的PostgreSQL上支持了LATERAL之后，只要在第2个语句上加上LATERAL，也就是变成第3个语句就能执行了。”大明在屏幕上比划着说。</p>\n<p>小明问道：“那岂不是说，有了LATERAL之后，ANY类型的相关子连接也能提升了？”</p>\n<p>大明说：“只能说有一部分ANY类型的相关子连接能够提升了，比如我们上面的例1本质上就是能提升的，而且一些商业数据库确实也对这种语句做了提升，但是PostgreSQL数据库目前还没有处理这种情况。”</p>\n<p>小明打了个哈欠说：“实在是太累了，让我们休息一下吧，查询优化器太复杂了。”</p>\n<p>大明笑着说：“坚持不懈就能成功，万一梦想实现了呢?子连接提升之后，还有子查询提升、表达式预处理、外连接消除，不过，在这之前还是让我们先吃个鸡再说吧。”</p>"},{"title":"PostgreSQL优化器白话(4) - 下推！下推！","date":"2020-08-04T23:06:30.000Z","_content":"\n小明在大明家的书房里摆好了纸砚，在一份过期的报纸上挥毫泼墨：“精推细敲慎思量，雄关漫道两茫茫，夜半挑灯读诗酒，莫谈肉串与烤馕。”大明看了之后笑道：“好诗好诗，来，让我们继续夜半挑灯读优化，莫与扯淡诉衷肠。”\n\n小明说：“再歇会吧，我觉得要深度了解查询优化没希望了。”大明看出了小明对查询优化产生了一点畏难情绪，因为小明本来以为通过大明的讲解能够快速的理解查询优化的本质，但是他通过几次听取大明的讲解之后发现，查询优化器远不是几次讲解就能解决的，大明目前给他讲解的还只是在应用层面的讲解，还没有深入到分析源码阶段，仅仅如此，对小明来说理解上就已经有些困难了，看来要想深度的了解查询优化器，还需要下更大的功夫才行。<!-- more -->\n\t\n大明说：“啥叫成功？成功就是在你坚持不下去的时候再坚持一下，来吧，Let’s继续。”说着拉着小明来到客厅，继续打开了电脑，“我们继续说点啥呢？上次说到了子连接，这次我们简单说说选择下推和等价类吧。”\n\n小明想了想说：“选择下推和等价类是逻辑分解优化中的内容了，可是逻辑重写优化里还有子查询提升、表达式预处理、外连接消除这些大块头你还没有给我讲解过吖。”\n\n大明说：“这些先留给你自己去理解，如果理解不了再来找我吧。逻辑优化的规则实际上还是比较多的，但是是可以逐个击破的，也就是他们之间通常而言并没有多大的关联，我们不打算在这上面纠缠太多时间，我相信以你自己的能力把他们搞定是没有问题的。”\n\n“哦，我觉得是你怕我在你家呆太长时间，把你吃穷吧？”小明偷笑着问。\n\n“是的，半大小子吃死老子，你这饭桶太能吃了，吃饭的速度比选择下推的速度还要快，午饭都被你吃了，我今天中午都没吃饱啊。”\n\n“我记得你说过，选择下推是为了尽早的过滤数据，这样就能在上层结点降低计算量，是吧？”\n\n“是的。”大明点了点头，“还是通过一个关系代数的示例来说明一下它吧，顺便我们把等价类推理也可以说一说，比如说我们想要获得编号为5的老师承担的所有的课程名字，我们可以给出它的关系代数表达式。”说着大明在电脑上敲了一个关系代数表达式：\n\n```\nΠcname (σTEACHER.tno=5∧TEACHER.tno=COURSE.tno (TEACHER×COURSE))\n```\n\n“小明，你看这个关系代数表达式怎么下推选择操作？”\n\n小明看着关系代数表达式思考了一会，说：“我看这个TEACHER.tno = 5比较可疑，你看这个关系代数表达式，先做了TEACHER×COURSE，也就是先做了卡氏积，我要是把TEACHER.tno = 5放到TEACHER上先把一些数据过滤掉，岂不是。。。完美！”说着小明也在电脑上敲出了把TEACHER.tno = 5下推之后的关系代数表达式。\n\n```\nΠcname (σTEACHER.tno=COURSE.tno (σTEACHER.tno=5(TEACHER)×COURSE))\n```\n\n大明说；“对的，你这样下推下来，的确能降低计算量，你这应用的是关系代数表达式中的分配率σF(A × B) == σF1(A) × σF2(B)，那你看看，既然下推这么好，是不是投影也能下推？”小明看了一下，关系代数表达式中值需要对cname进行投影，顿时想到了，COURSE表虽然有很多个列，但是我们只需要使用cname就够了嘛，于是小明在电脑上敲了投影下推的关系代数表达式。\n\n```\nΠcname (σTEACHER.tno=COURSE.tno (σTEACHER.tno=5(TEACHER)× Πcname(COURSE)))\n```\n\n大明拍了小明的头一下说：“笨蛋，你这样下推投影，TEACHER.tno=COURSE.tno还有办法做吗？”小明顿时领悟了，如果只在COURSE上对cname做投影时不行的，上层结点所有的表达式都需要考虑到，于是修改了表达式：\n\n```\nΠcname (σTEACHER.tno=COURSE.tno (σTEACHER.tno=5(TEACHER)× Πcname, tno(COURSE)))\n```\n\n“这还差不多。”大明笑着说：“这是使用的投影的串接率，也是一个非常重要的关系代数等价规则，目前我们对这个表达式的优化主要是使用了选择下推，和投影下推，如果用SQL语句来表示，就像这样。”大明在电脑的记事本上快速的打印出了两个SQL语句：\n\n```\nSELECT sname FROM TEACHER t, COURSE c WHERE t.tno = 5 AND t.tno = c.tno;\nSELECT sname FROM (SELECT * FROM TEACHER WHERE tno = 5) tt, (SELECT cname, tno FROM COURSE) cc WHERE tt.tno = cc.tno;\n```\n\n“你看这两个语句，就是谓词下推和投影下推前后的对照语句。在做卡氏积之前，先做了过滤，这样笛卡尔积的计算量会变小。”\n小明仔细的观察着代数表达式和这两个SQL语句，他发现一个问题，就是关系代数表达式中有TEACHER.tno = 5和TEACHER.tno = COURSE.tno这样的两个约束条件，这是不是意味着COURSE.tno也应该等于5呢？小明然后试着在电脑上写了一个SQL语句：\n\n```\nSELECT sname FROM (SELECT * FROM TEACHER WHERE tno = 5) tt, (SELECT cname, tno FROM COURSE WHERE tno=5) cc WHERE tt.tno = cc.tno;\n```\n\n然后小明说：“你看，由于有TEACHER.tno = 5和TEACHER.tno = COURSE.tno这样的两个约束条件，我们可以是不是可以推理出一个新的COURSE.tno = 5的新的约束条件来呢，这样我们还可以把这个条件下推到COURSE表上，这样也能降低笛卡尔积的计算量。”\n\n大明说：“是的，这就是等价推理，PostgreSQL数据库在查询优化的过程中，会将约束条件中等价的部分都记录到等价类中，这样就能根据等价类生成新的约束条件出来，比如示例的语句中就会产生一个等价类{TEACHER.tno, COURSE.tno, 5}，这是一个含有常量的等价类，是查询优化器比较喜欢的等价类，这种等价类可以得到列属性和常量组合成的约束条件，通常都是能下推的。”\n\n小明心里很高兴，自己通过仔细观察，得到了等价类的优化，感觉自己有了学习的动力，心里美滋滋的，然后就问大明：“那上面的SQL语句还有什么可优化的吗？”\n\n大明观察了一下这个语句，然后说：“你看，我们已经在TEACHER表上进行了TEACHER.tno = 5的过滤，在COURSE表上也做了COURSE.tno = 5的过滤，这样就说明在做笛卡尔积的时候，实际上已经确定了TEACHER.tno = COURSE.tno = 5，也就是说TEACHER.tno = COURSE.tno这个约束条件已经隐含成立了，也就没什么用了，我们可以把它去掉，最终形成一个这样的SQL语句。”大明在记事本中敲下了最终的语句：\n\n```\nSELECT sname FROM (SELECT * FROM TEACHER WHERE tno = 5) tt, (SELECT cname, tno FROM COURSE WHERE tno=5) cc；\n```\n\n同时也敲出了这个语句对应的关系代数表达式：\n\n```\nΠcname (σTEACHER.tno=5(TEACHER)× Πcname, tno(σCOURSE.tno=5(COURSE)))\n```\n\n然后大明说：“经过选择下推、投影下推和等价类推理，我们对这个SQL语句或者说关系代数表达式进行了优化，最终降低了计算量。”\n \n![](./postgresql-optimizer-outline-4/1.png) \n\n![](./postgresql-optimizer-outline-4/1.png) \n \n\n小明感觉对谓词下推已经理解了，然后说：“看上去也不复杂嘛，我发现了可以下推的选择我就下推，完全没有问题啊。”大明笑着说：“甚矣，我从未见过如此厚颜无耻之人，我们现在看的这个例子，只不过是最简单的一种情况啊，你就这样大言不惭，你的人生字典里还有羞耻二字吗？”\n\n小明愤愤的说：“我的人生没有字典。。。”\n\n大明问道：“我们这个例子有一个问题，就是他是内连接，因此我们可以肆意妄为的将选择下推下来，可以没羞没臊的做等价类推理，但是如果是外连接，那还能这么做吗？”\n\n小明顿时陷入了苦苦的沉思。\n","source":"_posts/postgresql-optimizer-outline-4.md","raw":"---\ntitle: PostgreSQL优化器白话(4) - 下推！下推！\ndate: 2020-08-05 07:06:30\ntags:\n---\n\n小明在大明家的书房里摆好了纸砚，在一份过期的报纸上挥毫泼墨：“精推细敲慎思量，雄关漫道两茫茫，夜半挑灯读诗酒，莫谈肉串与烤馕。”大明看了之后笑道：“好诗好诗，来，让我们继续夜半挑灯读优化，莫与扯淡诉衷肠。”\n\n小明说：“再歇会吧，我觉得要深度了解查询优化没希望了。”大明看出了小明对查询优化产生了一点畏难情绪，因为小明本来以为通过大明的讲解能够快速的理解查询优化的本质，但是他通过几次听取大明的讲解之后发现，查询优化器远不是几次讲解就能解决的，大明目前给他讲解的还只是在应用层面的讲解，还没有深入到分析源码阶段，仅仅如此，对小明来说理解上就已经有些困难了，看来要想深度的了解查询优化器，还需要下更大的功夫才行。<!-- more -->\n\t\n大明说：“啥叫成功？成功就是在你坚持不下去的时候再坚持一下，来吧，Let’s继续。”说着拉着小明来到客厅，继续打开了电脑，“我们继续说点啥呢？上次说到了子连接，这次我们简单说说选择下推和等价类吧。”\n\n小明想了想说：“选择下推和等价类是逻辑分解优化中的内容了，可是逻辑重写优化里还有子查询提升、表达式预处理、外连接消除这些大块头你还没有给我讲解过吖。”\n\n大明说：“这些先留给你自己去理解，如果理解不了再来找我吧。逻辑优化的规则实际上还是比较多的，但是是可以逐个击破的，也就是他们之间通常而言并没有多大的关联，我们不打算在这上面纠缠太多时间，我相信以你自己的能力把他们搞定是没有问题的。”\n\n“哦，我觉得是你怕我在你家呆太长时间，把你吃穷吧？”小明偷笑着问。\n\n“是的，半大小子吃死老子，你这饭桶太能吃了，吃饭的速度比选择下推的速度还要快，午饭都被你吃了，我今天中午都没吃饱啊。”\n\n“我记得你说过，选择下推是为了尽早的过滤数据，这样就能在上层结点降低计算量，是吧？”\n\n“是的。”大明点了点头，“还是通过一个关系代数的示例来说明一下它吧，顺便我们把等价类推理也可以说一说，比如说我们想要获得编号为5的老师承担的所有的课程名字，我们可以给出它的关系代数表达式。”说着大明在电脑上敲了一个关系代数表达式：\n\n```\nΠcname (σTEACHER.tno=5∧TEACHER.tno=COURSE.tno (TEACHER×COURSE))\n```\n\n“小明，你看这个关系代数表达式怎么下推选择操作？”\n\n小明看着关系代数表达式思考了一会，说：“我看这个TEACHER.tno = 5比较可疑，你看这个关系代数表达式，先做了TEACHER×COURSE，也就是先做了卡氏积，我要是把TEACHER.tno = 5放到TEACHER上先把一些数据过滤掉，岂不是。。。完美！”说着小明也在电脑上敲出了把TEACHER.tno = 5下推之后的关系代数表达式。\n\n```\nΠcname (σTEACHER.tno=COURSE.tno (σTEACHER.tno=5(TEACHER)×COURSE))\n```\n\n大明说；“对的，你这样下推下来，的确能降低计算量，你这应用的是关系代数表达式中的分配率σF(A × B) == σF1(A) × σF2(B)，那你看看，既然下推这么好，是不是投影也能下推？”小明看了一下，关系代数表达式中值需要对cname进行投影，顿时想到了，COURSE表虽然有很多个列，但是我们只需要使用cname就够了嘛，于是小明在电脑上敲了投影下推的关系代数表达式。\n\n```\nΠcname (σTEACHER.tno=COURSE.tno (σTEACHER.tno=5(TEACHER)× Πcname(COURSE)))\n```\n\n大明拍了小明的头一下说：“笨蛋，你这样下推投影，TEACHER.tno=COURSE.tno还有办法做吗？”小明顿时领悟了，如果只在COURSE上对cname做投影时不行的，上层结点所有的表达式都需要考虑到，于是修改了表达式：\n\n```\nΠcname (σTEACHER.tno=COURSE.tno (σTEACHER.tno=5(TEACHER)× Πcname, tno(COURSE)))\n```\n\n“这还差不多。”大明笑着说：“这是使用的投影的串接率，也是一个非常重要的关系代数等价规则，目前我们对这个表达式的优化主要是使用了选择下推，和投影下推，如果用SQL语句来表示，就像这样。”大明在电脑的记事本上快速的打印出了两个SQL语句：\n\n```\nSELECT sname FROM TEACHER t, COURSE c WHERE t.tno = 5 AND t.tno = c.tno;\nSELECT sname FROM (SELECT * FROM TEACHER WHERE tno = 5) tt, (SELECT cname, tno FROM COURSE) cc WHERE tt.tno = cc.tno;\n```\n\n“你看这两个语句，就是谓词下推和投影下推前后的对照语句。在做卡氏积之前，先做了过滤，这样笛卡尔积的计算量会变小。”\n小明仔细的观察着代数表达式和这两个SQL语句，他发现一个问题，就是关系代数表达式中有TEACHER.tno = 5和TEACHER.tno = COURSE.tno这样的两个约束条件，这是不是意味着COURSE.tno也应该等于5呢？小明然后试着在电脑上写了一个SQL语句：\n\n```\nSELECT sname FROM (SELECT * FROM TEACHER WHERE tno = 5) tt, (SELECT cname, tno FROM COURSE WHERE tno=5) cc WHERE tt.tno = cc.tno;\n```\n\n然后小明说：“你看，由于有TEACHER.tno = 5和TEACHER.tno = COURSE.tno这样的两个约束条件，我们可以是不是可以推理出一个新的COURSE.tno = 5的新的约束条件来呢，这样我们还可以把这个条件下推到COURSE表上，这样也能降低笛卡尔积的计算量。”\n\n大明说：“是的，这就是等价推理，PostgreSQL数据库在查询优化的过程中，会将约束条件中等价的部分都记录到等价类中，这样就能根据等价类生成新的约束条件出来，比如示例的语句中就会产生一个等价类{TEACHER.tno, COURSE.tno, 5}，这是一个含有常量的等价类，是查询优化器比较喜欢的等价类，这种等价类可以得到列属性和常量组合成的约束条件，通常都是能下推的。”\n\n小明心里很高兴，自己通过仔细观察，得到了等价类的优化，感觉自己有了学习的动力，心里美滋滋的，然后就问大明：“那上面的SQL语句还有什么可优化的吗？”\n\n大明观察了一下这个语句，然后说：“你看，我们已经在TEACHER表上进行了TEACHER.tno = 5的过滤，在COURSE表上也做了COURSE.tno = 5的过滤，这样就说明在做笛卡尔积的时候，实际上已经确定了TEACHER.tno = COURSE.tno = 5，也就是说TEACHER.tno = COURSE.tno这个约束条件已经隐含成立了，也就没什么用了，我们可以把它去掉，最终形成一个这样的SQL语句。”大明在记事本中敲下了最终的语句：\n\n```\nSELECT sname FROM (SELECT * FROM TEACHER WHERE tno = 5) tt, (SELECT cname, tno FROM COURSE WHERE tno=5) cc；\n```\n\n同时也敲出了这个语句对应的关系代数表达式：\n\n```\nΠcname (σTEACHER.tno=5(TEACHER)× Πcname, tno(σCOURSE.tno=5(COURSE)))\n```\n\n然后大明说：“经过选择下推、投影下推和等价类推理，我们对这个SQL语句或者说关系代数表达式进行了优化，最终降低了计算量。”\n \n![](./postgresql-optimizer-outline-4/1.png) \n\n![](./postgresql-optimizer-outline-4/1.png) \n \n\n小明感觉对谓词下推已经理解了，然后说：“看上去也不复杂嘛，我发现了可以下推的选择我就下推，完全没有问题啊。”大明笑着说：“甚矣，我从未见过如此厚颜无耻之人，我们现在看的这个例子，只不过是最简单的一种情况啊，你就这样大言不惭，你的人生字典里还有羞耻二字吗？”\n\n小明愤愤的说：“我的人生没有字典。。。”\n\n大明问道：“我们这个例子有一个问题，就是他是内连接，因此我们可以肆意妄为的将选择下推下来，可以没羞没臊的做等价类推理，但是如果是外连接，那还能这么做吗？”\n\n小明顿时陷入了苦苦的沉思。\n","slug":"postgresql-optimizer-outline-4","published":1,"updated":"2020-08-04T23:18:17.000Z","_id":"ckdgkb6d30000mvs61pjfd9kp","comments":1,"layout":"post","photos":[],"link":"","content":"<p>小明在大明家的书房里摆好了纸砚，在一份过期的报纸上挥毫泼墨：“精推细敲慎思量，雄关漫道两茫茫，夜半挑灯读诗酒，莫谈肉串与烤馕。”大明看了之后笑道：“好诗好诗，来，让我们继续夜半挑灯读优化，莫与扯淡诉衷肠。”</p>\n<p>小明说：“再歇会吧，我觉得要深度了解查询优化没希望了。”大明看出了小明对查询优化产生了一点畏难情绪，因为小明本来以为通过大明的讲解能够快速的理解查询优化的本质，但是他通过几次听取大明的讲解之后发现，查询优化器远不是几次讲解就能解决的，大明目前给他讲解的还只是在应用层面的讲解，还没有深入到分析源码阶段，仅仅如此，对小明来说理解上就已经有些困难了，看来要想深度的了解查询优化器，还需要下更大的功夫才行。<a id=\"more\"></a></p>\n<p>大明说：“啥叫成功？成功就是在你坚持不下去的时候再坚持一下，来吧，Let’s继续。”说着拉着小明来到客厅，继续打开了电脑，“我们继续说点啥呢？上次说到了子连接，这次我们简单说说选择下推和等价类吧。”</p>\n<p>小明想了想说：“选择下推和等价类是逻辑分解优化中的内容了，可是逻辑重写优化里还有子查询提升、表达式预处理、外连接消除这些大块头你还没有给我讲解过吖。”</p>\n<p>大明说：“这些先留给你自己去理解，如果理解不了再来找我吧。逻辑优化的规则实际上还是比较多的，但是是可以逐个击破的，也就是他们之间通常而言并没有多大的关联，我们不打算在这上面纠缠太多时间，我相信以你自己的能力把他们搞定是没有问题的。”</p>\n<p>“哦，我觉得是你怕我在你家呆太长时间，把你吃穷吧？”小明偷笑着问。</p>\n<p>“是的，半大小子吃死老子，你这饭桶太能吃了，吃饭的速度比选择下推的速度还要快，午饭都被你吃了，我今天中午都没吃饱啊。”</p>\n<p>“我记得你说过，选择下推是为了尽早的过滤数据，这样就能在上层结点降低计算量，是吧？”</p>\n<p>“是的。”大明点了点头，“还是通过一个关系代数的示例来说明一下它吧，顺便我们把等价类推理也可以说一说，比如说我们想要获得编号为5的老师承担的所有的课程名字，我们可以给出它的关系代数表达式。”说着大明在电脑上敲了一个关系代数表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Πcname (σTEACHER.tno&#x3D;5∧TEACHER.tno&#x3D;COURSE.tno (TEACHER×COURSE))</span><br></pre></td></tr></table></figure>\n\n<p>“小明，你看这个关系代数表达式怎么下推选择操作？”</p>\n<p>小明看着关系代数表达式思考了一会，说：“我看这个TEACHER.tno = 5比较可疑，你看这个关系代数表达式，先做了TEACHER×COURSE，也就是先做了卡氏积，我要是把TEACHER.tno = 5放到TEACHER上先把一些数据过滤掉，岂不是。。。完美！”说着小明也在电脑上敲出了把TEACHER.tno = 5下推之后的关系代数表达式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Πcname (σTEACHER.tno&#x3D;COURSE.tno (σTEACHER.tno&#x3D;5(TEACHER)×COURSE))</span><br></pre></td></tr></table></figure>\n\n<p>大明说；“对的，你这样下推下来，的确能降低计算量，你这应用的是关系代数表达式中的分配率σF(A × B) == σF1(A) × σF2(B)，那你看看，既然下推这么好，是不是投影也能下推？”小明看了一下，关系代数表达式中值需要对cname进行投影，顿时想到了，COURSE表虽然有很多个列，但是我们只需要使用cname就够了嘛，于是小明在电脑上敲了投影下推的关系代数表达式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Πcname (σTEACHER.tno&#x3D;COURSE.tno (σTEACHER.tno&#x3D;5(TEACHER)× Πcname(COURSE)))</span><br></pre></td></tr></table></figure>\n\n<p>大明拍了小明的头一下说：“笨蛋，你这样下推投影，TEACHER.tno=COURSE.tno还有办法做吗？”小明顿时领悟了，如果只在COURSE上对cname做投影时不行的，上层结点所有的表达式都需要考虑到，于是修改了表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Πcname (σTEACHER.tno&#x3D;COURSE.tno (σTEACHER.tno&#x3D;5(TEACHER)× Πcname, tno(COURSE)))</span><br></pre></td></tr></table></figure>\n\n<p>“这还差不多。”大明笑着说：“这是使用的投影的串接率，也是一个非常重要的关系代数等价规则，目前我们对这个表达式的优化主要是使用了选择下推，和投影下推，如果用SQL语句来表示，就像这样。”大明在电脑的记事本上快速的打印出了两个SQL语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sname FROM TEACHER t, COURSE c WHERE t.tno &#x3D; 5 AND t.tno &#x3D; c.tno;</span><br><span class=\"line\">SELECT sname FROM (SELECT * FROM TEACHER WHERE tno &#x3D; 5) tt, (SELECT cname, tno FROM COURSE) cc WHERE tt.tno &#x3D; cc.tno;</span><br></pre></td></tr></table></figure>\n\n<p>“你看这两个语句，就是谓词下推和投影下推前后的对照语句。在做卡氏积之前，先做了过滤，这样笛卡尔积的计算量会变小。”<br>小明仔细的观察着代数表达式和这两个SQL语句，他发现一个问题，就是关系代数表达式中有TEACHER.tno = 5和TEACHER.tno = COURSE.tno这样的两个约束条件，这是不是意味着COURSE.tno也应该等于5呢？小明然后试着在电脑上写了一个SQL语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sname FROM (SELECT * FROM TEACHER WHERE tno &#x3D; 5) tt, (SELECT cname, tno FROM COURSE WHERE tno&#x3D;5) cc WHERE tt.tno &#x3D; cc.tno;</span><br></pre></td></tr></table></figure>\n\n<p>然后小明说：“你看，由于有TEACHER.tno = 5和TEACHER.tno = COURSE.tno这样的两个约束条件，我们可以是不是可以推理出一个新的COURSE.tno = 5的新的约束条件来呢，这样我们还可以把这个条件下推到COURSE表上，这样也能降低笛卡尔积的计算量。”</p>\n<p>大明说：“是的，这就是等价推理，PostgreSQL数据库在查询优化的过程中，会将约束条件中等价的部分都记录到等价类中，这样就能根据等价类生成新的约束条件出来，比如示例的语句中就会产生一个等价类{TEACHER.tno, COURSE.tno, 5}，这是一个含有常量的等价类，是查询优化器比较喜欢的等价类，这种等价类可以得到列属性和常量组合成的约束条件，通常都是能下推的。”</p>\n<p>小明心里很高兴，自己通过仔细观察，得到了等价类的优化，感觉自己有了学习的动力，心里美滋滋的，然后就问大明：“那上面的SQL语句还有什么可优化的吗？”</p>\n<p>大明观察了一下这个语句，然后说：“你看，我们已经在TEACHER表上进行了TEACHER.tno = 5的过滤，在COURSE表上也做了COURSE.tno = 5的过滤，这样就说明在做笛卡尔积的时候，实际上已经确定了TEACHER.tno = COURSE.tno = 5，也就是说TEACHER.tno = COURSE.tno这个约束条件已经隐含成立了，也就没什么用了，我们可以把它去掉，最终形成一个这样的SQL语句。”大明在记事本中敲下了最终的语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sname FROM (SELECT * FROM TEACHER WHERE tno &#x3D; 5) tt, (SELECT cname, tno FROM COURSE WHERE tno&#x3D;5) cc；</span><br></pre></td></tr></table></figure>\n\n<p>同时也敲出了这个语句对应的关系代数表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Πcname (σTEACHER.tno&#x3D;5(TEACHER)× Πcname, tno(σCOURSE.tno&#x3D;5(COURSE)))</span><br></pre></td></tr></table></figure>\n\n<p>然后大明说：“经过选择下推、投影下推和等价类推理，我们对这个SQL语句或者说关系代数表达式进行了优化，最终降低了计算量。”</p>\n<p><img src=\"/2020/08/05/postgresql-optimizer-outline-4/1.png\"> </p>\n<p><img src=\"/2020/08/05/postgresql-optimizer-outline-4/1.png\"> </p>\n<p>小明感觉对谓词下推已经理解了，然后说：“看上去也不复杂嘛，我发现了可以下推的选择我就下推，完全没有问题啊。”大明笑着说：“甚矣，我从未见过如此厚颜无耻之人，我们现在看的这个例子，只不过是最简单的一种情况啊，你就这样大言不惭，你的人生字典里还有羞耻二字吗？”</p>\n<p>小明愤愤的说：“我的人生没有字典。。。”</p>\n<p>大明问道：“我们这个例子有一个问题，就是他是内连接，因此我们可以肆意妄为的将选择下推下来，可以没羞没臊的做等价类推理，但是如果是外连接，那还能这么做吗？”</p>\n<p>小明顿时陷入了苦苦的沉思。</p>\n","site":{"data":{}},"excerpt":"<p>小明在大明家的书房里摆好了纸砚，在一份过期的报纸上挥毫泼墨：“精推细敲慎思量，雄关漫道两茫茫，夜半挑灯读诗酒，莫谈肉串与烤馕。”大明看了之后笑道：“好诗好诗，来，让我们继续夜半挑灯读优化，莫与扯淡诉衷肠。”</p>\n<p>小明说：“再歇会吧，我觉得要深度了解查询优化没希望了。”大明看出了小明对查询优化产生了一点畏难情绪，因为小明本来以为通过大明的讲解能够快速的理解查询优化的本质，但是他通过几次听取大明的讲解之后发现，查询优化器远不是几次讲解就能解决的，大明目前给他讲解的还只是在应用层面的讲解，还没有深入到分析源码阶段，仅仅如此，对小明来说理解上就已经有些困难了，看来要想深度的了解查询优化器，还需要下更大的功夫才行。</p>","more":"<p></p>\n<p>大明说：“啥叫成功？成功就是在你坚持不下去的时候再坚持一下，来吧，Let’s继续。”说着拉着小明来到客厅，继续打开了电脑，“我们继续说点啥呢？上次说到了子连接，这次我们简单说说选择下推和等价类吧。”</p>\n<p>小明想了想说：“选择下推和等价类是逻辑分解优化中的内容了，可是逻辑重写优化里还有子查询提升、表达式预处理、外连接消除这些大块头你还没有给我讲解过吖。”</p>\n<p>大明说：“这些先留给你自己去理解，如果理解不了再来找我吧。逻辑优化的规则实际上还是比较多的，但是是可以逐个击破的，也就是他们之间通常而言并没有多大的关联，我们不打算在这上面纠缠太多时间，我相信以你自己的能力把他们搞定是没有问题的。”</p>\n<p>“哦，我觉得是你怕我在你家呆太长时间，把你吃穷吧？”小明偷笑着问。</p>\n<p>“是的，半大小子吃死老子，你这饭桶太能吃了，吃饭的速度比选择下推的速度还要快，午饭都被你吃了，我今天中午都没吃饱啊。”</p>\n<p>“我记得你说过，选择下推是为了尽早的过滤数据，这样就能在上层结点降低计算量，是吧？”</p>\n<p>“是的。”大明点了点头，“还是通过一个关系代数的示例来说明一下它吧，顺便我们把等价类推理也可以说一说，比如说我们想要获得编号为5的老师承担的所有的课程名字，我们可以给出它的关系代数表达式。”说着大明在电脑上敲了一个关系代数表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Πcname (σTEACHER.tno&#x3D;5∧TEACHER.tno&#x3D;COURSE.tno (TEACHER×COURSE))</span><br></pre></td></tr></table></figure>\n\n<p>“小明，你看这个关系代数表达式怎么下推选择操作？”</p>\n<p>小明看着关系代数表达式思考了一会，说：“我看这个TEACHER.tno = 5比较可疑，你看这个关系代数表达式，先做了TEACHER×COURSE，也就是先做了卡氏积，我要是把TEACHER.tno = 5放到TEACHER上先把一些数据过滤掉，岂不是。。。完美！”说着小明也在电脑上敲出了把TEACHER.tno = 5下推之后的关系代数表达式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Πcname (σTEACHER.tno&#x3D;COURSE.tno (σTEACHER.tno&#x3D;5(TEACHER)×COURSE))</span><br></pre></td></tr></table></figure>\n\n<p>大明说；“对的，你这样下推下来，的确能降低计算量，你这应用的是关系代数表达式中的分配率σF(A × B) == σF1(A) × σF2(B)，那你看看，既然下推这么好，是不是投影也能下推？”小明看了一下，关系代数表达式中值需要对cname进行投影，顿时想到了，COURSE表虽然有很多个列，但是我们只需要使用cname就够了嘛，于是小明在电脑上敲了投影下推的关系代数表达式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Πcname (σTEACHER.tno&#x3D;COURSE.tno (σTEACHER.tno&#x3D;5(TEACHER)× Πcname(COURSE)))</span><br></pre></td></tr></table></figure>\n\n<p>大明拍了小明的头一下说：“笨蛋，你这样下推投影，TEACHER.tno=COURSE.tno还有办法做吗？”小明顿时领悟了，如果只在COURSE上对cname做投影时不行的，上层结点所有的表达式都需要考虑到，于是修改了表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Πcname (σTEACHER.tno&#x3D;COURSE.tno (σTEACHER.tno&#x3D;5(TEACHER)× Πcname, tno(COURSE)))</span><br></pre></td></tr></table></figure>\n\n<p>“这还差不多。”大明笑着说：“这是使用的投影的串接率，也是一个非常重要的关系代数等价规则，目前我们对这个表达式的优化主要是使用了选择下推，和投影下推，如果用SQL语句来表示，就像这样。”大明在电脑的记事本上快速的打印出了两个SQL语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sname FROM TEACHER t, COURSE c WHERE t.tno &#x3D; 5 AND t.tno &#x3D; c.tno;</span><br><span class=\"line\">SELECT sname FROM (SELECT * FROM TEACHER WHERE tno &#x3D; 5) tt, (SELECT cname, tno FROM COURSE) cc WHERE tt.tno &#x3D; cc.tno;</span><br></pre></td></tr></table></figure>\n\n<p>“你看这两个语句，就是谓词下推和投影下推前后的对照语句。在做卡氏积之前，先做了过滤，这样笛卡尔积的计算量会变小。”<br>小明仔细的观察着代数表达式和这两个SQL语句，他发现一个问题，就是关系代数表达式中有TEACHER.tno = 5和TEACHER.tno = COURSE.tno这样的两个约束条件，这是不是意味着COURSE.tno也应该等于5呢？小明然后试着在电脑上写了一个SQL语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sname FROM (SELECT * FROM TEACHER WHERE tno &#x3D; 5) tt, (SELECT cname, tno FROM COURSE WHERE tno&#x3D;5) cc WHERE tt.tno &#x3D; cc.tno;</span><br></pre></td></tr></table></figure>\n\n<p>然后小明说：“你看，由于有TEACHER.tno = 5和TEACHER.tno = COURSE.tno这样的两个约束条件，我们可以是不是可以推理出一个新的COURSE.tno = 5的新的约束条件来呢，这样我们还可以把这个条件下推到COURSE表上，这样也能降低笛卡尔积的计算量。”</p>\n<p>大明说：“是的，这就是等价推理，PostgreSQL数据库在查询优化的过程中，会将约束条件中等价的部分都记录到等价类中，这样就能根据等价类生成新的约束条件出来，比如示例的语句中就会产生一个等价类{TEACHER.tno, COURSE.tno, 5}，这是一个含有常量的等价类，是查询优化器比较喜欢的等价类，这种等价类可以得到列属性和常量组合成的约束条件，通常都是能下推的。”</p>\n<p>小明心里很高兴，自己通过仔细观察，得到了等价类的优化，感觉自己有了学习的动力，心里美滋滋的，然后就问大明：“那上面的SQL语句还有什么可优化的吗？”</p>\n<p>大明观察了一下这个语句，然后说：“你看，我们已经在TEACHER表上进行了TEACHER.tno = 5的过滤，在COURSE表上也做了COURSE.tno = 5的过滤，这样就说明在做笛卡尔积的时候，实际上已经确定了TEACHER.tno = COURSE.tno = 5，也就是说TEACHER.tno = COURSE.tno这个约束条件已经隐含成立了，也就没什么用了，我们可以把它去掉，最终形成一个这样的SQL语句。”大明在记事本中敲下了最终的语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sname FROM (SELECT * FROM TEACHER WHERE tno &#x3D; 5) tt, (SELECT cname, tno FROM COURSE WHERE tno&#x3D;5) cc；</span><br></pre></td></tr></table></figure>\n\n<p>同时也敲出了这个语句对应的关系代数表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Πcname (σTEACHER.tno&#x3D;5(TEACHER)× Πcname, tno(σCOURSE.tno&#x3D;5(COURSE)))</span><br></pre></td></tr></table></figure>\n\n<p>然后大明说：“经过选择下推、投影下推和等价类推理，我们对这个SQL语句或者说关系代数表达式进行了优化，最终降低了计算量。”</p>\n<p><img src=\"/2020/08/05/postgresql-optimizer-outline-4/1.png\"> </p>\n<p><img src=\"/2020/08/05/postgresql-optimizer-outline-4/1.png\"> </p>\n<p>小明感觉对谓词下推已经理解了，然后说：“看上去也不复杂嘛，我发现了可以下推的选择我就下推，完全没有问题啊。”大明笑着说：“甚矣，我从未见过如此厚颜无耻之人，我们现在看的这个例子，只不过是最简单的一种情况啊，你就这样大言不惭，你的人生字典里还有羞耻二字吗？”</p>\n<p>小明愤愤的说：“我的人生没有字典。。。”</p>\n<p>大明问道：“我们这个例子有一个问题，就是他是内连接，因此我们可以肆意妄为的将选择下推下来，可以没羞没臊的做等价类推理，但是如果是外连接，那还能这么做吗？”</p>\n<p>小明顿时陷入了苦苦的沉思。</p>"},{"title":"PostgreSQL优化器白话(5) - 严格要求自己","date":"2020-08-14T15:40:53.000Z","_content":"\n小明被大明将了一军，于是心里开始合计起来，假如是外连接，可能会对某一方补NULL值，这样的话TEACHER.tno = COURSE.tno这样的约束条件就无法构成等价类了啊，然后小在电脑上默默的敲了一个SQL语句：<!-- more -->\n\n```\nSELECT sname FROM TEACHER t LEFT JOIN COURSE c ON t.tno = 5 AND t.tno = c.tno;\n```\n\n然后小明发现不但等价类可能产生不了了，而且选择下推也无法进行了，于是说：“这个语句中的TEACHER.tno=5不能下推了，因为左连接的语义是外表的所有的数据都要输出出来，如果把TEACHER.tno=5下推到TEACHER表上，那就会在做左连接之前先对TEACHER表做过滤，导致查询结果的不等价，而且由于补NULL值，等价类也生成不了了。”\n\n大明说：“对的，小明同学你理解的很快，由于外连接补NULL值的关系，确实导致无法做谓词下推，不过你可以看一下下面的这个语句，看看有什么区别。”然后大明在电脑里输入了另一个类似的SQL语句：\n\n```\nSELECT sname FROM TEACHER t LEFT JOIN COURSE c ON TRUE WHERE t.tno = 5 AND t.tno = c.tno;\n```\n\n小明仔细的观察上面的例句和当前这个例句，发现约束条件一个处在ON后面，另一个是处在WHERE后面，小明好像还不是很理解他们的含义，于是向大明投去了咨询的目光。大明说：“我们粗略的分一下，ON后面的约束条件是连接条件，WHERE后面的约束条件是过滤条件，连接条件和过滤条件是不同的。”\n\n小明好像悟到了什么，抢着说：“我知道了，一个是连接中的，一个是连接后的，可以这么理解吧？你看，连接条件会参与到连接操作的过程中，满足连接条件的会显示出来，不满足连接条件的，根据连接的类型还会决定是否补NULL值，而过滤条件是在连接操作之后对连接的结果进行过滤。。。”小明又对大明投去了期待的眼神，这种眼神是期望得到一点肯定，大明笑着说：“对，可以这么理解。”\n\n小明赶紧说：“你先别讲，让我看看这个带有过滤条件的SQL语句是不是能下推。”，然后小明对着这个SQL语句仔细观察起来，口中念念有词，似乎是已经走火入魔了。\n\n小明观察了半天，好无收获，只好说：“我掐指一算，觉得这个约束条件是能下推的，而且等价类也能建立起来。”\n\n“为什么？”大明追问道。\n\n“不为什么，我脑海中灵光乍现，我是一个佛系的程序员。”\n\n“你果然没有人生的字典，想必你即使有人生字典，你也把羞耻二字给扣掉了。”\n\n小明笑着说：“是的，像我这样优秀的人，本该灿烂过一生啊。。。”\n\n大明看小明竟然唱起了歌，愤怒的说：“不要胡闹，再胡闹我就让你一杯敬自由，一杯敬死亡。。。”大明停顿了一下，继续说道：“实际上这里还有一个严格的概念，什么叫严格呢？一个表达式，如果它的输入是NULL并且输出也是NULL，那么我们就说这个表达式是严格的，另外我们可以扩展一下严格的定义，从而定义出一个叫做‘宽泛的严格’的概念，就是说如果一个表达式它的输入是NULL，它的输出是NULL或者false，那么我们就说它符合宽泛的严格。”\n\n“那么严格有什么用呢？”\n\n“如果对一个元组应用约束条件，如果约束条件求值返回的是NULL值或者FALSE，实际上代表的是这一条元组不输出，明白吗？”\n“哦，那就是说我们补的NULL值如果遇到这种过滤条件，就不会输出出来喽。”小明停了一下，突然想到了些什么，继续问道，“那这种外连接还补NULL值干嘛，岂不是没有什么卵用了？”\n\n“对头，这就是外连接消除的基本原理，遇上这种严格的约束条件，外连接补的NULL值没有什么用，那也就转变成内连接就好了。问题来了，如果变成了内连接，我们又能肆意妄为的选择下推、没羞没臊的做等价推理了，惊不惊喜，意不意外？”\n\n“哈哈，那你能给我一个不严格的例子不？让我见识一下不严格的表达式。”\n\n“比如说IS NOT NULL，输入是NULL值，输出竟然是TRUE，还有COALESCE函数，输入是NULL值，输出是啥随你定。”\n\n小明说：“看来表达式是否严格是很重要的一个概念，通过这个概念我们能做外连接消除，外连接消除又能够导致选择能够下推。。。这我就明白了为什么要做外连接消除了。”\n\n“嗯，外连接消除不只是将外连接转换成内连接，其实还有一种情况，它也和我们要说的表达式的条件是否严格有关，那就是可以将外连接转换成AntiJoin，我们来看这样一个例子。”\n\n```\nSELECT * FROM STUDENT LEFT JOIN SCORE ON STUDENT.sno = SCORE.sno WHERE SCORE.sno IS NULL;\n```\n\n“由于STUDENT.sno = SCORE.sno是严格的，而且是连接条件，这样在连接的过程中他会将在STUDENT表和SCORE表中原有的NULL值去除掉，反而由于SOCRE.sno IS NULL是过滤条件，它起到了过滤作用，会将外连接补充NULL值的数据全部保留下来，这个语句的执行结果实际上就相当于做了一个Anti Join，因此这个语句可以转换成为Anti Join，它转换的结果相当于下面这个语句。”大明在电脑上敲出了等价语句，啪啪啪。。。\n\n```\nSELECT * FROM STUDENT ANTI JOIN SCORE ON STUDENT.sno = SCORE.sno\n```\n\n“不过需要注意，SQL语法中是没有ANTI JOIN的，这只是一个等价的语句，但是它无法直接执行。另外在外连接消除的阶段还有一个“很重大”的举措，就是把左外连接全部转换成了右外连接，这样就可以在后续的代码中少处理一种情况，简化了后面的代码逻辑。”\n\n“严格果然是太有用了，可是我怎么知道一个表达式是不是严格呢？”\n\n“对于函数而言，在PG_PROC系统表中的proisstrict列属性代表了当前函数是否严格，如果是操作符表达式，在PostgreSQL数据库中操作符实际都转成了对应的函数，因此也可以用proisstrict来表示是否严格，而对基于IS [NOT] NULL产生的NullTest表达式需要单独处理，其中IS NOT NULL是严格的，IS NULL是不严格的，大体上我们可以分成这么几类。”\n\n小明感觉自己今天好像学到了好多知识，幸好自己有个哥哥，不然很难有人这么教自己，于是发自内心的说：“OK，我又增加了新的知识，谢谢。”\n\n“不要谢我，我是雷锋，我们都是在为中华之崛起而读书，想想我们可是社会主义接班人啊。。。”大明感觉自己胸前的仿佛有红领巾在迎风飘扬，而且更加鲜艳了。\n","source":"_posts/postgresql-optimizer-outline-5.md","raw":"---\ntitle: PostgreSQL优化器白话(5) - 严格要求自己\ndate: 2020-08-14 23:40:53\n---\n\n小明被大明将了一军，于是心里开始合计起来，假如是外连接，可能会对某一方补NULL值，这样的话TEACHER.tno = COURSE.tno这样的约束条件就无法构成等价类了啊，然后小在电脑上默默的敲了一个SQL语句：<!-- more -->\n\n```\nSELECT sname FROM TEACHER t LEFT JOIN COURSE c ON t.tno = 5 AND t.tno = c.tno;\n```\n\n然后小明发现不但等价类可能产生不了了，而且选择下推也无法进行了，于是说：“这个语句中的TEACHER.tno=5不能下推了，因为左连接的语义是外表的所有的数据都要输出出来，如果把TEACHER.tno=5下推到TEACHER表上，那就会在做左连接之前先对TEACHER表做过滤，导致查询结果的不等价，而且由于补NULL值，等价类也生成不了了。”\n\n大明说：“对的，小明同学你理解的很快，由于外连接补NULL值的关系，确实导致无法做谓词下推，不过你可以看一下下面的这个语句，看看有什么区别。”然后大明在电脑里输入了另一个类似的SQL语句：\n\n```\nSELECT sname FROM TEACHER t LEFT JOIN COURSE c ON TRUE WHERE t.tno = 5 AND t.tno = c.tno;\n```\n\n小明仔细的观察上面的例句和当前这个例句，发现约束条件一个处在ON后面，另一个是处在WHERE后面，小明好像还不是很理解他们的含义，于是向大明投去了咨询的目光。大明说：“我们粗略的分一下，ON后面的约束条件是连接条件，WHERE后面的约束条件是过滤条件，连接条件和过滤条件是不同的。”\n\n小明好像悟到了什么，抢着说：“我知道了，一个是连接中的，一个是连接后的，可以这么理解吧？你看，连接条件会参与到连接操作的过程中，满足连接条件的会显示出来，不满足连接条件的，根据连接的类型还会决定是否补NULL值，而过滤条件是在连接操作之后对连接的结果进行过滤。。。”小明又对大明投去了期待的眼神，这种眼神是期望得到一点肯定，大明笑着说：“对，可以这么理解。”\n\n小明赶紧说：“你先别讲，让我看看这个带有过滤条件的SQL语句是不是能下推。”，然后小明对着这个SQL语句仔细观察起来，口中念念有词，似乎是已经走火入魔了。\n\n小明观察了半天，好无收获，只好说：“我掐指一算，觉得这个约束条件是能下推的，而且等价类也能建立起来。”\n\n“为什么？”大明追问道。\n\n“不为什么，我脑海中灵光乍现，我是一个佛系的程序员。”\n\n“你果然没有人生的字典，想必你即使有人生字典，你也把羞耻二字给扣掉了。”\n\n小明笑着说：“是的，像我这样优秀的人，本该灿烂过一生啊。。。”\n\n大明看小明竟然唱起了歌，愤怒的说：“不要胡闹，再胡闹我就让你一杯敬自由，一杯敬死亡。。。”大明停顿了一下，继续说道：“实际上这里还有一个严格的概念，什么叫严格呢？一个表达式，如果它的输入是NULL并且输出也是NULL，那么我们就说这个表达式是严格的，另外我们可以扩展一下严格的定义，从而定义出一个叫做‘宽泛的严格’的概念，就是说如果一个表达式它的输入是NULL，它的输出是NULL或者false，那么我们就说它符合宽泛的严格。”\n\n“那么严格有什么用呢？”\n\n“如果对一个元组应用约束条件，如果约束条件求值返回的是NULL值或者FALSE，实际上代表的是这一条元组不输出，明白吗？”\n“哦，那就是说我们补的NULL值如果遇到这种过滤条件，就不会输出出来喽。”小明停了一下，突然想到了些什么，继续问道，“那这种外连接还补NULL值干嘛，岂不是没有什么卵用了？”\n\n“对头，这就是外连接消除的基本原理，遇上这种严格的约束条件，外连接补的NULL值没有什么用，那也就转变成内连接就好了。问题来了，如果变成了内连接，我们又能肆意妄为的选择下推、没羞没臊的做等价推理了，惊不惊喜，意不意外？”\n\n“哈哈，那你能给我一个不严格的例子不？让我见识一下不严格的表达式。”\n\n“比如说IS NOT NULL，输入是NULL值，输出竟然是TRUE，还有COALESCE函数，输入是NULL值，输出是啥随你定。”\n\n小明说：“看来表达式是否严格是很重要的一个概念，通过这个概念我们能做外连接消除，外连接消除又能够导致选择能够下推。。。这我就明白了为什么要做外连接消除了。”\n\n“嗯，外连接消除不只是将外连接转换成内连接，其实还有一种情况，它也和我们要说的表达式的条件是否严格有关，那就是可以将外连接转换成AntiJoin，我们来看这样一个例子。”\n\n```\nSELECT * FROM STUDENT LEFT JOIN SCORE ON STUDENT.sno = SCORE.sno WHERE SCORE.sno IS NULL;\n```\n\n“由于STUDENT.sno = SCORE.sno是严格的，而且是连接条件，这样在连接的过程中他会将在STUDENT表和SCORE表中原有的NULL值去除掉，反而由于SOCRE.sno IS NULL是过滤条件，它起到了过滤作用，会将外连接补充NULL值的数据全部保留下来，这个语句的执行结果实际上就相当于做了一个Anti Join，因此这个语句可以转换成为Anti Join，它转换的结果相当于下面这个语句。”大明在电脑上敲出了等价语句，啪啪啪。。。\n\n```\nSELECT * FROM STUDENT ANTI JOIN SCORE ON STUDENT.sno = SCORE.sno\n```\n\n“不过需要注意，SQL语法中是没有ANTI JOIN的，这只是一个等价的语句，但是它无法直接执行。另外在外连接消除的阶段还有一个“很重大”的举措，就是把左外连接全部转换成了右外连接，这样就可以在后续的代码中少处理一种情况，简化了后面的代码逻辑。”\n\n“严格果然是太有用了，可是我怎么知道一个表达式是不是严格呢？”\n\n“对于函数而言，在PG_PROC系统表中的proisstrict列属性代表了当前函数是否严格，如果是操作符表达式，在PostgreSQL数据库中操作符实际都转成了对应的函数，因此也可以用proisstrict来表示是否严格，而对基于IS [NOT] NULL产生的NullTest表达式需要单独处理，其中IS NOT NULL是严格的，IS NULL是不严格的，大体上我们可以分成这么几类。”\n\n小明感觉自己今天好像学到了好多知识，幸好自己有个哥哥，不然很难有人这么教自己，于是发自内心的说：“OK，我又增加了新的知识，谢谢。”\n\n“不要谢我，我是雷锋，我们都是在为中华之崛起而读书，想想我们可是社会主义接班人啊。。。”大明感觉自己胸前的仿佛有红领巾在迎风飘扬，而且更加鲜艳了。\n","slug":"postgresql-optimizer-outline-5","published":1,"updated":"2020-08-14T15:45:18.000Z","_id":"ckduejkln0000ox9k0nxvhd01","comments":1,"layout":"post","photos":[],"link":"","content":"<p>小明被大明将了一军，于是心里开始合计起来，假如是外连接，可能会对某一方补NULL值，这样的话TEACHER.tno = COURSE.tno这样的约束条件就无法构成等价类了啊，然后小在电脑上默默的敲了一个SQL语句：<a id=\"more\"></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sname FROM TEACHER t LEFT JOIN COURSE c ON t.tno &#x3D; 5 AND t.tno &#x3D; c.tno;</span><br></pre></td></tr></table></figure>\n\n<p>然后小明发现不但等价类可能产生不了了，而且选择下推也无法进行了，于是说：“这个语句中的TEACHER.tno=5不能下推了，因为左连接的语义是外表的所有的数据都要输出出来，如果把TEACHER.tno=5下推到TEACHER表上，那就会在做左连接之前先对TEACHER表做过滤，导致查询结果的不等价，而且由于补NULL值，等价类也生成不了了。”</p>\n<p>大明说：“对的，小明同学你理解的很快，由于外连接补NULL值的关系，确实导致无法做谓词下推，不过你可以看一下下面的这个语句，看看有什么区别。”然后大明在电脑里输入了另一个类似的SQL语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sname FROM TEACHER t LEFT JOIN COURSE c ON TRUE WHERE t.tno &#x3D; 5 AND t.tno &#x3D; c.tno;</span><br></pre></td></tr></table></figure>\n\n<p>小明仔细的观察上面的例句和当前这个例句，发现约束条件一个处在ON后面，另一个是处在WHERE后面，小明好像还不是很理解他们的含义，于是向大明投去了咨询的目光。大明说：“我们粗略的分一下，ON后面的约束条件是连接条件，WHERE后面的约束条件是过滤条件，连接条件和过滤条件是不同的。”</p>\n<p>小明好像悟到了什么，抢着说：“我知道了，一个是连接中的，一个是连接后的，可以这么理解吧？你看，连接条件会参与到连接操作的过程中，满足连接条件的会显示出来，不满足连接条件的，根据连接的类型还会决定是否补NULL值，而过滤条件是在连接操作之后对连接的结果进行过滤。。。”小明又对大明投去了期待的眼神，这种眼神是期望得到一点肯定，大明笑着说：“对，可以这么理解。”</p>\n<p>小明赶紧说：“你先别讲，让我看看这个带有过滤条件的SQL语句是不是能下推。”，然后小明对着这个SQL语句仔细观察起来，口中念念有词，似乎是已经走火入魔了。</p>\n<p>小明观察了半天，好无收获，只好说：“我掐指一算，觉得这个约束条件是能下推的，而且等价类也能建立起来。”</p>\n<p>“为什么？”大明追问道。</p>\n<p>“不为什么，我脑海中灵光乍现，我是一个佛系的程序员。”</p>\n<p>“你果然没有人生的字典，想必你即使有人生字典，你也把羞耻二字给扣掉了。”</p>\n<p>小明笑着说：“是的，像我这样优秀的人，本该灿烂过一生啊。。。”</p>\n<p>大明看小明竟然唱起了歌，愤怒的说：“不要胡闹，再胡闹我就让你一杯敬自由，一杯敬死亡。。。”大明停顿了一下，继续说道：“实际上这里还有一个严格的概念，什么叫严格呢？一个表达式，如果它的输入是NULL并且输出也是NULL，那么我们就说这个表达式是严格的，另外我们可以扩展一下严格的定义，从而定义出一个叫做‘宽泛的严格’的概念，就是说如果一个表达式它的输入是NULL，它的输出是NULL或者false，那么我们就说它符合宽泛的严格。”</p>\n<p>“那么严格有什么用呢？”</p>\n<p>“如果对一个元组应用约束条件，如果约束条件求值返回的是NULL值或者FALSE，实际上代表的是这一条元组不输出，明白吗？”<br>“哦，那就是说我们补的NULL值如果遇到这种过滤条件，就不会输出出来喽。”小明停了一下，突然想到了些什么，继续问道，“那这种外连接还补NULL值干嘛，岂不是没有什么卵用了？”</p>\n<p>“对头，这就是外连接消除的基本原理，遇上这种严格的约束条件，外连接补的NULL值没有什么用，那也就转变成内连接就好了。问题来了，如果变成了内连接，我们又能肆意妄为的选择下推、没羞没臊的做等价推理了，惊不惊喜，意不意外？”</p>\n<p>“哈哈，那你能给我一个不严格的例子不？让我见识一下不严格的表达式。”</p>\n<p>“比如说IS NOT NULL，输入是NULL值，输出竟然是TRUE，还有COALESCE函数，输入是NULL值，输出是啥随你定。”</p>\n<p>小明说：“看来表达式是否严格是很重要的一个概念，通过这个概念我们能做外连接消除，外连接消除又能够导致选择能够下推。。。这我就明白了为什么要做外连接消除了。”</p>\n<p>“嗯，外连接消除不只是将外连接转换成内连接，其实还有一种情况，它也和我们要说的表达式的条件是否严格有关，那就是可以将外连接转换成AntiJoin，我们来看这样一个例子。”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM STUDENT LEFT JOIN SCORE ON STUDENT.sno &#x3D; SCORE.sno WHERE SCORE.sno IS NULL;</span><br></pre></td></tr></table></figure>\n\n<p>“由于STUDENT.sno = SCORE.sno是严格的，而且是连接条件，这样在连接的过程中他会将在STUDENT表和SCORE表中原有的NULL值去除掉，反而由于SOCRE.sno IS NULL是过滤条件，它起到了过滤作用，会将外连接补充NULL值的数据全部保留下来，这个语句的执行结果实际上就相当于做了一个Anti Join，因此这个语句可以转换成为Anti Join，它转换的结果相当于下面这个语句。”大明在电脑上敲出了等价语句，啪啪啪。。。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM STUDENT ANTI JOIN SCORE ON STUDENT.sno &#x3D; SCORE.sno</span><br></pre></td></tr></table></figure>\n\n<p>“不过需要注意，SQL语法中是没有ANTI JOIN的，这只是一个等价的语句，但是它无法直接执行。另外在外连接消除的阶段还有一个“很重大”的举措，就是把左外连接全部转换成了右外连接，这样就可以在后续的代码中少处理一种情况，简化了后面的代码逻辑。”</p>\n<p>“严格果然是太有用了，可是我怎么知道一个表达式是不是严格呢？”</p>\n<p>“对于函数而言，在PG_PROC系统表中的proisstrict列属性代表了当前函数是否严格，如果是操作符表达式，在PostgreSQL数据库中操作符实际都转成了对应的函数，因此也可以用proisstrict来表示是否严格，而对基于IS [NOT] NULL产生的NullTest表达式需要单独处理，其中IS NOT NULL是严格的，IS NULL是不严格的，大体上我们可以分成这么几类。”</p>\n<p>小明感觉自己今天好像学到了好多知识，幸好自己有个哥哥，不然很难有人这么教自己，于是发自内心的说：“OK，我又增加了新的知识，谢谢。”</p>\n<p>“不要谢我，我是雷锋，我们都是在为中华之崛起而读书，想想我们可是社会主义接班人啊。。。”大明感觉自己胸前的仿佛有红领巾在迎风飘扬，而且更加鲜艳了。</p>\n","site":{"data":{}},"excerpt":"<p>小明被大明将了一军，于是心里开始合计起来，假如是外连接，可能会对某一方补NULL值，这样的话TEACHER.tno = COURSE.tno这样的约束条件就无法构成等价类了啊，然后小在电脑上默默的敲了一个SQL语句：</p>","more":"<p></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sname FROM TEACHER t LEFT JOIN COURSE c ON t.tno &#x3D; 5 AND t.tno &#x3D; c.tno;</span><br></pre></td></tr></table></figure>\n\n<p>然后小明发现不但等价类可能产生不了了，而且选择下推也无法进行了，于是说：“这个语句中的TEACHER.tno=5不能下推了，因为左连接的语义是外表的所有的数据都要输出出来，如果把TEACHER.tno=5下推到TEACHER表上，那就会在做左连接之前先对TEACHER表做过滤，导致查询结果的不等价，而且由于补NULL值，等价类也生成不了了。”</p>\n<p>大明说：“对的，小明同学你理解的很快，由于外连接补NULL值的关系，确实导致无法做谓词下推，不过你可以看一下下面的这个语句，看看有什么区别。”然后大明在电脑里输入了另一个类似的SQL语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sname FROM TEACHER t LEFT JOIN COURSE c ON TRUE WHERE t.tno &#x3D; 5 AND t.tno &#x3D; c.tno;</span><br></pre></td></tr></table></figure>\n\n<p>小明仔细的观察上面的例句和当前这个例句，发现约束条件一个处在ON后面，另一个是处在WHERE后面，小明好像还不是很理解他们的含义，于是向大明投去了咨询的目光。大明说：“我们粗略的分一下，ON后面的约束条件是连接条件，WHERE后面的约束条件是过滤条件，连接条件和过滤条件是不同的。”</p>\n<p>小明好像悟到了什么，抢着说：“我知道了，一个是连接中的，一个是连接后的，可以这么理解吧？你看，连接条件会参与到连接操作的过程中，满足连接条件的会显示出来，不满足连接条件的，根据连接的类型还会决定是否补NULL值，而过滤条件是在连接操作之后对连接的结果进行过滤。。。”小明又对大明投去了期待的眼神，这种眼神是期望得到一点肯定，大明笑着说：“对，可以这么理解。”</p>\n<p>小明赶紧说：“你先别讲，让我看看这个带有过滤条件的SQL语句是不是能下推。”，然后小明对着这个SQL语句仔细观察起来，口中念念有词，似乎是已经走火入魔了。</p>\n<p>小明观察了半天，好无收获，只好说：“我掐指一算，觉得这个约束条件是能下推的，而且等价类也能建立起来。”</p>\n<p>“为什么？”大明追问道。</p>\n<p>“不为什么，我脑海中灵光乍现，我是一个佛系的程序员。”</p>\n<p>“你果然没有人生的字典，想必你即使有人生字典，你也把羞耻二字给扣掉了。”</p>\n<p>小明笑着说：“是的，像我这样优秀的人，本该灿烂过一生啊。。。”</p>\n<p>大明看小明竟然唱起了歌，愤怒的说：“不要胡闹，再胡闹我就让你一杯敬自由，一杯敬死亡。。。”大明停顿了一下，继续说道：“实际上这里还有一个严格的概念，什么叫严格呢？一个表达式，如果它的输入是NULL并且输出也是NULL，那么我们就说这个表达式是严格的，另外我们可以扩展一下严格的定义，从而定义出一个叫做‘宽泛的严格’的概念，就是说如果一个表达式它的输入是NULL，它的输出是NULL或者false，那么我们就说它符合宽泛的严格。”</p>\n<p>“那么严格有什么用呢？”</p>\n<p>“如果对一个元组应用约束条件，如果约束条件求值返回的是NULL值或者FALSE，实际上代表的是这一条元组不输出，明白吗？”<br>“哦，那就是说我们补的NULL值如果遇到这种过滤条件，就不会输出出来喽。”小明停了一下，突然想到了些什么，继续问道，“那这种外连接还补NULL值干嘛，岂不是没有什么卵用了？”</p>\n<p>“对头，这就是外连接消除的基本原理，遇上这种严格的约束条件，外连接补的NULL值没有什么用，那也就转变成内连接就好了。问题来了，如果变成了内连接，我们又能肆意妄为的选择下推、没羞没臊的做等价推理了，惊不惊喜，意不意外？”</p>\n<p>“哈哈，那你能给我一个不严格的例子不？让我见识一下不严格的表达式。”</p>\n<p>“比如说IS NOT NULL，输入是NULL值，输出竟然是TRUE，还有COALESCE函数，输入是NULL值，输出是啥随你定。”</p>\n<p>小明说：“看来表达式是否严格是很重要的一个概念，通过这个概念我们能做外连接消除，外连接消除又能够导致选择能够下推。。。这我就明白了为什么要做外连接消除了。”</p>\n<p>“嗯，外连接消除不只是将外连接转换成内连接，其实还有一种情况，它也和我们要说的表达式的条件是否严格有关，那就是可以将外连接转换成AntiJoin，我们来看这样一个例子。”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM STUDENT LEFT JOIN SCORE ON STUDENT.sno &#x3D; SCORE.sno WHERE SCORE.sno IS NULL;</span><br></pre></td></tr></table></figure>\n\n<p>“由于STUDENT.sno = SCORE.sno是严格的，而且是连接条件，这样在连接的过程中他会将在STUDENT表和SCORE表中原有的NULL值去除掉，反而由于SOCRE.sno IS NULL是过滤条件，它起到了过滤作用，会将外连接补充NULL值的数据全部保留下来，这个语句的执行结果实际上就相当于做了一个Anti Join，因此这个语句可以转换成为Anti Join，它转换的结果相当于下面这个语句。”大明在电脑上敲出了等价语句，啪啪啪。。。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM STUDENT ANTI JOIN SCORE ON STUDENT.sno &#x3D; SCORE.sno</span><br></pre></td></tr></table></figure>\n\n<p>“不过需要注意，SQL语法中是没有ANTI JOIN的，这只是一个等价的语句，但是它无法直接执行。另外在外连接消除的阶段还有一个“很重大”的举措，就是把左外连接全部转换成了右外连接，这样就可以在后续的代码中少处理一种情况，简化了后面的代码逻辑。”</p>\n<p>“严格果然是太有用了，可是我怎么知道一个表达式是不是严格呢？”</p>\n<p>“对于函数而言，在PG_PROC系统表中的proisstrict列属性代表了当前函数是否严格，如果是操作符表达式，在PostgreSQL数据库中操作符实际都转成了对应的函数，因此也可以用proisstrict来表示是否严格，而对基于IS [NOT] NULL产生的NullTest表达式需要单独处理，其中IS NOT NULL是严格的，IS NULL是不严格的，大体上我们可以分成这么几类。”</p>\n<p>小明感觉自己今天好像学到了好多知识，幸好自己有个哥哥，不然很难有人这么教自己，于是发自内心的说：“OK，我又增加了新的知识，谢谢。”</p>\n<p>“不要谢我，我是雷锋，我们都是在为中华之崛起而读书，想想我们可是社会主义接班人啊。。。”大明感觉自己胸前的仿佛有红领巾在迎风飘扬，而且更加鲜艳了。</p>"},{"title":"PostgreSQL优化器白话(6) - 统计局旁的泉水","date":"2020-10-03T00:23:35.000Z","_content":"\n\n“咚咚咚。。。咚咚咚”门外传来了敲门声，大明去打开房门一看，进来的原来是自己的同事牛二哥，牛二哥是专门从事数据库查询优化开发的码农，也有十几年的从业经验了，大明感到非常happy，因为这两天给小明讲查询优化器干到有些吃力，今天牛二哥来了，可以帮助自己给小明来讲查询优化器了，于是和牛二哥说：“牛二同志，来了就别走了，今天大腰子加红酒管够，你来帮我个忙。”\n\n牛二哥是大腰子爱好者，听说有大腰子，顿时感觉浑身鸡血翻腾，连忙说：“没问题，不过要帮什么忙？”\n<!-- more -->\n大明说：“我的弟弟小明最近在学校要进行数据库原理实践，最近总来问我优化器的问题，可我对优化器也是一知半解，这下你来了，你可以帮我弟弟讲讲优化器了。”\n\n牛二哥痛快的说：“这难不倒我，随时都可以讲。”\n\n大明说：“好嘞，我先给我的弟弟小明打个电话，和他说有优化器高手来了，赶紧过来请教。”\n\n……（此处略去近千字）\n\n小明早就听说过牛二哥的名字，据说对查询优化非常了解，没想到牛二哥竟然和自己的哥哥是同事，于是赶紧来到了大明家，看到牛二哥的洗旧的格子衫和半秃的发型，感觉就像少林寺的扫地僧一样，于是赶紧说：“我这最近正在查看基于代价的优化，感觉付出了很多代价，但收获甚微啊，期望今天能得到牛二哥的指导。”\n\n牛二哥说：“不客气，我是也是受到了大腰子和红酒的诱惑，估计今天也要付出惨痛的代价。。。。你有什么问题尽管问，我捡我会的回答。”看着小明稚嫩的脸庞，牛二哥突然想起了自己刚开始从事数据库内核开发的日子，心底翻腾起一股悲凉感，那是一段不堪回首的血泪史啊，有血、有泪、有。。。\n\n牛二哥突然想到了什么，继续说道：“说到代价，我觉得有个东西是绕不过去的，那就是统计信息和选择率，PostgreSQL数据库的物理优化需要计算各种物理路径的代价，而代价估算的过程严重的依赖于数据库的统计信息，统计信息是否能准确的描述表中的数据分布情况是决定代价的准确性的重要条件之一。”\n\n小明说：“大明和我说过，数据库有很多的物理路径，这些物理路径我们也叫他们物理算子，和逻辑算子不同，物理算子是查询执行器的执行方法，我们只需要计算物理算子每个步骤的代价，汇总起来就是路径的代价了，那要统计信息有什么用呢？”\n\n牛二哥看了看大明，意思是让大明来说，不过大明正在专心的查吃了吗外卖APP，找大腰子和红酒，并没有看到牛二哥的眼神，牛二哥只好尴尬的说：“是的，我们就是要计算一个物理算子的代价，但是物理算子的计算量并不是一成不变的。”说着牛二哥从旁边的书桌上拿来纸和笔，在纸上写了两个SQL语句。\n\n```\n\tSELECT A+B FROM TEST_A WHERE A > 1;\n\tSELECT A+B FROM TEST_A WHERE A > 100000000;\n```\n\t\n然后牛二哥说：“你看，这两个语句可以用同样的物理算子来完成，但是他们的计算量一样吗？”\n\n小明心想：A > 1和A > 1000000000都是过滤条件，经过过滤之后，他们产生的数据量就不同了，这样投影中的A+B的计算的次数就不同了，所以他们的代价应该是不同的，那它和统计信息有什么关系呢？小明感觉灵光一闪，马上说：“我知道了，我在计算物理算子的代价的时候，要知道A > 1之后还剩下多少数据或者A > 1000000000之后还剩下多少数据，如果我们提前对表上的数据内容做了统计，剩下多少数据就不难计算了，所以必须要有统计信息。”\n\n牛二哥点了点头，说：“嗯，通过统计信息，代价估算系统就可以了解一个表有多少行数据、用了多少个数据页面、某个值出现的频率等等，然后就能根据这些信息计算出一个约束条件能过滤掉多少数据，这种约束条件过滤出的数据占总数据量的比例称之为‘选择率’，所谓选择率就是一个比例，它的公式是这样的。”说着牛二哥继续在纸上写了选择率的公式：\n选择率=约束条件过滤后的元组数/约束条件过滤前的总元组数\n\n“不过上面的示例有点简单了，实际应用中通常约束条件会比较多，而且比较复杂，通常我们会计算每个子约束条件的选择率，然后就可以根据AND运算符和OR运算符计算它们的综合的选择率，AND运算符和OR运算符的选择率计算是基于概率的，你看这里的概率公式。”说着，牛二哥又继续在纸上写起来。\n\n```\nP(A+B)=P(A)+P(B)-P(AB)\nP(AB)=P(A)×P(B)\n```\n\n“有了这些，我们就可以求解多种类型的约束条件的选择率了，比如。。。”牛二哥继续在纸上画起来：\n\n```\n    P(ssex IS NOT NULL OR sno > 5) \n  = P(ssex IS NOT NULL) + P(sno > 5) – P(ssex IS NOT NULL AND sno > 5)\n  = P(ssex IS NOT NULL) + P(sno > 5) – P(ssex IS NOT NULL) × P(no > 5)\n```\n\n小明觉得牛二哥的进展有点快，赶紧问：“那么统计信息是什么形式的呢？”\n\n牛二哥挠挠头，说：“这个还真是有点麻烦，我们说常用的统计信息的形式就是distinct率、NULL值率、高频值、直方图、相关系数这些，他们分别有不同的作用，比如说distinct率，你可以获知某一列有多少个独立值，这种信息对于像性别这种列就显得特别有用，NULL值率呢？在统计的过程中，NULL值是不好处理的，因此把它独立出来，形成NULL值率，这样在高频值、直方图这些里面就不用考虑NULL值的情况了，高频值属于奇异值，顾名思义，就是出现的比较多的一些列值，去掉了NULL值，再去掉高频值，剩下的值可以用来做一个等频的直方图。。。。”\n \n“呃。。。”小明感觉跟不上牛二哥的速度了，于是说：“有点快，我有点跟不上了。”\n\t\n这时大明已经点完了外卖，过来说：“别急，外卖没有那么快送到，至于统计信息嘛，主要的还是高频值、直方图和相关系数，实际上我建议还是不要纠结于统计信息有哪些形式，我们只要知道它是用来算代价的就可以了。”\n\n牛二哥对大明说：“这怎么可以，我还没有说统计信息是如何生成的呢，比如它通过了两阶段采样，然后对样本进行统计时使用的统计方法，哪些值可以作为高频值，直方图有几个桶，相关系数是怎么计算的，相关系数在计算索引扫描路径代价的时候怎么用的，而且我和你说，PostgreSQL还出了基于多列的扩展统计信息，多列统计信息分成了哪些类型，分别是什么含义，各自是怎么计算的，还有选择率是怎么结合统计信息计算的，这些我还没说呢。。。”\n\n大明说：“你快闭嘴吧，像你这样讲优化器，岂不是要出一本书。”\n\n牛二哥做痛苦状：“那好吧，统计信息我们就说到这里吧，但是它确实是代价计算的基石，小明同学，你理解了它的作用就可以了。”\n\n小明痛苦的说：“牛二哥，你说了这么多，都不告诉我答案，我感觉要学的内容好多啊。”\n\n大明笑着说：“不用这么痛苦嘛，没有啥事是一顿烧烤不能解决的，如果有，那就是两顿。”然后大明继续神秘的说：“实际上统计信息往往也不准，你想想本来就是采样的结果嘛，样本是否显著压根就不好说，而且随着应用程序对表的更新，统计信息可能更新不及时，那就更会出现偏差。更严重的是，如果我们遇到a > b这样的约束条件，使用统计信息计算选择率也很不好计算，即使算出来，也不准嘛。”\n\n牛二哥说：“是的，统计信息确实也有不准确的问题，我听说有个DBA，他家祖坟旁边出了一口泉水，他爸爸觉得是吉兆，去找风水大师看一看，风水大师掐指算一算，说：你儿子是个DBA，每次数据库性能慢就知道更新统计信息，可是统计信息太水了，都从你家祖坟冒出来了。”\n\n三个人顿时笑做一团，气氛从痛苦又恢复到了活泼，大明说：“学习查询优化器确实还是比较繁琐的，绝对不是我们通过一两次讲解就能让你变得精通的，这个学习的曲线还是比较陡峭的。”\n\n小明点了点头说：“好吧，有了两位师傅，再加上我自己天资聪慧、风流倜傥、玉树临风、高大威武、骨骼惊奇，我相信一定能将优化器搞定。”\n\n大明和牛二哥都晕倒在地上。。。\n","source":"_posts/postgresql-optimizer-outline-6.md","raw":"---\ntitle: PostgreSQL优化器白话(6) - 统计局旁的泉水\ndate: 2020-10-03 08:23:35\n---\n\n\n“咚咚咚。。。咚咚咚”门外传来了敲门声，大明去打开房门一看，进来的原来是自己的同事牛二哥，牛二哥是专门从事数据库查询优化开发的码农，也有十几年的从业经验了，大明感到非常happy，因为这两天给小明讲查询优化器干到有些吃力，今天牛二哥来了，可以帮助自己给小明来讲查询优化器了，于是和牛二哥说：“牛二同志，来了就别走了，今天大腰子加红酒管够，你来帮我个忙。”\n\n牛二哥是大腰子爱好者，听说有大腰子，顿时感觉浑身鸡血翻腾，连忙说：“没问题，不过要帮什么忙？”\n<!-- more -->\n大明说：“我的弟弟小明最近在学校要进行数据库原理实践，最近总来问我优化器的问题，可我对优化器也是一知半解，这下你来了，你可以帮我弟弟讲讲优化器了。”\n\n牛二哥痛快的说：“这难不倒我，随时都可以讲。”\n\n大明说：“好嘞，我先给我的弟弟小明打个电话，和他说有优化器高手来了，赶紧过来请教。”\n\n……（此处略去近千字）\n\n小明早就听说过牛二哥的名字，据说对查询优化非常了解，没想到牛二哥竟然和自己的哥哥是同事，于是赶紧来到了大明家，看到牛二哥的洗旧的格子衫和半秃的发型，感觉就像少林寺的扫地僧一样，于是赶紧说：“我这最近正在查看基于代价的优化，感觉付出了很多代价，但收获甚微啊，期望今天能得到牛二哥的指导。”\n\n牛二哥说：“不客气，我是也是受到了大腰子和红酒的诱惑，估计今天也要付出惨痛的代价。。。。你有什么问题尽管问，我捡我会的回答。”看着小明稚嫩的脸庞，牛二哥突然想起了自己刚开始从事数据库内核开发的日子，心底翻腾起一股悲凉感，那是一段不堪回首的血泪史啊，有血、有泪、有。。。\n\n牛二哥突然想到了什么，继续说道：“说到代价，我觉得有个东西是绕不过去的，那就是统计信息和选择率，PostgreSQL数据库的物理优化需要计算各种物理路径的代价，而代价估算的过程严重的依赖于数据库的统计信息，统计信息是否能准确的描述表中的数据分布情况是决定代价的准确性的重要条件之一。”\n\n小明说：“大明和我说过，数据库有很多的物理路径，这些物理路径我们也叫他们物理算子，和逻辑算子不同，物理算子是查询执行器的执行方法，我们只需要计算物理算子每个步骤的代价，汇总起来就是路径的代价了，那要统计信息有什么用呢？”\n\n牛二哥看了看大明，意思是让大明来说，不过大明正在专心的查吃了吗外卖APP，找大腰子和红酒，并没有看到牛二哥的眼神，牛二哥只好尴尬的说：“是的，我们就是要计算一个物理算子的代价，但是物理算子的计算量并不是一成不变的。”说着牛二哥从旁边的书桌上拿来纸和笔，在纸上写了两个SQL语句。\n\n```\n\tSELECT A+B FROM TEST_A WHERE A > 1;\n\tSELECT A+B FROM TEST_A WHERE A > 100000000;\n```\n\t\n然后牛二哥说：“你看，这两个语句可以用同样的物理算子来完成，但是他们的计算量一样吗？”\n\n小明心想：A > 1和A > 1000000000都是过滤条件，经过过滤之后，他们产生的数据量就不同了，这样投影中的A+B的计算的次数就不同了，所以他们的代价应该是不同的，那它和统计信息有什么关系呢？小明感觉灵光一闪，马上说：“我知道了，我在计算物理算子的代价的时候，要知道A > 1之后还剩下多少数据或者A > 1000000000之后还剩下多少数据，如果我们提前对表上的数据内容做了统计，剩下多少数据就不难计算了，所以必须要有统计信息。”\n\n牛二哥点了点头，说：“嗯，通过统计信息，代价估算系统就可以了解一个表有多少行数据、用了多少个数据页面、某个值出现的频率等等，然后就能根据这些信息计算出一个约束条件能过滤掉多少数据，这种约束条件过滤出的数据占总数据量的比例称之为‘选择率’，所谓选择率就是一个比例，它的公式是这样的。”说着牛二哥继续在纸上写了选择率的公式：\n选择率=约束条件过滤后的元组数/约束条件过滤前的总元组数\n\n“不过上面的示例有点简单了，实际应用中通常约束条件会比较多，而且比较复杂，通常我们会计算每个子约束条件的选择率，然后就可以根据AND运算符和OR运算符计算它们的综合的选择率，AND运算符和OR运算符的选择率计算是基于概率的，你看这里的概率公式。”说着，牛二哥又继续在纸上写起来。\n\n```\nP(A+B)=P(A)+P(B)-P(AB)\nP(AB)=P(A)×P(B)\n```\n\n“有了这些，我们就可以求解多种类型的约束条件的选择率了，比如。。。”牛二哥继续在纸上画起来：\n\n```\n    P(ssex IS NOT NULL OR sno > 5) \n  = P(ssex IS NOT NULL) + P(sno > 5) – P(ssex IS NOT NULL AND sno > 5)\n  = P(ssex IS NOT NULL) + P(sno > 5) – P(ssex IS NOT NULL) × P(no > 5)\n```\n\n小明觉得牛二哥的进展有点快，赶紧问：“那么统计信息是什么形式的呢？”\n\n牛二哥挠挠头，说：“这个还真是有点麻烦，我们说常用的统计信息的形式就是distinct率、NULL值率、高频值、直方图、相关系数这些，他们分别有不同的作用，比如说distinct率，你可以获知某一列有多少个独立值，这种信息对于像性别这种列就显得特别有用，NULL值率呢？在统计的过程中，NULL值是不好处理的，因此把它独立出来，形成NULL值率，这样在高频值、直方图这些里面就不用考虑NULL值的情况了，高频值属于奇异值，顾名思义，就是出现的比较多的一些列值，去掉了NULL值，再去掉高频值，剩下的值可以用来做一个等频的直方图。。。。”\n \n“呃。。。”小明感觉跟不上牛二哥的速度了，于是说：“有点快，我有点跟不上了。”\n\t\n这时大明已经点完了外卖，过来说：“别急，外卖没有那么快送到，至于统计信息嘛，主要的还是高频值、直方图和相关系数，实际上我建议还是不要纠结于统计信息有哪些形式，我们只要知道它是用来算代价的就可以了。”\n\n牛二哥对大明说：“这怎么可以，我还没有说统计信息是如何生成的呢，比如它通过了两阶段采样，然后对样本进行统计时使用的统计方法，哪些值可以作为高频值，直方图有几个桶，相关系数是怎么计算的，相关系数在计算索引扫描路径代价的时候怎么用的，而且我和你说，PostgreSQL还出了基于多列的扩展统计信息，多列统计信息分成了哪些类型，分别是什么含义，各自是怎么计算的，还有选择率是怎么结合统计信息计算的，这些我还没说呢。。。”\n\n大明说：“你快闭嘴吧，像你这样讲优化器，岂不是要出一本书。”\n\n牛二哥做痛苦状：“那好吧，统计信息我们就说到这里吧，但是它确实是代价计算的基石，小明同学，你理解了它的作用就可以了。”\n\n小明痛苦的说：“牛二哥，你说了这么多，都不告诉我答案，我感觉要学的内容好多啊。”\n\n大明笑着说：“不用这么痛苦嘛，没有啥事是一顿烧烤不能解决的，如果有，那就是两顿。”然后大明继续神秘的说：“实际上统计信息往往也不准，你想想本来就是采样的结果嘛，样本是否显著压根就不好说，而且随着应用程序对表的更新，统计信息可能更新不及时，那就更会出现偏差。更严重的是，如果我们遇到a > b这样的约束条件，使用统计信息计算选择率也很不好计算，即使算出来，也不准嘛。”\n\n牛二哥说：“是的，统计信息确实也有不准确的问题，我听说有个DBA，他家祖坟旁边出了一口泉水，他爸爸觉得是吉兆，去找风水大师看一看，风水大师掐指算一算，说：你儿子是个DBA，每次数据库性能慢就知道更新统计信息，可是统计信息太水了，都从你家祖坟冒出来了。”\n\n三个人顿时笑做一团，气氛从痛苦又恢复到了活泼，大明说：“学习查询优化器确实还是比较繁琐的，绝对不是我们通过一两次讲解就能让你变得精通的，这个学习的曲线还是比较陡峭的。”\n\n小明点了点头说：“好吧，有了两位师傅，再加上我自己天资聪慧、风流倜傥、玉树临风、高大威武、骨骼惊奇，我相信一定能将优化器搞定。”\n\n大明和牛二哥都晕倒在地上。。。\n","slug":"postgresql-optimizer-outline-6","published":1,"updated":"2020-10-03T00:35:54.000Z","_id":"ckfsy1s6g0000nw9ke9283mf0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>“咚咚咚。。。咚咚咚”门外传来了敲门声，大明去打开房门一看，进来的原来是自己的同事牛二哥，牛二哥是专门从事数据库查询优化开发的码农，也有十几年的从业经验了，大明感到非常happy，因为这两天给小明讲查询优化器干到有些吃力，今天牛二哥来了，可以帮助自己给小明来讲查询优化器了，于是和牛二哥说：“牛二同志，来了就别走了，今天大腰子加红酒管够，你来帮我个忙。”</p>\n<p>牛二哥是大腰子爱好者，听说有大腰子，顿时感觉浑身鸡血翻腾，连忙说：“没问题，不过要帮什么忙？”</p>\n<a id=\"more\"></a>\n<p>大明说：“我的弟弟小明最近在学校要进行数据库原理实践，最近总来问我优化器的问题，可我对优化器也是一知半解，这下你来了，你可以帮我弟弟讲讲优化器了。”</p>\n<p>牛二哥痛快的说：“这难不倒我，随时都可以讲。”</p>\n<p>大明说：“好嘞，我先给我的弟弟小明打个电话，和他说有优化器高手来了，赶紧过来请教。”</p>\n<p>……（此处略去近千字）</p>\n<p>小明早就听说过牛二哥的名字，据说对查询优化非常了解，没想到牛二哥竟然和自己的哥哥是同事，于是赶紧来到了大明家，看到牛二哥的洗旧的格子衫和半秃的发型，感觉就像少林寺的扫地僧一样，于是赶紧说：“我这最近正在查看基于代价的优化，感觉付出了很多代价，但收获甚微啊，期望今天能得到牛二哥的指导。”</p>\n<p>牛二哥说：“不客气，我是也是受到了大腰子和红酒的诱惑，估计今天也要付出惨痛的代价。。。。你有什么问题尽管问，我捡我会的回答。”看着小明稚嫩的脸庞，牛二哥突然想起了自己刚开始从事数据库内核开发的日子，心底翻腾起一股悲凉感，那是一段不堪回首的血泪史啊，有血、有泪、有。。。</p>\n<p>牛二哥突然想到了什么，继续说道：“说到代价，我觉得有个东西是绕不过去的，那就是统计信息和选择率，PostgreSQL数据库的物理优化需要计算各种物理路径的代价，而代价估算的过程严重的依赖于数据库的统计信息，统计信息是否能准确的描述表中的数据分布情况是决定代价的准确性的重要条件之一。”</p>\n<p>小明说：“大明和我说过，数据库有很多的物理路径，这些物理路径我们也叫他们物理算子，和逻辑算子不同，物理算子是查询执行器的执行方法，我们只需要计算物理算子每个步骤的代价，汇总起来就是路径的代价了，那要统计信息有什么用呢？”</p>\n<p>牛二哥看了看大明，意思是让大明来说，不过大明正在专心的查吃了吗外卖APP，找大腰子和红酒，并没有看到牛二哥的眼神，牛二哥只好尴尬的说：“是的，我们就是要计算一个物理算子的代价，但是物理算子的计算量并不是一成不变的。”说着牛二哥从旁边的书桌上拿来纸和笔，在纸上写了两个SQL语句。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT A+B FROM TEST_A WHERE A &gt; 1;</span><br><span class=\"line\">SELECT A+B FROM TEST_A WHERE A &gt; 100000000;</span><br></pre></td></tr></table></figure>\n\n<p>然后牛二哥说：“你看，这两个语句可以用同样的物理算子来完成，但是他们的计算量一样吗？”</p>\n<p>小明心想：A &gt; 1和A &gt; 1000000000都是过滤条件，经过过滤之后，他们产生的数据量就不同了，这样投影中的A+B的计算的次数就不同了，所以他们的代价应该是不同的，那它和统计信息有什么关系呢？小明感觉灵光一闪，马上说：“我知道了，我在计算物理算子的代价的时候，要知道A &gt; 1之后还剩下多少数据或者A &gt; 1000000000之后还剩下多少数据，如果我们提前对表上的数据内容做了统计，剩下多少数据就不难计算了，所以必须要有统计信息。”</p>\n<p>牛二哥点了点头，说：“嗯，通过统计信息，代价估算系统就可以了解一个表有多少行数据、用了多少个数据页面、某个值出现的频率等等，然后就能根据这些信息计算出一个约束条件能过滤掉多少数据，这种约束条件过滤出的数据占总数据量的比例称之为‘选择率’，所谓选择率就是一个比例，它的公式是这样的。”说着牛二哥继续在纸上写了选择率的公式：<br>选择率=约束条件过滤后的元组数/约束条件过滤前的总元组数</p>\n<p>“不过上面的示例有点简单了，实际应用中通常约束条件会比较多，而且比较复杂，通常我们会计算每个子约束条件的选择率，然后就可以根据AND运算符和OR运算符计算它们的综合的选择率，AND运算符和OR运算符的选择率计算是基于概率的，你看这里的概率公式。”说着，牛二哥又继续在纸上写起来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P(A+B)&#x3D;P(A)+P(B)-P(AB)</span><br><span class=\"line\">P(AB)&#x3D;P(A)×P(B)</span><br></pre></td></tr></table></figure>\n\n<p>“有了这些，我们就可以求解多种类型的约束条件的选择率了，比如。。。”牛二哥继续在纸上画起来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  P(ssex IS NOT NULL OR sno &gt; 5) </span><br><span class=\"line\">&#x3D; P(ssex IS NOT NULL) + P(sno &gt; 5) – P(ssex IS NOT NULL AND sno &gt; 5)</span><br><span class=\"line\">&#x3D; P(ssex IS NOT NULL) + P(sno &gt; 5) – P(ssex IS NOT NULL) × P(no &gt; 5)</span><br></pre></td></tr></table></figure>\n\n<p>小明觉得牛二哥的进展有点快，赶紧问：“那么统计信息是什么形式的呢？”</p>\n<p>牛二哥挠挠头，说：“这个还真是有点麻烦，我们说常用的统计信息的形式就是distinct率、NULL值率、高频值、直方图、相关系数这些，他们分别有不同的作用，比如说distinct率，你可以获知某一列有多少个独立值，这种信息对于像性别这种列就显得特别有用，NULL值率呢？在统计的过程中，NULL值是不好处理的，因此把它独立出来，形成NULL值率，这样在高频值、直方图这些里面就不用考虑NULL值的情况了，高频值属于奇异值，顾名思义，就是出现的比较多的一些列值，去掉了NULL值，再去掉高频值，剩下的值可以用来做一个等频的直方图。。。。”</p>\n<p>“呃。。。”小明感觉跟不上牛二哥的速度了，于是说：“有点快，我有点跟不上了。”</p>\n<p>这时大明已经点完了外卖，过来说：“别急，外卖没有那么快送到，至于统计信息嘛，主要的还是高频值、直方图和相关系数，实际上我建议还是不要纠结于统计信息有哪些形式，我们只要知道它是用来算代价的就可以了。”</p>\n<p>牛二哥对大明说：“这怎么可以，我还没有说统计信息是如何生成的呢，比如它通过了两阶段采样，然后对样本进行统计时使用的统计方法，哪些值可以作为高频值，直方图有几个桶，相关系数是怎么计算的，相关系数在计算索引扫描路径代价的时候怎么用的，而且我和你说，PostgreSQL还出了基于多列的扩展统计信息，多列统计信息分成了哪些类型，分别是什么含义，各自是怎么计算的，还有选择率是怎么结合统计信息计算的，这些我还没说呢。。。”</p>\n<p>大明说：“你快闭嘴吧，像你这样讲优化器，岂不是要出一本书。”</p>\n<p>牛二哥做痛苦状：“那好吧，统计信息我们就说到这里吧，但是它确实是代价计算的基石，小明同学，你理解了它的作用就可以了。”</p>\n<p>小明痛苦的说：“牛二哥，你说了这么多，都不告诉我答案，我感觉要学的内容好多啊。”</p>\n<p>大明笑着说：“不用这么痛苦嘛，没有啥事是一顿烧烤不能解决的，如果有，那就是两顿。”然后大明继续神秘的说：“实际上统计信息往往也不准，你想想本来就是采样的结果嘛，样本是否显著压根就不好说，而且随着应用程序对表的更新，统计信息可能更新不及时，那就更会出现偏差。更严重的是，如果我们遇到a &gt; b这样的约束条件，使用统计信息计算选择率也很不好计算，即使算出来，也不准嘛。”</p>\n<p>牛二哥说：“是的，统计信息确实也有不准确的问题，我听说有个DBA，他家祖坟旁边出了一口泉水，他爸爸觉得是吉兆，去找风水大师看一看，风水大师掐指算一算，说：你儿子是个DBA，每次数据库性能慢就知道更新统计信息，可是统计信息太水了，都从你家祖坟冒出来了。”</p>\n<p>三个人顿时笑做一团，气氛从痛苦又恢复到了活泼，大明说：“学习查询优化器确实还是比较繁琐的，绝对不是我们通过一两次讲解就能让你变得精通的，这个学习的曲线还是比较陡峭的。”</p>\n<p>小明点了点头说：“好吧，有了两位师傅，再加上我自己天资聪慧、风流倜傥、玉树临风、高大威武、骨骼惊奇，我相信一定能将优化器搞定。”</p>\n<p>大明和牛二哥都晕倒在地上。。。</p>\n","site":{"data":{}},"excerpt":"<p>“咚咚咚。。。咚咚咚”门外传来了敲门声，大明去打开房门一看，进来的原来是自己的同事牛二哥，牛二哥是专门从事数据库查询优化开发的码农，也有十几年的从业经验了，大明感到非常happy，因为这两天给小明讲查询优化器干到有些吃力，今天牛二哥来了，可以帮助自己给小明来讲查询优化器了，于是和牛二哥说：“牛二同志，来了就别走了，今天大腰子加红酒管够，你来帮我个忙。”</p>\n<p>牛二哥是大腰子爱好者，听说有大腰子，顿时感觉浑身鸡血翻腾，连忙说：“没问题，不过要帮什么忙？”</p>","more":"<p>大明说：“我的弟弟小明最近在学校要进行数据库原理实践，最近总来问我优化器的问题，可我对优化器也是一知半解，这下你来了，你可以帮我弟弟讲讲优化器了。”</p>\n<p>牛二哥痛快的说：“这难不倒我，随时都可以讲。”</p>\n<p>大明说：“好嘞，我先给我的弟弟小明打个电话，和他说有优化器高手来了，赶紧过来请教。”</p>\n<p>……（此处略去近千字）</p>\n<p>小明早就听说过牛二哥的名字，据说对查询优化非常了解，没想到牛二哥竟然和自己的哥哥是同事，于是赶紧来到了大明家，看到牛二哥的洗旧的格子衫和半秃的发型，感觉就像少林寺的扫地僧一样，于是赶紧说：“我这最近正在查看基于代价的优化，感觉付出了很多代价，但收获甚微啊，期望今天能得到牛二哥的指导。”</p>\n<p>牛二哥说：“不客气，我是也是受到了大腰子和红酒的诱惑，估计今天也要付出惨痛的代价。。。。你有什么问题尽管问，我捡我会的回答。”看着小明稚嫩的脸庞，牛二哥突然想起了自己刚开始从事数据库内核开发的日子，心底翻腾起一股悲凉感，那是一段不堪回首的血泪史啊，有血、有泪、有。。。</p>\n<p>牛二哥突然想到了什么，继续说道：“说到代价，我觉得有个东西是绕不过去的，那就是统计信息和选择率，PostgreSQL数据库的物理优化需要计算各种物理路径的代价，而代价估算的过程严重的依赖于数据库的统计信息，统计信息是否能准确的描述表中的数据分布情况是决定代价的准确性的重要条件之一。”</p>\n<p>小明说：“大明和我说过，数据库有很多的物理路径，这些物理路径我们也叫他们物理算子，和逻辑算子不同，物理算子是查询执行器的执行方法，我们只需要计算物理算子每个步骤的代价，汇总起来就是路径的代价了，那要统计信息有什么用呢？”</p>\n<p>牛二哥看了看大明，意思是让大明来说，不过大明正在专心的查吃了吗外卖APP，找大腰子和红酒，并没有看到牛二哥的眼神，牛二哥只好尴尬的说：“是的，我们就是要计算一个物理算子的代价，但是物理算子的计算量并不是一成不变的。”说着牛二哥从旁边的书桌上拿来纸和笔，在纸上写了两个SQL语句。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT A+B FROM TEST_A WHERE A &gt; 1;</span><br><span class=\"line\">SELECT A+B FROM TEST_A WHERE A &gt; 100000000;</span><br></pre></td></tr></table></figure>\n\n<p>然后牛二哥说：“你看，这两个语句可以用同样的物理算子来完成，但是他们的计算量一样吗？”</p>\n<p>小明心想：A &gt; 1和A &gt; 1000000000都是过滤条件，经过过滤之后，他们产生的数据量就不同了，这样投影中的A+B的计算的次数就不同了，所以他们的代价应该是不同的，那它和统计信息有什么关系呢？小明感觉灵光一闪，马上说：“我知道了，我在计算物理算子的代价的时候，要知道A &gt; 1之后还剩下多少数据或者A &gt; 1000000000之后还剩下多少数据，如果我们提前对表上的数据内容做了统计，剩下多少数据就不难计算了，所以必须要有统计信息。”</p>\n<p>牛二哥点了点头，说：“嗯，通过统计信息，代价估算系统就可以了解一个表有多少行数据、用了多少个数据页面、某个值出现的频率等等，然后就能根据这些信息计算出一个约束条件能过滤掉多少数据，这种约束条件过滤出的数据占总数据量的比例称之为‘选择率’，所谓选择率就是一个比例，它的公式是这样的。”说着牛二哥继续在纸上写了选择率的公式：<br>选择率=约束条件过滤后的元组数/约束条件过滤前的总元组数</p>\n<p>“不过上面的示例有点简单了，实际应用中通常约束条件会比较多，而且比较复杂，通常我们会计算每个子约束条件的选择率，然后就可以根据AND运算符和OR运算符计算它们的综合的选择率，AND运算符和OR运算符的选择率计算是基于概率的，你看这里的概率公式。”说着，牛二哥又继续在纸上写起来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P(A+B)&#x3D;P(A)+P(B)-P(AB)</span><br><span class=\"line\">P(AB)&#x3D;P(A)×P(B)</span><br></pre></td></tr></table></figure>\n\n<p>“有了这些，我们就可以求解多种类型的约束条件的选择率了，比如。。。”牛二哥继续在纸上画起来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  P(ssex IS NOT NULL OR sno &gt; 5) </span><br><span class=\"line\">&#x3D; P(ssex IS NOT NULL) + P(sno &gt; 5) – P(ssex IS NOT NULL AND sno &gt; 5)</span><br><span class=\"line\">&#x3D; P(ssex IS NOT NULL) + P(sno &gt; 5) – P(ssex IS NOT NULL) × P(no &gt; 5)</span><br></pre></td></tr></table></figure>\n\n<p>小明觉得牛二哥的进展有点快，赶紧问：“那么统计信息是什么形式的呢？”</p>\n<p>牛二哥挠挠头，说：“这个还真是有点麻烦，我们说常用的统计信息的形式就是distinct率、NULL值率、高频值、直方图、相关系数这些，他们分别有不同的作用，比如说distinct率，你可以获知某一列有多少个独立值，这种信息对于像性别这种列就显得特别有用，NULL值率呢？在统计的过程中，NULL值是不好处理的，因此把它独立出来，形成NULL值率，这样在高频值、直方图这些里面就不用考虑NULL值的情况了，高频值属于奇异值，顾名思义，就是出现的比较多的一些列值，去掉了NULL值，再去掉高频值，剩下的值可以用来做一个等频的直方图。。。。”</p>\n<p>“呃。。。”小明感觉跟不上牛二哥的速度了，于是说：“有点快，我有点跟不上了。”</p>\n<p>这时大明已经点完了外卖，过来说：“别急，外卖没有那么快送到，至于统计信息嘛，主要的还是高频值、直方图和相关系数，实际上我建议还是不要纠结于统计信息有哪些形式，我们只要知道它是用来算代价的就可以了。”</p>\n<p>牛二哥对大明说：“这怎么可以，我还没有说统计信息是如何生成的呢，比如它通过了两阶段采样，然后对样本进行统计时使用的统计方法，哪些值可以作为高频值，直方图有几个桶，相关系数是怎么计算的，相关系数在计算索引扫描路径代价的时候怎么用的，而且我和你说，PostgreSQL还出了基于多列的扩展统计信息，多列统计信息分成了哪些类型，分别是什么含义，各自是怎么计算的，还有选择率是怎么结合统计信息计算的，这些我还没说呢。。。”</p>\n<p>大明说：“你快闭嘴吧，像你这样讲优化器，岂不是要出一本书。”</p>\n<p>牛二哥做痛苦状：“那好吧，统计信息我们就说到这里吧，但是它确实是代价计算的基石，小明同学，你理解了它的作用就可以了。”</p>\n<p>小明痛苦的说：“牛二哥，你说了这么多，都不告诉我答案，我感觉要学的内容好多啊。”</p>\n<p>大明笑着说：“不用这么痛苦嘛，没有啥事是一顿烧烤不能解决的，如果有，那就是两顿。”然后大明继续神秘的说：“实际上统计信息往往也不准，你想想本来就是采样的结果嘛，样本是否显著压根就不好说，而且随着应用程序对表的更新，统计信息可能更新不及时，那就更会出现偏差。更严重的是，如果我们遇到a &gt; b这样的约束条件，使用统计信息计算选择率也很不好计算，即使算出来，也不准嘛。”</p>\n<p>牛二哥说：“是的，统计信息确实也有不准确的问题，我听说有个DBA，他家祖坟旁边出了一口泉水，他爸爸觉得是吉兆，去找风水大师看一看，风水大师掐指算一算，说：你儿子是个DBA，每次数据库性能慢就知道更新统计信息，可是统计信息太水了，都从你家祖坟冒出来了。”</p>\n<p>三个人顿时笑做一团，气氛从痛苦又恢复到了活泼，大明说：“学习查询优化器确实还是比较繁琐的，绝对不是我们通过一两次讲解就能让你变得精通的，这个学习的曲线还是比较陡峭的。”</p>\n<p>小明点了点头说：“好吧，有了两位师傅，再加上我自己天资聪慧、风流倜傥、玉树临风、高大威武、骨骼惊奇，我相信一定能将优化器搞定。”</p>\n<p>大明和牛二哥都晕倒在地上。。。</p>"},{"title":"PostgreSQL优化器白话(7) - 你走你的阳关道","date":"2020-10-03T00:36:07.000Z","_content":"\n小明“摇醒”了晕倒的大明和牛二哥，然后说：“趁着大腰子和红酒还没送到，不如给我说说物理路径吧，虽然我们代价计算来计算去，最终还是为物理路径计算代价嘛。”\n\n大明愤怒的说：“讲物理路径可以，不过你如果再这么吹嘘自己，咱俩就势不两立，你走你的阳关道，我过我的独木桥。”\n\n牛二哥笑着说：“我看还是先算算走阳关道合算还是走独木桥合算吧，同样一件事，既可以走阳关道，也可以走独木桥，所谓殊途同归于尽嘛，不过我们还是得知道哪一个适合自己。”<!-- more -->\n\n小明说：“大明和我说过这些阳关道和独木桥，它大体上分成扫描路径和连接路径，我查过一些查询优化器的说明，我知道扫描路径有顺序扫描路径、索引扫描路径、位图扫描路径等等，而连接路径通常有嵌套循环连接路径、哈希连接路径、归并连接路径，另外还有一些其他的路径，比如排序路径、物化路径等等。”\n\n牛二哥说：“是的，我们就来说说这些路径的含义吧。如果要获得一个表中的数据，最基础的方法就是将表中的所有的数据都遍历一遍，从中挑选出符合条件的数据，这种方式就是顺序扫描路径，顺序扫描路径的优点是其具有广泛的适用性，各种表都可以用这种方法，它缺点自然是代价通常比较高，因为要把所有的数据都遍历一遍。”大明趁着牛二哥说顺序扫描路径的时候，在纸上画了个图，说：“这个图大概就是顺序扫描路径。”\n\n![](./postgresql-optimizer-outline-7/1.jpg) \n\n牛二哥则继续说：“如果将数据做一些预处理，比如建立一个索引，如果要想获得一个表的数据，可以通过扫描索引获得所需数据的“地址”，然后通过地址将需要的数据获取出来，尤其是在选择操作带有约束条件的情况下，在索引和约束条件共同的作用下，表中的有些数据就不用再遍历了，因为通过索引就很容易知道这些数据是不符合约束条件的，更有甚者，因为索引上也保存了数据，它的数据和关系中的数据是一致的，因此如果索引上的数据就能满足要求，就只需要扫描索引就可以获得所需的数据了，也就是说在扫描路径中还可以有索引扫描路径和快速索引扫描路径两种方式。”\n\n大明则继续为牛二哥“捧哏”，在纸上画上了索引扫描和快速索引扫描的图。\n\n![](./postgresql-optimizer-outline-7/2.png) \n \n小明看到大明特意在图里写上了“随机读”三个字，于是问道：“我看这个索引扫描有随机读的问题，这个问题能否把它解决掉呢？也就是说即利用了索引，还避免了随机读的问题，有这样的办法吗？”\n\n牛二哥说：“索引扫描路径确实带来随机读的问题，因为索引中记录的是数据元组的地址，索引扫描是通过扫描索引获得元组地址，然后通过元组地址访问数据，索引中保存的“有序”的地址，到数据中就可能是随机的了，位图扫描就能解决这个问题，它通过位图将地址保存起来，把地址收集起来之后，然后让地址变得有序，这样就通过中间的位图把随机读消解掉了。”大明则继续在纸上画上了位图扫描的示意图。\n\n![](./postgresql-optimizer-outline-7/3.png) \n \n不过大明不甘心一直“站在桌子里面”，也想“站到桌子外面”承担一下“逗哏”的角色，于是说道：“扫描的过程中还会结合一些特殊的情况有一些非常高效的扫描路径，比如TID扫描路径，TID实际上是元组在磁盘上的存储地址，我们能够根据TID直接就获得元组，这样查询的效率就非常高了。”\n\n牛二哥点了点头继续说到：“扫描路径通常是执行计划中的叶子结点，也就是在最底层对表进行扫描的结点，扫描路径就是为连接路径做准备的，扫描出来的数据就可以给连接路径来实现连接操作了。”\n\n大明一边在纸上画一边说道：“要对两个关系做连接，受笛卡尔积的启发，可以用一个算法复杂度是O(mn)的方法来实现，我们叫它Nestlooped Join方法，这种方法虽然复杂度比较高，但是和顺序扫描一样，胜在具有普适性。”\n\n牛二哥说：“嵌套循环连接这种方法的复杂度比较高，看上去没什么意义，但是如果Nestlooped Join的内表的路径是一个索引扫描路径，那么算法的复杂度就会降下来，索引扫描的算法复杂度是O(logn)，因此如果Nestlooped Join的内表是一个索引扫描，它的整体的算法复杂度就变成了O(mlogn)，看上去这样也是可以接受的。”\n\n![](./postgresql-optimizer-outline-7/4.png) \n\n小明点了点头说：“嗯，索引实际上是对数据做了一些预处理，我想如果哈希连接方法就是将内表做一个哈希表，这样也等于将内表的数据做了预处理，也能方便外表的元组在里面探测吧？”\n\n牛二哥点了点头说：“假设Hash表有N个桶，内表数据均匀的分布在各个桶中，那么Hash Join的时间复杂度就是O(m * n /N)，当然，这里我们没有考虑上建立Hash表的代价。”\n\n大明则在纸上画出了Hash连接的示意图，并且补充道：“Hash连接通常只能用来做等值判断。”\n\n![](./postgresql-optimizer-outline-7/5.png) \n \n牛二哥继续说：“如果将两个表先排序，那么就可以引入第三种连接方式，Merge Join，这种连接方式的代价主要浪费在排序上，如果两个关系的数据量都比较小，那么排序的代价是可控的，MergeJoin就是适用的，另外如果关系上有有序的索引，那么就可以不用单独排序了，这样也比较适用于MergeJoin。你看我画的这个归并连接的示意图，外表是需要排序的，而内表则借用了原有的索引的顺序，消除了排序的时间，降低了物理路径的代价。”\n\n![](./postgresql-optimizer-outline-7/6.png) \n \n“这些路径属于SPJ路径，在PostgreSQL的优化器中，通常会先生成SPJ的路径，然后在这基础上再叠加Non-SPJ的路径，比如说聚集操作、排序操作、limit操作、分组操作。。。。”牛二哥继续补充道。\n\n“咚咚咚，咚咚咚”敲门声响了，吃了吗外卖东来了三个人最爱的大腰子，吃大腰子的感觉完全停不下来，至于优化器。。。先让它见鬼去吧。\n","source":"_posts/postgresql-optimizer-outline-7.md","raw":"---\ntitle: PostgreSQL优化器白话(7) - 你走你的阳关道\ndate: 2020-10-03 08:36:07\ntags: 路径 Path 顺序扫描 索引扫描 位图扫描 Join\n---\n\n小明“摇醒”了晕倒的大明和牛二哥，然后说：“趁着大腰子和红酒还没送到，不如给我说说物理路径吧，虽然我们代价计算来计算去，最终还是为物理路径计算代价嘛。”\n\n大明愤怒的说：“讲物理路径可以，不过你如果再这么吹嘘自己，咱俩就势不两立，你走你的阳关道，我过我的独木桥。”\n\n牛二哥笑着说：“我看还是先算算走阳关道合算还是走独木桥合算吧，同样一件事，既可以走阳关道，也可以走独木桥，所谓殊途同归于尽嘛，不过我们还是得知道哪一个适合自己。”<!-- more -->\n\n小明说：“大明和我说过这些阳关道和独木桥，它大体上分成扫描路径和连接路径，我查过一些查询优化器的说明，我知道扫描路径有顺序扫描路径、索引扫描路径、位图扫描路径等等，而连接路径通常有嵌套循环连接路径、哈希连接路径、归并连接路径，另外还有一些其他的路径，比如排序路径、物化路径等等。”\n\n牛二哥说：“是的，我们就来说说这些路径的含义吧。如果要获得一个表中的数据，最基础的方法就是将表中的所有的数据都遍历一遍，从中挑选出符合条件的数据，这种方式就是顺序扫描路径，顺序扫描路径的优点是其具有广泛的适用性，各种表都可以用这种方法，它缺点自然是代价通常比较高，因为要把所有的数据都遍历一遍。”大明趁着牛二哥说顺序扫描路径的时候，在纸上画了个图，说：“这个图大概就是顺序扫描路径。”\n\n![](./postgresql-optimizer-outline-7/1.jpg) \n\n牛二哥则继续说：“如果将数据做一些预处理，比如建立一个索引，如果要想获得一个表的数据，可以通过扫描索引获得所需数据的“地址”，然后通过地址将需要的数据获取出来，尤其是在选择操作带有约束条件的情况下，在索引和约束条件共同的作用下，表中的有些数据就不用再遍历了，因为通过索引就很容易知道这些数据是不符合约束条件的，更有甚者，因为索引上也保存了数据，它的数据和关系中的数据是一致的，因此如果索引上的数据就能满足要求，就只需要扫描索引就可以获得所需的数据了，也就是说在扫描路径中还可以有索引扫描路径和快速索引扫描路径两种方式。”\n\n大明则继续为牛二哥“捧哏”，在纸上画上了索引扫描和快速索引扫描的图。\n\n![](./postgresql-optimizer-outline-7/2.png) \n \n小明看到大明特意在图里写上了“随机读”三个字，于是问道：“我看这个索引扫描有随机读的问题，这个问题能否把它解决掉呢？也就是说即利用了索引，还避免了随机读的问题，有这样的办法吗？”\n\n牛二哥说：“索引扫描路径确实带来随机读的问题，因为索引中记录的是数据元组的地址，索引扫描是通过扫描索引获得元组地址，然后通过元组地址访问数据，索引中保存的“有序”的地址，到数据中就可能是随机的了，位图扫描就能解决这个问题，它通过位图将地址保存起来，把地址收集起来之后，然后让地址变得有序，这样就通过中间的位图把随机读消解掉了。”大明则继续在纸上画上了位图扫描的示意图。\n\n![](./postgresql-optimizer-outline-7/3.png) \n \n不过大明不甘心一直“站在桌子里面”，也想“站到桌子外面”承担一下“逗哏”的角色，于是说道：“扫描的过程中还会结合一些特殊的情况有一些非常高效的扫描路径，比如TID扫描路径，TID实际上是元组在磁盘上的存储地址，我们能够根据TID直接就获得元组，这样查询的效率就非常高了。”\n\n牛二哥点了点头继续说到：“扫描路径通常是执行计划中的叶子结点，也就是在最底层对表进行扫描的结点，扫描路径就是为连接路径做准备的，扫描出来的数据就可以给连接路径来实现连接操作了。”\n\n大明一边在纸上画一边说道：“要对两个关系做连接，受笛卡尔积的启发，可以用一个算法复杂度是O(mn)的方法来实现，我们叫它Nestlooped Join方法，这种方法虽然复杂度比较高，但是和顺序扫描一样，胜在具有普适性。”\n\n牛二哥说：“嵌套循环连接这种方法的复杂度比较高，看上去没什么意义，但是如果Nestlooped Join的内表的路径是一个索引扫描路径，那么算法的复杂度就会降下来，索引扫描的算法复杂度是O(logn)，因此如果Nestlooped Join的内表是一个索引扫描，它的整体的算法复杂度就变成了O(mlogn)，看上去这样也是可以接受的。”\n\n![](./postgresql-optimizer-outline-7/4.png) \n\n小明点了点头说：“嗯，索引实际上是对数据做了一些预处理，我想如果哈希连接方法就是将内表做一个哈希表，这样也等于将内表的数据做了预处理，也能方便外表的元组在里面探测吧？”\n\n牛二哥点了点头说：“假设Hash表有N个桶，内表数据均匀的分布在各个桶中，那么Hash Join的时间复杂度就是O(m * n /N)，当然，这里我们没有考虑上建立Hash表的代价。”\n\n大明则在纸上画出了Hash连接的示意图，并且补充道：“Hash连接通常只能用来做等值判断。”\n\n![](./postgresql-optimizer-outline-7/5.png) \n \n牛二哥继续说：“如果将两个表先排序，那么就可以引入第三种连接方式，Merge Join，这种连接方式的代价主要浪费在排序上，如果两个关系的数据量都比较小，那么排序的代价是可控的，MergeJoin就是适用的，另外如果关系上有有序的索引，那么就可以不用单独排序了，这样也比较适用于MergeJoin。你看我画的这个归并连接的示意图，外表是需要排序的，而内表则借用了原有的索引的顺序，消除了排序的时间，降低了物理路径的代价。”\n\n![](./postgresql-optimizer-outline-7/6.png) \n \n“这些路径属于SPJ路径，在PostgreSQL的优化器中，通常会先生成SPJ的路径，然后在这基础上再叠加Non-SPJ的路径，比如说聚集操作、排序操作、limit操作、分组操作。。。。”牛二哥继续补充道。\n\n“咚咚咚，咚咚咚”敲门声响了，吃了吗外卖东来了三个人最爱的大腰子，吃大腰子的感觉完全停不下来，至于优化器。。。先让它见鬼去吧。\n","slug":"postgresql-optimizer-outline-7","published":1,"updated":"2020-10-03T01:12:47.000Z","_id":"ckfszbzyj0000ro9kgeuy15hy","comments":1,"layout":"post","photos":[],"link":"","content":"<p>小明“摇醒”了晕倒的大明和牛二哥，然后说：“趁着大腰子和红酒还没送到，不如给我说说物理路径吧，虽然我们代价计算来计算去，最终还是为物理路径计算代价嘛。”</p>\n<p>大明愤怒的说：“讲物理路径可以，不过你如果再这么吹嘘自己，咱俩就势不两立，你走你的阳关道，我过我的独木桥。”</p>\n<p>牛二哥笑着说：“我看还是先算算走阳关道合算还是走独木桥合算吧，同样一件事，既可以走阳关道，也可以走独木桥，所谓殊途同归于尽嘛，不过我们还是得知道哪一个适合自己。”<a id=\"more\"></a></p>\n<p>小明说：“大明和我说过这些阳关道和独木桥，它大体上分成扫描路径和连接路径，我查过一些查询优化器的说明，我知道扫描路径有顺序扫描路径、索引扫描路径、位图扫描路径等等，而连接路径通常有嵌套循环连接路径、哈希连接路径、归并连接路径，另外还有一些其他的路径，比如排序路径、物化路径等等。”</p>\n<p>牛二哥说：“是的，我们就来说说这些路径的含义吧。如果要获得一个表中的数据，最基础的方法就是将表中的所有的数据都遍历一遍，从中挑选出符合条件的数据，这种方式就是顺序扫描路径，顺序扫描路径的优点是其具有广泛的适用性，各种表都可以用这种方法，它缺点自然是代价通常比较高，因为要把所有的数据都遍历一遍。”大明趁着牛二哥说顺序扫描路径的时候，在纸上画了个图，说：“这个图大概就是顺序扫描路径。”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/1.jpg\"> </p>\n<p>牛二哥则继续说：“如果将数据做一些预处理，比如建立一个索引，如果要想获得一个表的数据，可以通过扫描索引获得所需数据的“地址”，然后通过地址将需要的数据获取出来，尤其是在选择操作带有约束条件的情况下，在索引和约束条件共同的作用下，表中的有些数据就不用再遍历了，因为通过索引就很容易知道这些数据是不符合约束条件的，更有甚者，因为索引上也保存了数据，它的数据和关系中的数据是一致的，因此如果索引上的数据就能满足要求，就只需要扫描索引就可以获得所需的数据了，也就是说在扫描路径中还可以有索引扫描路径和快速索引扫描路径两种方式。”</p>\n<p>大明则继续为牛二哥“捧哏”，在纸上画上了索引扫描和快速索引扫描的图。</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/2.png\"> </p>\n<p>小明看到大明特意在图里写上了“随机读”三个字，于是问道：“我看这个索引扫描有随机读的问题，这个问题能否把它解决掉呢？也就是说即利用了索引，还避免了随机读的问题，有这样的办法吗？”</p>\n<p>牛二哥说：“索引扫描路径确实带来随机读的问题，因为索引中记录的是数据元组的地址，索引扫描是通过扫描索引获得元组地址，然后通过元组地址访问数据，索引中保存的“有序”的地址，到数据中就可能是随机的了，位图扫描就能解决这个问题，它通过位图将地址保存起来，把地址收集起来之后，然后让地址变得有序，这样就通过中间的位图把随机读消解掉了。”大明则继续在纸上画上了位图扫描的示意图。</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/3.png\"> </p>\n<p>不过大明不甘心一直“站在桌子里面”，也想“站到桌子外面”承担一下“逗哏”的角色，于是说道：“扫描的过程中还会结合一些特殊的情况有一些非常高效的扫描路径，比如TID扫描路径，TID实际上是元组在磁盘上的存储地址，我们能够根据TID直接就获得元组，这样查询的效率就非常高了。”</p>\n<p>牛二哥点了点头继续说到：“扫描路径通常是执行计划中的叶子结点，也就是在最底层对表进行扫描的结点，扫描路径就是为连接路径做准备的，扫描出来的数据就可以给连接路径来实现连接操作了。”</p>\n<p>大明一边在纸上画一边说道：“要对两个关系做连接，受笛卡尔积的启发，可以用一个算法复杂度是O(mn)的方法来实现，我们叫它Nestlooped Join方法，这种方法虽然复杂度比较高，但是和顺序扫描一样，胜在具有普适性。”</p>\n<p>牛二哥说：“嵌套循环连接这种方法的复杂度比较高，看上去没什么意义，但是如果Nestlooped Join的内表的路径是一个索引扫描路径，那么算法的复杂度就会降下来，索引扫描的算法复杂度是O(logn)，因此如果Nestlooped Join的内表是一个索引扫描，它的整体的算法复杂度就变成了O(mlogn)，看上去这样也是可以接受的。”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/4.png\"> </p>\n<p>小明点了点头说：“嗯，索引实际上是对数据做了一些预处理，我想如果哈希连接方法就是将内表做一个哈希表，这样也等于将内表的数据做了预处理，也能方便外表的元组在里面探测吧？”</p>\n<p>牛二哥点了点头说：“假设Hash表有N个桶，内表数据均匀的分布在各个桶中，那么Hash Join的时间复杂度就是O(m * n /N)，当然，这里我们没有考虑上建立Hash表的代价。”</p>\n<p>大明则在纸上画出了Hash连接的示意图，并且补充道：“Hash连接通常只能用来做等值判断。”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/5.png\"> </p>\n<p>牛二哥继续说：“如果将两个表先排序，那么就可以引入第三种连接方式，Merge Join，这种连接方式的代价主要浪费在排序上，如果两个关系的数据量都比较小，那么排序的代价是可控的，MergeJoin就是适用的，另外如果关系上有有序的索引，那么就可以不用单独排序了，这样也比较适用于MergeJoin。你看我画的这个归并连接的示意图，外表是需要排序的，而内表则借用了原有的索引的顺序，消除了排序的时间，降低了物理路径的代价。”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/6.png\"> </p>\n<p>“这些路径属于SPJ路径，在PostgreSQL的优化器中，通常会先生成SPJ的路径，然后在这基础上再叠加Non-SPJ的路径，比如说聚集操作、排序操作、limit操作、分组操作。。。。”牛二哥继续补充道。</p>\n<p>“咚咚咚，咚咚咚”敲门声响了，吃了吗外卖东来了三个人最爱的大腰子，吃大腰子的感觉完全停不下来，至于优化器。。。先让它见鬼去吧。</p>\n","site":{"data":{}},"excerpt":"<p>小明“摇醒”了晕倒的大明和牛二哥，然后说：“趁着大腰子和红酒还没送到，不如给我说说物理路径吧，虽然我们代价计算来计算去，最终还是为物理路径计算代价嘛。”</p>\n<p>大明愤怒的说：“讲物理路径可以，不过你如果再这么吹嘘自己，咱俩就势不两立，你走你的阳关道，我过我的独木桥。”</p>\n<p>牛二哥笑着说：“我看还是先算算走阳关道合算还是走独木桥合算吧，同样一件事，既可以走阳关道，也可以走独木桥，所谓殊途同归于尽嘛，不过我们还是得知道哪一个适合自己。”</p>","more":"<p></p>\n<p>小明说：“大明和我说过这些阳关道和独木桥，它大体上分成扫描路径和连接路径，我查过一些查询优化器的说明，我知道扫描路径有顺序扫描路径、索引扫描路径、位图扫描路径等等，而连接路径通常有嵌套循环连接路径、哈希连接路径、归并连接路径，另外还有一些其他的路径，比如排序路径、物化路径等等。”</p>\n<p>牛二哥说：“是的，我们就来说说这些路径的含义吧。如果要获得一个表中的数据，最基础的方法就是将表中的所有的数据都遍历一遍，从中挑选出符合条件的数据，这种方式就是顺序扫描路径，顺序扫描路径的优点是其具有广泛的适用性，各种表都可以用这种方法，它缺点自然是代价通常比较高，因为要把所有的数据都遍历一遍。”大明趁着牛二哥说顺序扫描路径的时候，在纸上画了个图，说：“这个图大概就是顺序扫描路径。”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/1.jpg\"> </p>\n<p>牛二哥则继续说：“如果将数据做一些预处理，比如建立一个索引，如果要想获得一个表的数据，可以通过扫描索引获得所需数据的“地址”，然后通过地址将需要的数据获取出来，尤其是在选择操作带有约束条件的情况下，在索引和约束条件共同的作用下，表中的有些数据就不用再遍历了，因为通过索引就很容易知道这些数据是不符合约束条件的，更有甚者，因为索引上也保存了数据，它的数据和关系中的数据是一致的，因此如果索引上的数据就能满足要求，就只需要扫描索引就可以获得所需的数据了，也就是说在扫描路径中还可以有索引扫描路径和快速索引扫描路径两种方式。”</p>\n<p>大明则继续为牛二哥“捧哏”，在纸上画上了索引扫描和快速索引扫描的图。</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/2.png\"> </p>\n<p>小明看到大明特意在图里写上了“随机读”三个字，于是问道：“我看这个索引扫描有随机读的问题，这个问题能否把它解决掉呢？也就是说即利用了索引，还避免了随机读的问题，有这样的办法吗？”</p>\n<p>牛二哥说：“索引扫描路径确实带来随机读的问题，因为索引中记录的是数据元组的地址，索引扫描是通过扫描索引获得元组地址，然后通过元组地址访问数据，索引中保存的“有序”的地址，到数据中就可能是随机的了，位图扫描就能解决这个问题，它通过位图将地址保存起来，把地址收集起来之后，然后让地址变得有序，这样就通过中间的位图把随机读消解掉了。”大明则继续在纸上画上了位图扫描的示意图。</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/3.png\"> </p>\n<p>不过大明不甘心一直“站在桌子里面”，也想“站到桌子外面”承担一下“逗哏”的角色，于是说道：“扫描的过程中还会结合一些特殊的情况有一些非常高效的扫描路径，比如TID扫描路径，TID实际上是元组在磁盘上的存储地址，我们能够根据TID直接就获得元组，这样查询的效率就非常高了。”</p>\n<p>牛二哥点了点头继续说到：“扫描路径通常是执行计划中的叶子结点，也就是在最底层对表进行扫描的结点，扫描路径就是为连接路径做准备的，扫描出来的数据就可以给连接路径来实现连接操作了。”</p>\n<p>大明一边在纸上画一边说道：“要对两个关系做连接，受笛卡尔积的启发，可以用一个算法复杂度是O(mn)的方法来实现，我们叫它Nestlooped Join方法，这种方法虽然复杂度比较高，但是和顺序扫描一样，胜在具有普适性。”</p>\n<p>牛二哥说：“嵌套循环连接这种方法的复杂度比较高，看上去没什么意义，但是如果Nestlooped Join的内表的路径是一个索引扫描路径，那么算法的复杂度就会降下来，索引扫描的算法复杂度是O(logn)，因此如果Nestlooped Join的内表是一个索引扫描，它的整体的算法复杂度就变成了O(mlogn)，看上去这样也是可以接受的。”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/4.png\"> </p>\n<p>小明点了点头说：“嗯，索引实际上是对数据做了一些预处理，我想如果哈希连接方法就是将内表做一个哈希表，这样也等于将内表的数据做了预处理，也能方便外表的元组在里面探测吧？”</p>\n<p>牛二哥点了点头说：“假设Hash表有N个桶，内表数据均匀的分布在各个桶中，那么Hash Join的时间复杂度就是O(m * n /N)，当然，这里我们没有考虑上建立Hash表的代价。”</p>\n<p>大明则在纸上画出了Hash连接的示意图，并且补充道：“Hash连接通常只能用来做等值判断。”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/5.png\"> </p>\n<p>牛二哥继续说：“如果将两个表先排序，那么就可以引入第三种连接方式，Merge Join，这种连接方式的代价主要浪费在排序上，如果两个关系的数据量都比较小，那么排序的代价是可控的，MergeJoin就是适用的，另外如果关系上有有序的索引，那么就可以不用单独排序了，这样也比较适用于MergeJoin。你看我画的这个归并连接的示意图，外表是需要排序的，而内表则借用了原有的索引的顺序，消除了排序的时间，降低了物理路径的代价。”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/6.png\"> </p>\n<p>“这些路径属于SPJ路径，在PostgreSQL的优化器中，通常会先生成SPJ的路径，然后在这基础上再叠加Non-SPJ的路径，比如说聚集操作、排序操作、limit操作、分组操作。。。。”牛二哥继续补充道。</p>\n<p>“咚咚咚，咚咚咚”敲门声响了，吃了吗外卖东来了三个人最爱的大腰子，吃大腰子的感觉完全停不下来，至于优化器。。。先让它见鬼去吧。</p>"},{"title":"PostgreSQL优化器白话(8) - 算计不到就受穷","date":"2020-10-03T00:55:42.000Z","_content":"\n“俗话说啊，吃不穷，穿不穷，算计不到就受穷。”大明一边啃着大腰子，一边说：“所以该吃就得吃，吃是吃不穷的。”\n\t\n小明说：“可是算来算去，物理路径的代价还是有选不准的时候啊。”\n\n牛二哥说：“小明你已经走火入魔了，我们正在美美的吃饭，你看大明啃得竹签子都冒火星子，你非要扯到优化器，太扫兴了，好了，我吃饱了，我来和你聊聊。”说着牛二哥抽了张纸巾擦了擦嘴，纸巾被嘴角的油浸成透明状，飘悠悠的被牛二哥弹进了垃圾筐，然后牛二哥抚摸着自己沟满壕平的肚子，慢条斯理的说：“最优路径选的不准是谁的原因，那就是代价模型不行啊，代价模型不行赖谁，那就是程序员没建好啊，所以要怪就要怪到程序员自己头上。”\n<!-- more -->\n\n小明问道：“可是我看PostgreSQL数据库的代价计算已经很复杂了啊？”\n\n“可是数据库的周边环境更复杂啊。你想想，在实际应用中，数据库用户的配置硬件环境千差万别，CPU的频率、主存的大小和磁盘介质的性质都会影响执行计划在实际执行时的效率。”牛二哥说完，喝了一口红酒。\n\n大明接过来继续说道；“虽然在代价估算的过程中，我们无法获得‘绝对真实’的代价，但是‘绝对真实’的代价也是不必要的，因为我们只是想从多个路径（Path）中找到一个代价最小的路径，只要这些路径的代价是可以‘相互比较’的就可以了，因此可以设定一个‘相对’的代价的单位1，同一个查询中所有的物理路径都基于这个“相对”的单位1来计算的代价，这样计算出来的代价就是可以比较的，也就能用来对路径进行挑选了。”\n\n然后大明给牛二哥递了根中华烟，说：“饭后一根烟，赛过活神仙，来，抽一根。”牛二哥接过烟，大明把火递了过来，牛二哥点上了烟，把打火机扔到茶几上，然后深吸了一口，喷云吐雾的说：“PostgreSQL数据库采用顺序读写一个页面的IO代价作为单位1，而把随机IO定位了顺序IO的4倍”\n\n小明说：“我知道，我知道，这个我查过相关的书，首先，目前的存储介质很大部分仍然是机械硬盘，机械硬盘的磁头在获得数据库的时候需要付出寻道时间，如果要读写的是一串在磁盘上连续的数据，就可以节省寻道时间，提高IO性能，而如果随机读写磁盘上任意扇区的数据，那么会有大量的时间浪费在寻道上。其次，大部分磁盘本身带有缓存，这就形成了主存->磁盘缓存->磁盘的三级结构，在将磁盘的内容加载到内存的时候，考虑到磁盘的IO性能，磁盘会进行数据的预读，把预读到的数据保存在磁盘的缓存中，也就是说如果用户只打算从磁盘读取100个字节的数据，那么磁盘可能会连续的读取磁盘中的512字节（不同的磁盘预读的数量可能不同）并将其保存到磁盘缓存，如果下一次是顺序读取100个字节之后的内容，那么预读的512字节的数据就会发挥作用，性能会大大的增加，而如果读取的内容超出了512字节的范围，那么预读的数据就没有发挥作用，磁盘的IO性能就会下降。”说完小明得意的说：“怎么样，我说的对吧？”\n\n牛二哥说：“你说的对，目前PostgreSQL的查询优化大量的考虑了随机IO和顺序IO所带来的性能差别，在这方面做了不少优化，但是现在的磁盘技术越来越发达了，以后随机IO和顺序IO是不是还差这么多，就值得商榷了。”\n\n“那到底还有那些代价基准单位呢？”小明继续问道。\n\n大明回答道：“基于磁盘IO的代价单位当然就是和Page有关的了，也就是说我们刚才说的顺序IO和随机IO都属于IO方面的基准代价。让后让牛二哥给你介绍一下CPU方面的代价基准单位，我先去吃个鸡。”\n\n牛二哥说：“CPU方面的基准单位有哪些呢？比如说我们通过IO把磁盘页面读到了缓存，但我们要处理的是元组啊，所以还需要把元组从页面里解出来，还要处理元组，这部分主要消耗的是CPU，所以会有一个元组处理的代价基准单位，另外，我们在投影、约束条件里有大量的表达式，这些表达式求解也主要消耗CPU资源，所以还有一个表达式代价的基准单位。”\n\n牛二哥弹了弹烟灰，继续说道：“现在PostgreSQL数据库增加了很多并行路径，因此它也产生了通信代价，这个也需要计算的。”\n\n小明听了之后，说：“那我们就能得到一个这样的公式。”说着在纸上写了一个公式：\n```\n\t\t总代价 = CPU代价 + IO代价 + 通信代价\n```\n\n然后小明继续说：“可是我通过EXPLAIN还查看过PostgreSQL的执行计划，我从执行计划中还看到有启动代价和总代价，这是怎么回事呢？”\n\n牛二哥听了之后，想了想，在纸上写了一个公式：\n\n```\n\t\t总代价 = 启动代价 + 执行代价\n```\n\n然后牛二哥说：“这是从另一个角度来计算代价，启动代价是指从语句开始执行到查询引擎返回第一条元组的代价（另一种说法是准备好去获得第一条元组的代价），总代价是SQL语句从开始执行到结束的所有代价。”\n\t\n“可是。。。为什么要区分启动代价和执行代价呢？”\n\n“这个嘛。。。。”牛二哥思考了一下，觉得一句两句不容易说清楚，于是写了个例子：\n\n```\n\tSELECT * FROM TEST_A WHERE a > 1 ORDER BY a LIMIT 1;\n```\n\n“我们假设这个在TEST_A(a)上有一个B树索引，晓得不，那这个语句可能会形成什么样的执行计划呢？”\n\n小明想了想，觉得空想可能有点困难，于是在纸上画了一起，最终他画了两个执行路径：\n\n```\n\t执行路径1：LIMIT 1\n       \t\t\t\t-> SORT(a)\n                       -> SeqScan WHERE A > 1;\n\t执行路径2：LIMIT 1\n\t\t\t\t\t-> IndexScan WHERE A > 1; \n\t\t\t\t\t（小明注：B树索引有序，不用再排序了）\n```\n\n小明说：“我觉得这两个都可以，不过我觉得第二个更好，因为它节省了排序的时间。”\n\n牛二哥问：“你知道的，PostgreSQL数据库采用动态规划的方法来实现路径的搜索，它是一种自底向上的方法，也就是说会先建立筛选扫描路径，然后用筛选后的扫描路径再去形成连接路径，那么在我们筛选扫描路径的时候，是不知道它的上层有没有LIMIT的，这时候如果单独看SeqScan + SORT和IndexScan你觉得哪个好呢？”\n\n“嗯，我知道陷阱在哪里，大明和我说过，A > 1的选择率高的话会选择顺序扫描，而A > 1的选择率低的情况下，会选择索引扫描，这是因为索引扫描会产生随机IO，也就是说在选择率高的情况下，有可能SeqScan + SORT会优于IndexScan，虽然SeqScan + SORT会有排序，但是IndexScan的随机IO实在是太可观了。”\n\n牛二哥点了点头，说：“对的，假设选择率比较高，这时候选择了SeqScan + SORT，是因为它不知道再上层是LIMIT 1，如果上面是LIMIT 1，就会导致索引扫描不用全部扫完，只要扫一丢丢就可以了，这时候随机IO就很小了，但是SeqScan + SORT就还必须全部执行完才能获取到LIMIT 1，也就是说SeqScan + SORT、或者说SORT要获取第一条元组的启动代价是比较高的，如果上面有LIMIT 1这样的子句，那么启动代价高的路径可能就没有优势了，这就是启动代价的作用。”\n\n小明恍然大悟，说：“SORT要全部做完才能获取第一条元组，它的启动代价大，但是总代价小，而索引扫描呢，因为本身有序，它的启动代价是小的，但是由于有随机IO，所以它的总代价是大的，如果我们只按照总代价进行筛选，就没办法获得最优的代价了。”\n\n“什么什么？启动代价。。。你们进展很快嘛。”这时大明跑过来，说：“让我们想一下晚上吃点什么吧？”\n\n小明：“吃点好的，很有必要。我这脑细胞已经快用没了。”\n","source":"_posts/postgresql-optimizer-outline-8.md","raw":"---\ntitle: PostgreSQL优化器白话(8) - 算计不到就受穷\ndate: 2020-10-03 08:55:42\ntags: 代价 启动代价 IO代价 CPU代价\n---\n\n“俗话说啊，吃不穷，穿不穷，算计不到就受穷。”大明一边啃着大腰子，一边说：“所以该吃就得吃，吃是吃不穷的。”\n\t\n小明说：“可是算来算去，物理路径的代价还是有选不准的时候啊。”\n\n牛二哥说：“小明你已经走火入魔了，我们正在美美的吃饭，你看大明啃得竹签子都冒火星子，你非要扯到优化器，太扫兴了，好了，我吃饱了，我来和你聊聊。”说着牛二哥抽了张纸巾擦了擦嘴，纸巾被嘴角的油浸成透明状，飘悠悠的被牛二哥弹进了垃圾筐，然后牛二哥抚摸着自己沟满壕平的肚子，慢条斯理的说：“最优路径选的不准是谁的原因，那就是代价模型不行啊，代价模型不行赖谁，那就是程序员没建好啊，所以要怪就要怪到程序员自己头上。”\n<!-- more -->\n\n小明问道：“可是我看PostgreSQL数据库的代价计算已经很复杂了啊？”\n\n“可是数据库的周边环境更复杂啊。你想想，在实际应用中，数据库用户的配置硬件环境千差万别，CPU的频率、主存的大小和磁盘介质的性质都会影响执行计划在实际执行时的效率。”牛二哥说完，喝了一口红酒。\n\n大明接过来继续说道；“虽然在代价估算的过程中，我们无法获得‘绝对真实’的代价，但是‘绝对真实’的代价也是不必要的，因为我们只是想从多个路径（Path）中找到一个代价最小的路径，只要这些路径的代价是可以‘相互比较’的就可以了，因此可以设定一个‘相对’的代价的单位1，同一个查询中所有的物理路径都基于这个“相对”的单位1来计算的代价，这样计算出来的代价就是可以比较的，也就能用来对路径进行挑选了。”\n\n然后大明给牛二哥递了根中华烟，说：“饭后一根烟，赛过活神仙，来，抽一根。”牛二哥接过烟，大明把火递了过来，牛二哥点上了烟，把打火机扔到茶几上，然后深吸了一口，喷云吐雾的说：“PostgreSQL数据库采用顺序读写一个页面的IO代价作为单位1，而把随机IO定位了顺序IO的4倍”\n\n小明说：“我知道，我知道，这个我查过相关的书，首先，目前的存储介质很大部分仍然是机械硬盘，机械硬盘的磁头在获得数据库的时候需要付出寻道时间，如果要读写的是一串在磁盘上连续的数据，就可以节省寻道时间，提高IO性能，而如果随机读写磁盘上任意扇区的数据，那么会有大量的时间浪费在寻道上。其次，大部分磁盘本身带有缓存，这就形成了主存->磁盘缓存->磁盘的三级结构，在将磁盘的内容加载到内存的时候，考虑到磁盘的IO性能，磁盘会进行数据的预读，把预读到的数据保存在磁盘的缓存中，也就是说如果用户只打算从磁盘读取100个字节的数据，那么磁盘可能会连续的读取磁盘中的512字节（不同的磁盘预读的数量可能不同）并将其保存到磁盘缓存，如果下一次是顺序读取100个字节之后的内容，那么预读的512字节的数据就会发挥作用，性能会大大的增加，而如果读取的内容超出了512字节的范围，那么预读的数据就没有发挥作用，磁盘的IO性能就会下降。”说完小明得意的说：“怎么样，我说的对吧？”\n\n牛二哥说：“你说的对，目前PostgreSQL的查询优化大量的考虑了随机IO和顺序IO所带来的性能差别，在这方面做了不少优化，但是现在的磁盘技术越来越发达了，以后随机IO和顺序IO是不是还差这么多，就值得商榷了。”\n\n“那到底还有那些代价基准单位呢？”小明继续问道。\n\n大明回答道：“基于磁盘IO的代价单位当然就是和Page有关的了，也就是说我们刚才说的顺序IO和随机IO都属于IO方面的基准代价。让后让牛二哥给你介绍一下CPU方面的代价基准单位，我先去吃个鸡。”\n\n牛二哥说：“CPU方面的基准单位有哪些呢？比如说我们通过IO把磁盘页面读到了缓存，但我们要处理的是元组啊，所以还需要把元组从页面里解出来，还要处理元组，这部分主要消耗的是CPU，所以会有一个元组处理的代价基准单位，另外，我们在投影、约束条件里有大量的表达式，这些表达式求解也主要消耗CPU资源，所以还有一个表达式代价的基准单位。”\n\n牛二哥弹了弹烟灰，继续说道：“现在PostgreSQL数据库增加了很多并行路径，因此它也产生了通信代价，这个也需要计算的。”\n\n小明听了之后，说：“那我们就能得到一个这样的公式。”说着在纸上写了一个公式：\n```\n\t\t总代价 = CPU代价 + IO代价 + 通信代价\n```\n\n然后小明继续说：“可是我通过EXPLAIN还查看过PostgreSQL的执行计划，我从执行计划中还看到有启动代价和总代价，这是怎么回事呢？”\n\n牛二哥听了之后，想了想，在纸上写了一个公式：\n\n```\n\t\t总代价 = 启动代价 + 执行代价\n```\n\n然后牛二哥说：“这是从另一个角度来计算代价，启动代价是指从语句开始执行到查询引擎返回第一条元组的代价（另一种说法是准备好去获得第一条元组的代价），总代价是SQL语句从开始执行到结束的所有代价。”\n\t\n“可是。。。为什么要区分启动代价和执行代价呢？”\n\n“这个嘛。。。。”牛二哥思考了一下，觉得一句两句不容易说清楚，于是写了个例子：\n\n```\n\tSELECT * FROM TEST_A WHERE a > 1 ORDER BY a LIMIT 1;\n```\n\n“我们假设这个在TEST_A(a)上有一个B树索引，晓得不，那这个语句可能会形成什么样的执行计划呢？”\n\n小明想了想，觉得空想可能有点困难，于是在纸上画了一起，最终他画了两个执行路径：\n\n```\n\t执行路径1：LIMIT 1\n       \t\t\t\t-> SORT(a)\n                       -> SeqScan WHERE A > 1;\n\t执行路径2：LIMIT 1\n\t\t\t\t\t-> IndexScan WHERE A > 1; \n\t\t\t\t\t（小明注：B树索引有序，不用再排序了）\n```\n\n小明说：“我觉得这两个都可以，不过我觉得第二个更好，因为它节省了排序的时间。”\n\n牛二哥问：“你知道的，PostgreSQL数据库采用动态规划的方法来实现路径的搜索，它是一种自底向上的方法，也就是说会先建立筛选扫描路径，然后用筛选后的扫描路径再去形成连接路径，那么在我们筛选扫描路径的时候，是不知道它的上层有没有LIMIT的，这时候如果单独看SeqScan + SORT和IndexScan你觉得哪个好呢？”\n\n“嗯，我知道陷阱在哪里，大明和我说过，A > 1的选择率高的话会选择顺序扫描，而A > 1的选择率低的情况下，会选择索引扫描，这是因为索引扫描会产生随机IO，也就是说在选择率高的情况下，有可能SeqScan + SORT会优于IndexScan，虽然SeqScan + SORT会有排序，但是IndexScan的随机IO实在是太可观了。”\n\n牛二哥点了点头，说：“对的，假设选择率比较高，这时候选择了SeqScan + SORT，是因为它不知道再上层是LIMIT 1，如果上面是LIMIT 1，就会导致索引扫描不用全部扫完，只要扫一丢丢就可以了，这时候随机IO就很小了，但是SeqScan + SORT就还必须全部执行完才能获取到LIMIT 1，也就是说SeqScan + SORT、或者说SORT要获取第一条元组的启动代价是比较高的，如果上面有LIMIT 1这样的子句，那么启动代价高的路径可能就没有优势了，这就是启动代价的作用。”\n\n小明恍然大悟，说：“SORT要全部做完才能获取第一条元组，它的启动代价大，但是总代价小，而索引扫描呢，因为本身有序，它的启动代价是小的，但是由于有随机IO，所以它的总代价是大的，如果我们只按照总代价进行筛选，就没办法获得最优的代价了。”\n\n“什么什么？启动代价。。。你们进展很快嘛。”这时大明跑过来，说：“让我们想一下晚上吃点什么吧？”\n\n小明：“吃点好的，很有必要。我这脑细胞已经快用没了。”\n","slug":"postgresql-optimizer-outline-8","published":1,"updated":"2020-10-03T01:01:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfszbzyk0001ro9kakdf920l","content":"<p>“俗话说啊，吃不穷，穿不穷，算计不到就受穷。”大明一边啃着大腰子，一边说：“所以该吃就得吃，吃是吃不穷的。”</p>\n<p>小明说：“可是算来算去，物理路径的代价还是有选不准的时候啊。”</p>\n<p>牛二哥说：“小明你已经走火入魔了，我们正在美美的吃饭，你看大明啃得竹签子都冒火星子，你非要扯到优化器，太扫兴了，好了，我吃饱了，我来和你聊聊。”说着牛二哥抽了张纸巾擦了擦嘴，纸巾被嘴角的油浸成透明状，飘悠悠的被牛二哥弹进了垃圾筐，然后牛二哥抚摸着自己沟满壕平的肚子，慢条斯理的说：“最优路径选的不准是谁的原因，那就是代价模型不行啊，代价模型不行赖谁，那就是程序员没建好啊，所以要怪就要怪到程序员自己头上。”</p>\n<a id=\"more\"></a>\n\n<p>小明问道：“可是我看PostgreSQL数据库的代价计算已经很复杂了啊？”</p>\n<p>“可是数据库的周边环境更复杂啊。你想想，在实际应用中，数据库用户的配置硬件环境千差万别，CPU的频率、主存的大小和磁盘介质的性质都会影响执行计划在实际执行时的效率。”牛二哥说完，喝了一口红酒。</p>\n<p>大明接过来继续说道；“虽然在代价估算的过程中，我们无法获得‘绝对真实’的代价，但是‘绝对真实’的代价也是不必要的，因为我们只是想从多个路径（Path）中找到一个代价最小的路径，只要这些路径的代价是可以‘相互比较’的就可以了，因此可以设定一个‘相对’的代价的单位1，同一个查询中所有的物理路径都基于这个“相对”的单位1来计算的代价，这样计算出来的代价就是可以比较的，也就能用来对路径进行挑选了。”</p>\n<p>然后大明给牛二哥递了根中华烟，说：“饭后一根烟，赛过活神仙，来，抽一根。”牛二哥接过烟，大明把火递了过来，牛二哥点上了烟，把打火机扔到茶几上，然后深吸了一口，喷云吐雾的说：“PostgreSQL数据库采用顺序读写一个页面的IO代价作为单位1，而把随机IO定位了顺序IO的4倍”</p>\n<p>小明说：“我知道，我知道，这个我查过相关的书，首先，目前的存储介质很大部分仍然是机械硬盘，机械硬盘的磁头在获得数据库的时候需要付出寻道时间，如果要读写的是一串在磁盘上连续的数据，就可以节省寻道时间，提高IO性能，而如果随机读写磁盘上任意扇区的数据，那么会有大量的时间浪费在寻道上。其次，大部分磁盘本身带有缓存，这就形成了主存-&gt;磁盘缓存-&gt;磁盘的三级结构，在将磁盘的内容加载到内存的时候，考虑到磁盘的IO性能，磁盘会进行数据的预读，把预读到的数据保存在磁盘的缓存中，也就是说如果用户只打算从磁盘读取100个字节的数据，那么磁盘可能会连续的读取磁盘中的512字节（不同的磁盘预读的数量可能不同）并将其保存到磁盘缓存，如果下一次是顺序读取100个字节之后的内容，那么预读的512字节的数据就会发挥作用，性能会大大的增加，而如果读取的内容超出了512字节的范围，那么预读的数据就没有发挥作用，磁盘的IO性能就会下降。”说完小明得意的说：“怎么样，我说的对吧？”</p>\n<p>牛二哥说：“你说的对，目前PostgreSQL的查询优化大量的考虑了随机IO和顺序IO所带来的性能差别，在这方面做了不少优化，但是现在的磁盘技术越来越发达了，以后随机IO和顺序IO是不是还差这么多，就值得商榷了。”</p>\n<p>“那到底还有那些代价基准单位呢？”小明继续问道。</p>\n<p>大明回答道：“基于磁盘IO的代价单位当然就是和Page有关的了，也就是说我们刚才说的顺序IO和随机IO都属于IO方面的基准代价。让后让牛二哥给你介绍一下CPU方面的代价基准单位，我先去吃个鸡。”</p>\n<p>牛二哥说：“CPU方面的基准单位有哪些呢？比如说我们通过IO把磁盘页面读到了缓存，但我们要处理的是元组啊，所以还需要把元组从页面里解出来，还要处理元组，这部分主要消耗的是CPU，所以会有一个元组处理的代价基准单位，另外，我们在投影、约束条件里有大量的表达式，这些表达式求解也主要消耗CPU资源，所以还有一个表达式代价的基准单位。”</p>\n<p>牛二哥弹了弹烟灰，继续说道：“现在PostgreSQL数据库增加了很多并行路径，因此它也产生了通信代价，这个也需要计算的。”</p>\n<p>小明听了之后，说：“那我们就能得到一个这样的公式。”说着在纸上写了一个公式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">总代价 &#x3D; CPU代价 + IO代价 + 通信代价</span><br></pre></td></tr></table></figure>\n\n<p>然后小明继续说：“可是我通过EXPLAIN还查看过PostgreSQL的执行计划，我从执行计划中还看到有启动代价和总代价，这是怎么回事呢？”</p>\n<p>牛二哥听了之后，想了想，在纸上写了一个公式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">总代价 &#x3D; 启动代价 + 执行代价</span><br></pre></td></tr></table></figure>\n\n<p>然后牛二哥说：“这是从另一个角度来计算代价，启动代价是指从语句开始执行到查询引擎返回第一条元组的代价（另一种说法是准备好去获得第一条元组的代价），总代价是SQL语句从开始执行到结束的所有代价。”</p>\n<p>“可是。。。为什么要区分启动代价和执行代价呢？”</p>\n<p>“这个嘛。。。。”牛二哥思考了一下，觉得一句两句不容易说清楚，于是写了个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM TEST_A WHERE a &gt; 1 ORDER BY a LIMIT 1;</span><br></pre></td></tr></table></figure>\n\n<p>“我们假设这个在TEST_A(a)上有一个B树索引，晓得不，那这个语句可能会形成什么样的执行计划呢？”</p>\n<p>小明想了想，觉得空想可能有点困难，于是在纸上画了一起，最终他画了两个执行路径：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行路径1：LIMIT 1</span><br><span class=\"line\">                      -&gt; SORT(a)</span><br><span class=\"line\">                      -&gt; SeqScan WHERE A &gt; 1;</span><br><span class=\"line\">执行路径2：LIMIT 1</span><br><span class=\"line\">                -&gt; IndexScan WHERE A &gt; 1; </span><br><span class=\"line\">                （小明注：B树索引有序，不用再排序了）</span><br></pre></td></tr></table></figure>\n\n<p>小明说：“我觉得这两个都可以，不过我觉得第二个更好，因为它节省了排序的时间。”</p>\n<p>牛二哥问：“你知道的，PostgreSQL数据库采用动态规划的方法来实现路径的搜索，它是一种自底向上的方法，也就是说会先建立筛选扫描路径，然后用筛选后的扫描路径再去形成连接路径，那么在我们筛选扫描路径的时候，是不知道它的上层有没有LIMIT的，这时候如果单独看SeqScan + SORT和IndexScan你觉得哪个好呢？”</p>\n<p>“嗯，我知道陷阱在哪里，大明和我说过，A &gt; 1的选择率高的话会选择顺序扫描，而A &gt; 1的选择率低的情况下，会选择索引扫描，这是因为索引扫描会产生随机IO，也就是说在选择率高的情况下，有可能SeqScan + SORT会优于IndexScan，虽然SeqScan + SORT会有排序，但是IndexScan的随机IO实在是太可观了。”</p>\n<p>牛二哥点了点头，说：“对的，假设选择率比较高，这时候选择了SeqScan + SORT，是因为它不知道再上层是LIMIT 1，如果上面是LIMIT 1，就会导致索引扫描不用全部扫完，只要扫一丢丢就可以了，这时候随机IO就很小了，但是SeqScan + SORT就还必须全部执行完才能获取到LIMIT 1，也就是说SeqScan + SORT、或者说SORT要获取第一条元组的启动代价是比较高的，如果上面有LIMIT 1这样的子句，那么启动代价高的路径可能就没有优势了，这就是启动代价的作用。”</p>\n<p>小明恍然大悟，说：“SORT要全部做完才能获取第一条元组，它的启动代价大，但是总代价小，而索引扫描呢，因为本身有序，它的启动代价是小的，但是由于有随机IO，所以它的总代价是大的，如果我们只按照总代价进行筛选，就没办法获得最优的代价了。”</p>\n<p>“什么什么？启动代价。。。你们进展很快嘛。”这时大明跑过来，说：“让我们想一下晚上吃点什么吧？”</p>\n<p>小明：“吃点好的，很有必要。我这脑细胞已经快用没了。”</p>\n","site":{"data":{}},"excerpt":"<p>“俗话说啊，吃不穷，穿不穷，算计不到就受穷。”大明一边啃着大腰子，一边说：“所以该吃就得吃，吃是吃不穷的。”</p>\n<p>小明说：“可是算来算去，物理路径的代价还是有选不准的时候啊。”</p>\n<p>牛二哥说：“小明你已经走火入魔了，我们正在美美的吃饭，你看大明啃得竹签子都冒火星子，你非要扯到优化器，太扫兴了，好了，我吃饱了，我来和你聊聊。”说着牛二哥抽了张纸巾擦了擦嘴，纸巾被嘴角的油浸成透明状，飘悠悠的被牛二哥弹进了垃圾筐，然后牛二哥抚摸着自己沟满壕平的肚子，慢条斯理的说：“最优路径选的不准是谁的原因，那就是代价模型不行啊，代价模型不行赖谁，那就是程序员没建好啊，所以要怪就要怪到程序员自己头上。”</p>","more":"<p>小明问道：“可是我看PostgreSQL数据库的代价计算已经很复杂了啊？”</p>\n<p>“可是数据库的周边环境更复杂啊。你想想，在实际应用中，数据库用户的配置硬件环境千差万别，CPU的频率、主存的大小和磁盘介质的性质都会影响执行计划在实际执行时的效率。”牛二哥说完，喝了一口红酒。</p>\n<p>大明接过来继续说道；“虽然在代价估算的过程中，我们无法获得‘绝对真实’的代价，但是‘绝对真实’的代价也是不必要的，因为我们只是想从多个路径（Path）中找到一个代价最小的路径，只要这些路径的代价是可以‘相互比较’的就可以了，因此可以设定一个‘相对’的代价的单位1，同一个查询中所有的物理路径都基于这个“相对”的单位1来计算的代价，这样计算出来的代价就是可以比较的，也就能用来对路径进行挑选了。”</p>\n<p>然后大明给牛二哥递了根中华烟，说：“饭后一根烟，赛过活神仙，来，抽一根。”牛二哥接过烟，大明把火递了过来，牛二哥点上了烟，把打火机扔到茶几上，然后深吸了一口，喷云吐雾的说：“PostgreSQL数据库采用顺序读写一个页面的IO代价作为单位1，而把随机IO定位了顺序IO的4倍”</p>\n<p>小明说：“我知道，我知道，这个我查过相关的书，首先，目前的存储介质很大部分仍然是机械硬盘，机械硬盘的磁头在获得数据库的时候需要付出寻道时间，如果要读写的是一串在磁盘上连续的数据，就可以节省寻道时间，提高IO性能，而如果随机读写磁盘上任意扇区的数据，那么会有大量的时间浪费在寻道上。其次，大部分磁盘本身带有缓存，这就形成了主存-&gt;磁盘缓存-&gt;磁盘的三级结构，在将磁盘的内容加载到内存的时候，考虑到磁盘的IO性能，磁盘会进行数据的预读，把预读到的数据保存在磁盘的缓存中，也就是说如果用户只打算从磁盘读取100个字节的数据，那么磁盘可能会连续的读取磁盘中的512字节（不同的磁盘预读的数量可能不同）并将其保存到磁盘缓存，如果下一次是顺序读取100个字节之后的内容，那么预读的512字节的数据就会发挥作用，性能会大大的增加，而如果读取的内容超出了512字节的范围，那么预读的数据就没有发挥作用，磁盘的IO性能就会下降。”说完小明得意的说：“怎么样，我说的对吧？”</p>\n<p>牛二哥说：“你说的对，目前PostgreSQL的查询优化大量的考虑了随机IO和顺序IO所带来的性能差别，在这方面做了不少优化，但是现在的磁盘技术越来越发达了，以后随机IO和顺序IO是不是还差这么多，就值得商榷了。”</p>\n<p>“那到底还有那些代价基准单位呢？”小明继续问道。</p>\n<p>大明回答道：“基于磁盘IO的代价单位当然就是和Page有关的了，也就是说我们刚才说的顺序IO和随机IO都属于IO方面的基准代价。让后让牛二哥给你介绍一下CPU方面的代价基准单位，我先去吃个鸡。”</p>\n<p>牛二哥说：“CPU方面的基准单位有哪些呢？比如说我们通过IO把磁盘页面读到了缓存，但我们要处理的是元组啊，所以还需要把元组从页面里解出来，还要处理元组，这部分主要消耗的是CPU，所以会有一个元组处理的代价基准单位，另外，我们在投影、约束条件里有大量的表达式，这些表达式求解也主要消耗CPU资源，所以还有一个表达式代价的基准单位。”</p>\n<p>牛二哥弹了弹烟灰，继续说道：“现在PostgreSQL数据库增加了很多并行路径，因此它也产生了通信代价，这个也需要计算的。”</p>\n<p>小明听了之后，说：“那我们就能得到一个这样的公式。”说着在纸上写了一个公式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">总代价 &#x3D; CPU代价 + IO代价 + 通信代价</span><br></pre></td></tr></table></figure>\n\n<p>然后小明继续说：“可是我通过EXPLAIN还查看过PostgreSQL的执行计划，我从执行计划中还看到有启动代价和总代价，这是怎么回事呢？”</p>\n<p>牛二哥听了之后，想了想，在纸上写了一个公式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">总代价 &#x3D; 启动代价 + 执行代价</span><br></pre></td></tr></table></figure>\n\n<p>然后牛二哥说：“这是从另一个角度来计算代价，启动代价是指从语句开始执行到查询引擎返回第一条元组的代价（另一种说法是准备好去获得第一条元组的代价），总代价是SQL语句从开始执行到结束的所有代价。”</p>\n<p>“可是。。。为什么要区分启动代价和执行代价呢？”</p>\n<p>“这个嘛。。。。”牛二哥思考了一下，觉得一句两句不容易说清楚，于是写了个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM TEST_A WHERE a &gt; 1 ORDER BY a LIMIT 1;</span><br></pre></td></tr></table></figure>\n\n<p>“我们假设这个在TEST_A(a)上有一个B树索引，晓得不，那这个语句可能会形成什么样的执行计划呢？”</p>\n<p>小明想了想，觉得空想可能有点困难，于是在纸上画了一起，最终他画了两个执行路径：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行路径1：LIMIT 1</span><br><span class=\"line\">                      -&gt; SORT(a)</span><br><span class=\"line\">                      -&gt; SeqScan WHERE A &gt; 1;</span><br><span class=\"line\">执行路径2：LIMIT 1</span><br><span class=\"line\">                -&gt; IndexScan WHERE A &gt; 1; </span><br><span class=\"line\">                （小明注：B树索引有序，不用再排序了）</span><br></pre></td></tr></table></figure>\n\n<p>小明说：“我觉得这两个都可以，不过我觉得第二个更好，因为它节省了排序的时间。”</p>\n<p>牛二哥问：“你知道的，PostgreSQL数据库采用动态规划的方法来实现路径的搜索，它是一种自底向上的方法，也就是说会先建立筛选扫描路径，然后用筛选后的扫描路径再去形成连接路径，那么在我们筛选扫描路径的时候，是不知道它的上层有没有LIMIT的，这时候如果单独看SeqScan + SORT和IndexScan你觉得哪个好呢？”</p>\n<p>“嗯，我知道陷阱在哪里，大明和我说过，A &gt; 1的选择率高的话会选择顺序扫描，而A &gt; 1的选择率低的情况下，会选择索引扫描，这是因为索引扫描会产生随机IO，也就是说在选择率高的情况下，有可能SeqScan + SORT会优于IndexScan，虽然SeqScan + SORT会有排序，但是IndexScan的随机IO实在是太可观了。”</p>\n<p>牛二哥点了点头，说：“对的，假设选择率比较高，这时候选择了SeqScan + SORT，是因为它不知道再上层是LIMIT 1，如果上面是LIMIT 1，就会导致索引扫描不用全部扫完，只要扫一丢丢就可以了，这时候随机IO就很小了，但是SeqScan + SORT就还必须全部执行完才能获取到LIMIT 1，也就是说SeqScan + SORT、或者说SORT要获取第一条元组的启动代价是比较高的，如果上面有LIMIT 1这样的子句，那么启动代价高的路径可能就没有优势了，这就是启动代价的作用。”</p>\n<p>小明恍然大悟，说：“SORT要全部做完才能获取第一条元组，它的启动代价大，但是总代价小，而索引扫描呢，因为本身有序，它的启动代价是小的，但是由于有随机IO，所以它的总代价是大的，如果我们只按照总代价进行筛选，就没办法获得最优的代价了。”</p>\n<p>“什么什么？启动代价。。。你们进展很快嘛。”这时大明跑过来，说：“让我们想一下晚上吃点什么吧？”</p>\n<p>小明：“吃点好的，很有必要。我这脑细胞已经快用没了。”</p>"},{"title":"PostgreSQL优化器白话(9) - 找饭店","date":"2020-10-03T01:01:40.000Z","_content":"\n\n小明、大明和牛二哥在大坑点评里搜索附近好的饭店，搜来搜去总是感觉不太靠谱，不是卫生有问题，就是味道不够正宗，大明感叹道：“看，这就是蓝海，我们可以创业搞一个AI点评，只能推荐最优的饭店啊，我准确的找到了吃货们的痛点，这里面隐含着很大的商机啊！”\n\n牛二哥瞥了它一眼说：“AI推荐当然好啊，可是要推荐的准才行啊，可是一个人一个口味，你这个需求太‘智能’了，我估计不好弄。”\n\n小明突然想到自己最近在学校的算法课上老师讲过一些求最优解问题的方法，然后说：“我知道，我知道，我最近在算法课上学过一些最优解问题的解决方法，应该可以用得上。”\n\n<!-- more -->\n\n牛二哥叹口气道：“可是这些方法用到优化器里都不一定够用，何况用到一个更加智能的项目上呢？”\n\n“嗯？优化器里也用到了最优解问题的方法了吗？我们学过动态规划、贪心算法。。。”小明如数家珍的说起来。\n\n大明说：“用到了啊， 虽然物理路径看上去也不多，但实际上枚举起来，它的搜索空间也不小。例如在扫描路径中，我们就可以有顺序扫描、索引扫描和位图扫描，假如一个表上有多个索引，那么就可能产生多个不同的索引扫描，那么哪个索引扫描路径好呢？而索引扫描和顺序扫描、位图扫描相比，哪个好呢？”\n\n大明看着小明迷离的眼神，停顿了一下，给他足够的思考空间之后继续说道：“数据库路径的搜索方法通常有3种类型：自底向上方法、自顶向下方法、随机方法，而PostgreSQL采用了其中的两种方法呢。”\n\n“采用了哪两种方法呢？”牛二哥明知故问道。\n\n“采用了自底向上的方法和随机方法，其中自底向上的方法是采用的动态规划方法，而随机方法采用的是遗传算法。”\n\n“那有谁使用了自顶向下的方法呢？”牛二哥继续“捧哏”道。\n\n“嗯。。。这个嘛，Pivotal公司的开源优化器ORCA用的就是自顶向下的方法。可以让牛二先给你说说怎么样用动态规划方法搜索最优物理路径。”\n\n牛二哥拿出纸来，在纸上画了几个圈，然后说：“这代表4个表，自底向上嘛，所以是从底下向上堆积，这是最底层，我们叫它第一层”。\n\n![](./postgresql-optimizer-outline-9/1.png) \n\n“动态规划方法首先考虑两个表的连接，其中优先考虑有连接关系的表进行连接，两个表的连接可以建立一个新的表，我们把这些新表叫做第二层。”牛二哥通过连线，产生了一些新的“表”。\n\n![](./postgresql-optimizer-outline-9/2.png) \n\n“第二层的表和第一层的表再连接，可以生成基于3个表连接的新的‘表’，这样就又向前推进了一层，我们产生了第三层”\n\n![](./postgresql-optimizer-outline-9/3.png) \n \n“然后再用第三层的表和第一层的表进行连接，最终生成整个问题的最优路径。”\n\n![](./postgresql-optimizer-outline-9/4.png) \n \n“可是，这不就是穷举吗？”小明问道。\n\n牛二哥解释说：“动态规划有两个特点，一个是要重复的利用子问题的解，这样能减少计算量，降低复杂度，另外一点就是通过子问题的最优解能够构造出最终的最优解，也就是说需要具有最优子结构的性质，所以动态规划的复杂度和穷举是不一样的。”\n\n大明继续解释说：“还有，虽然你看图里的连线比较多，但在实际情况里，并不是所有的圈圈之间都能产生连线，连接关系也有个合法性的问题嘛，所以复杂度是可以控制住的。”\n\n小明感觉好像明白了一点，然后赶紧追问：“那遗传算法呢？”\n\n大明说：“虽然动态规划的复杂度是可以控制的，但是如果表比较多，它的搜索空间还是很大，所以如果在表比较多的时候，可以尝试使遗传算法，这个算法获得的不一定是全局最优解，它获得的可能是局部最优解。”\n\n“那遗传算法是怎么实现物理路径搜索的呢？”小明问。\n\n牛二哥去大明的书柜里找到了一本算法的书，恰好里面有遗传算法的介绍，于是朗读了起来：“遗传算法的实现步骤如下：1）种群初始化：对基因进行编码，并通过对基因进行随机的排列组合，生成多个染色体，这些染色体构成一个新的种群，另外，在生成染色体的过程中同时计算染色体的适应度；2）选择染色体：通过随机选择（实际上通过基于概率的随机数生成算法，这样能倾向于选择出优秀的染色体），选择出用于交叉和变异的染色体；3）交叉操作：染色体进行交叉，产生新的染色体并加入到种群；4）变异操作：对染色体进行变异操作，产生新的染色体并加入到种群；5）适应度计算：对不良的染色体进行淘汰。”\n\n大明笑着说：“尽信书不如无书，我来说一下遗传算法是如何解决货郎问题的。我们可以将城市作为基因，走遍各个城市的路径作为染色体，路径的总长度作为适应度，适应度函数负责筛选掉比较长的路径，保留较短的路径，算法的步骤如下：1）对各个城市进行编号，将各个城市根据编号进行排列组合，生成多条新的路径（染色体），然后根据各城市间的距离计算整体路径长度（适应度），多条新路径构成一个种群；2）选择两个路径进行交叉（需要注意交叉生成新染色体中不能重复出现同一个城市），对交叉操作产生的新路径计算路径长度；3）随机选择染色体进行变异（通常方法是交换城市在路径中的位置），对变异操作后的新路径计算路径长度；4）对种群中所有路径进行基于路径长度有小到大排序，淘汰掉排名靠后的路径。”大明一口气说完了整个流程，长出了一口气，然后继续说：“怎么样，是不是so easy?”\n\n小明想了想牛二哥和大明说的流程，然后说，“我来猜想一下PostgreSQL是如何实现遗传算法的，PostgreSQL应该是模拟了解决货郎问题的方法，它将表作为基因、最终生成的执行计划作为染色体、执行计划的总代价作为适应度，适应度函数则是基于路径的代价进行筛选，对不对？”\n\n牛二哥赞叹道：“说得非常好，不过需 PostgreSQL数据库的基因算法实现方式和通常的遗传算法略有不同在于其没有变异的过程，只通过交叉产生新的染色体，不过这都不是重点了。”\n\n大明说：“哎哎哎，我们不是在搜索饭店吗，怎么搜索起来最优路径了？不要再说优化器了，再晚点饭都没得吃了。”\n于是三个人又热火朝天的搜起饭店来了。\n\n\n","source":"_posts/postgresql-optimizer-outline-9.md","raw":"---\ntitle: PostgreSQL优化器白话(9) - 找饭店\ndate: 2020-10-03 09:01:40\ntags: 动态规划 自底向上 自顶向下\n---\n\n\n小明、大明和牛二哥在大坑点评里搜索附近好的饭店，搜来搜去总是感觉不太靠谱，不是卫生有问题，就是味道不够正宗，大明感叹道：“看，这就是蓝海，我们可以创业搞一个AI点评，只能推荐最优的饭店啊，我准确的找到了吃货们的痛点，这里面隐含着很大的商机啊！”\n\n牛二哥瞥了它一眼说：“AI推荐当然好啊，可是要推荐的准才行啊，可是一个人一个口味，你这个需求太‘智能’了，我估计不好弄。”\n\n小明突然想到自己最近在学校的算法课上老师讲过一些求最优解问题的方法，然后说：“我知道，我知道，我最近在算法课上学过一些最优解问题的解决方法，应该可以用得上。”\n\n<!-- more -->\n\n牛二哥叹口气道：“可是这些方法用到优化器里都不一定够用，何况用到一个更加智能的项目上呢？”\n\n“嗯？优化器里也用到了最优解问题的方法了吗？我们学过动态规划、贪心算法。。。”小明如数家珍的说起来。\n\n大明说：“用到了啊， 虽然物理路径看上去也不多，但实际上枚举起来，它的搜索空间也不小。例如在扫描路径中，我们就可以有顺序扫描、索引扫描和位图扫描，假如一个表上有多个索引，那么就可能产生多个不同的索引扫描，那么哪个索引扫描路径好呢？而索引扫描和顺序扫描、位图扫描相比，哪个好呢？”\n\n大明看着小明迷离的眼神，停顿了一下，给他足够的思考空间之后继续说道：“数据库路径的搜索方法通常有3种类型：自底向上方法、自顶向下方法、随机方法，而PostgreSQL采用了其中的两种方法呢。”\n\n“采用了哪两种方法呢？”牛二哥明知故问道。\n\n“采用了自底向上的方法和随机方法，其中自底向上的方法是采用的动态规划方法，而随机方法采用的是遗传算法。”\n\n“那有谁使用了自顶向下的方法呢？”牛二哥继续“捧哏”道。\n\n“嗯。。。这个嘛，Pivotal公司的开源优化器ORCA用的就是自顶向下的方法。可以让牛二先给你说说怎么样用动态规划方法搜索最优物理路径。”\n\n牛二哥拿出纸来，在纸上画了几个圈，然后说：“这代表4个表，自底向上嘛，所以是从底下向上堆积，这是最底层，我们叫它第一层”。\n\n![](./postgresql-optimizer-outline-9/1.png) \n\n“动态规划方法首先考虑两个表的连接，其中优先考虑有连接关系的表进行连接，两个表的连接可以建立一个新的表，我们把这些新表叫做第二层。”牛二哥通过连线，产生了一些新的“表”。\n\n![](./postgresql-optimizer-outline-9/2.png) \n\n“第二层的表和第一层的表再连接，可以生成基于3个表连接的新的‘表’，这样就又向前推进了一层，我们产生了第三层”\n\n![](./postgresql-optimizer-outline-9/3.png) \n \n“然后再用第三层的表和第一层的表进行连接，最终生成整个问题的最优路径。”\n\n![](./postgresql-optimizer-outline-9/4.png) \n \n“可是，这不就是穷举吗？”小明问道。\n\n牛二哥解释说：“动态规划有两个特点，一个是要重复的利用子问题的解，这样能减少计算量，降低复杂度，另外一点就是通过子问题的最优解能够构造出最终的最优解，也就是说需要具有最优子结构的性质，所以动态规划的复杂度和穷举是不一样的。”\n\n大明继续解释说：“还有，虽然你看图里的连线比较多，但在实际情况里，并不是所有的圈圈之间都能产生连线，连接关系也有个合法性的问题嘛，所以复杂度是可以控制住的。”\n\n小明感觉好像明白了一点，然后赶紧追问：“那遗传算法呢？”\n\n大明说：“虽然动态规划的复杂度是可以控制的，但是如果表比较多，它的搜索空间还是很大，所以如果在表比较多的时候，可以尝试使遗传算法，这个算法获得的不一定是全局最优解，它获得的可能是局部最优解。”\n\n“那遗传算法是怎么实现物理路径搜索的呢？”小明问。\n\n牛二哥去大明的书柜里找到了一本算法的书，恰好里面有遗传算法的介绍，于是朗读了起来：“遗传算法的实现步骤如下：1）种群初始化：对基因进行编码，并通过对基因进行随机的排列组合，生成多个染色体，这些染色体构成一个新的种群，另外，在生成染色体的过程中同时计算染色体的适应度；2）选择染色体：通过随机选择（实际上通过基于概率的随机数生成算法，这样能倾向于选择出优秀的染色体），选择出用于交叉和变异的染色体；3）交叉操作：染色体进行交叉，产生新的染色体并加入到种群；4）变异操作：对染色体进行变异操作，产生新的染色体并加入到种群；5）适应度计算：对不良的染色体进行淘汰。”\n\n大明笑着说：“尽信书不如无书，我来说一下遗传算法是如何解决货郎问题的。我们可以将城市作为基因，走遍各个城市的路径作为染色体，路径的总长度作为适应度，适应度函数负责筛选掉比较长的路径，保留较短的路径，算法的步骤如下：1）对各个城市进行编号，将各个城市根据编号进行排列组合，生成多条新的路径（染色体），然后根据各城市间的距离计算整体路径长度（适应度），多条新路径构成一个种群；2）选择两个路径进行交叉（需要注意交叉生成新染色体中不能重复出现同一个城市），对交叉操作产生的新路径计算路径长度；3）随机选择染色体进行变异（通常方法是交换城市在路径中的位置），对变异操作后的新路径计算路径长度；4）对种群中所有路径进行基于路径长度有小到大排序，淘汰掉排名靠后的路径。”大明一口气说完了整个流程，长出了一口气，然后继续说：“怎么样，是不是so easy?”\n\n小明想了想牛二哥和大明说的流程，然后说，“我来猜想一下PostgreSQL是如何实现遗传算法的，PostgreSQL应该是模拟了解决货郎问题的方法，它将表作为基因、最终生成的执行计划作为染色体、执行计划的总代价作为适应度，适应度函数则是基于路径的代价进行筛选，对不对？”\n\n牛二哥赞叹道：“说得非常好，不过需 PostgreSQL数据库的基因算法实现方式和通常的遗传算法略有不同在于其没有变异的过程，只通过交叉产生新的染色体，不过这都不是重点了。”\n\n大明说：“哎哎哎，我们不是在搜索饭店吗，怎么搜索起来最优路径了？不要再说优化器了，再晚点饭都没得吃了。”\n于是三个人又热火朝天的搜起饭店来了。\n\n\n","slug":"postgresql-optimizer-outline-9","published":1,"updated":"2020-10-03T01:13:29.000Z","_id":"ckfszbzyo0003ro9k3ejk08ql","comments":1,"layout":"post","photos":[],"link":"","content":"<p>小明、大明和牛二哥在大坑点评里搜索附近好的饭店，搜来搜去总是感觉不太靠谱，不是卫生有问题，就是味道不够正宗，大明感叹道：“看，这就是蓝海，我们可以创业搞一个AI点评，只能推荐最优的饭店啊，我准确的找到了吃货们的痛点，这里面隐含着很大的商机啊！”</p>\n<p>牛二哥瞥了它一眼说：“AI推荐当然好啊，可是要推荐的准才行啊，可是一个人一个口味，你这个需求太‘智能’了，我估计不好弄。”</p>\n<p>小明突然想到自己最近在学校的算法课上老师讲过一些求最优解问题的方法，然后说：“我知道，我知道，我最近在算法课上学过一些最优解问题的解决方法，应该可以用得上。”</p>\n<a id=\"more\"></a>\n\n<p>牛二哥叹口气道：“可是这些方法用到优化器里都不一定够用，何况用到一个更加智能的项目上呢？”</p>\n<p>“嗯？优化器里也用到了最优解问题的方法了吗？我们学过动态规划、贪心算法。。。”小明如数家珍的说起来。</p>\n<p>大明说：“用到了啊， 虽然物理路径看上去也不多，但实际上枚举起来，它的搜索空间也不小。例如在扫描路径中，我们就可以有顺序扫描、索引扫描和位图扫描，假如一个表上有多个索引，那么就可能产生多个不同的索引扫描，那么哪个索引扫描路径好呢？而索引扫描和顺序扫描、位图扫描相比，哪个好呢？”</p>\n<p>大明看着小明迷离的眼神，停顿了一下，给他足够的思考空间之后继续说道：“数据库路径的搜索方法通常有3种类型：自底向上方法、自顶向下方法、随机方法，而PostgreSQL采用了其中的两种方法呢。”</p>\n<p>“采用了哪两种方法呢？”牛二哥明知故问道。</p>\n<p>“采用了自底向上的方法和随机方法，其中自底向上的方法是采用的动态规划方法，而随机方法采用的是遗传算法。”</p>\n<p>“那有谁使用了自顶向下的方法呢？”牛二哥继续“捧哏”道。</p>\n<p>“嗯。。。这个嘛，Pivotal公司的开源优化器ORCA用的就是自顶向下的方法。可以让牛二先给你说说怎么样用动态规划方法搜索最优物理路径。”</p>\n<p>牛二哥拿出纸来，在纸上画了几个圈，然后说：“这代表4个表，自底向上嘛，所以是从底下向上堆积，这是最底层，我们叫它第一层”。</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-9/1.png\"> </p>\n<p>“动态规划方法首先考虑两个表的连接，其中优先考虑有连接关系的表进行连接，两个表的连接可以建立一个新的表，我们把这些新表叫做第二层。”牛二哥通过连线，产生了一些新的“表”。</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-9/2.png\"> </p>\n<p>“第二层的表和第一层的表再连接，可以生成基于3个表连接的新的‘表’，这样就又向前推进了一层，我们产生了第三层”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-9/3.png\"> </p>\n<p>“然后再用第三层的表和第一层的表进行连接，最终生成整个问题的最优路径。”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-9/4.png\"> </p>\n<p>“可是，这不就是穷举吗？”小明问道。</p>\n<p>牛二哥解释说：“动态规划有两个特点，一个是要重复的利用子问题的解，这样能减少计算量，降低复杂度，另外一点就是通过子问题的最优解能够构造出最终的最优解，也就是说需要具有最优子结构的性质，所以动态规划的复杂度和穷举是不一样的。”</p>\n<p>大明继续解释说：“还有，虽然你看图里的连线比较多，但在实际情况里，并不是所有的圈圈之间都能产生连线，连接关系也有个合法性的问题嘛，所以复杂度是可以控制住的。”</p>\n<p>小明感觉好像明白了一点，然后赶紧追问：“那遗传算法呢？”</p>\n<p>大明说：“虽然动态规划的复杂度是可以控制的，但是如果表比较多，它的搜索空间还是很大，所以如果在表比较多的时候，可以尝试使遗传算法，这个算法获得的不一定是全局最优解，它获得的可能是局部最优解。”</p>\n<p>“那遗传算法是怎么实现物理路径搜索的呢？”小明问。</p>\n<p>牛二哥去大明的书柜里找到了一本算法的书，恰好里面有遗传算法的介绍，于是朗读了起来：“遗传算法的实现步骤如下：1）种群初始化：对基因进行编码，并通过对基因进行随机的排列组合，生成多个染色体，这些染色体构成一个新的种群，另外，在生成染色体的过程中同时计算染色体的适应度；2）选择染色体：通过随机选择（实际上通过基于概率的随机数生成算法，这样能倾向于选择出优秀的染色体），选择出用于交叉和变异的染色体；3）交叉操作：染色体进行交叉，产生新的染色体并加入到种群；4）变异操作：对染色体进行变异操作，产生新的染色体并加入到种群；5）适应度计算：对不良的染色体进行淘汰。”</p>\n<p>大明笑着说：“尽信书不如无书，我来说一下遗传算法是如何解决货郎问题的。我们可以将城市作为基因，走遍各个城市的路径作为染色体，路径的总长度作为适应度，适应度函数负责筛选掉比较长的路径，保留较短的路径，算法的步骤如下：1）对各个城市进行编号，将各个城市根据编号进行排列组合，生成多条新的路径（染色体），然后根据各城市间的距离计算整体路径长度（适应度），多条新路径构成一个种群；2）选择两个路径进行交叉（需要注意交叉生成新染色体中不能重复出现同一个城市），对交叉操作产生的新路径计算路径长度；3）随机选择染色体进行变异（通常方法是交换城市在路径中的位置），对变异操作后的新路径计算路径长度；4）对种群中所有路径进行基于路径长度有小到大排序，淘汰掉排名靠后的路径。”大明一口气说完了整个流程，长出了一口气，然后继续说：“怎么样，是不是so easy?”</p>\n<p>小明想了想牛二哥和大明说的流程，然后说，“我来猜想一下PostgreSQL是如何实现遗传算法的，PostgreSQL应该是模拟了解决货郎问题的方法，它将表作为基因、最终生成的执行计划作为染色体、执行计划的总代价作为适应度，适应度函数则是基于路径的代价进行筛选，对不对？”</p>\n<p>牛二哥赞叹道：“说得非常好，不过需 PostgreSQL数据库的基因算法实现方式和通常的遗传算法略有不同在于其没有变异的过程，只通过交叉产生新的染色体，不过这都不是重点了。”</p>\n<p>大明说：“哎哎哎，我们不是在搜索饭店吗，怎么搜索起来最优路径了？不要再说优化器了，再晚点饭都没得吃了。”<br>于是三个人又热火朝天的搜起饭店来了。</p>\n","site":{"data":{}},"excerpt":"<p>小明、大明和牛二哥在大坑点评里搜索附近好的饭店，搜来搜去总是感觉不太靠谱，不是卫生有问题，就是味道不够正宗，大明感叹道：“看，这就是蓝海，我们可以创业搞一个AI点评，只能推荐最优的饭店啊，我准确的找到了吃货们的痛点，这里面隐含着很大的商机啊！”</p>\n<p>牛二哥瞥了它一眼说：“AI推荐当然好啊，可是要推荐的准才行啊，可是一个人一个口味，你这个需求太‘智能’了，我估计不好弄。”</p>\n<p>小明突然想到自己最近在学校的算法课上老师讲过一些求最优解问题的方法，然后说：“我知道，我知道，我最近在算法课上学过一些最优解问题的解决方法，应该可以用得上。”</p>","more":"<p>牛二哥叹口气道：“可是这些方法用到优化器里都不一定够用，何况用到一个更加智能的项目上呢？”</p>\n<p>“嗯？优化器里也用到了最优解问题的方法了吗？我们学过动态规划、贪心算法。。。”小明如数家珍的说起来。</p>\n<p>大明说：“用到了啊， 虽然物理路径看上去也不多，但实际上枚举起来，它的搜索空间也不小。例如在扫描路径中，我们就可以有顺序扫描、索引扫描和位图扫描，假如一个表上有多个索引，那么就可能产生多个不同的索引扫描，那么哪个索引扫描路径好呢？而索引扫描和顺序扫描、位图扫描相比，哪个好呢？”</p>\n<p>大明看着小明迷离的眼神，停顿了一下，给他足够的思考空间之后继续说道：“数据库路径的搜索方法通常有3种类型：自底向上方法、自顶向下方法、随机方法，而PostgreSQL采用了其中的两种方法呢。”</p>\n<p>“采用了哪两种方法呢？”牛二哥明知故问道。</p>\n<p>“采用了自底向上的方法和随机方法，其中自底向上的方法是采用的动态规划方法，而随机方法采用的是遗传算法。”</p>\n<p>“那有谁使用了自顶向下的方法呢？”牛二哥继续“捧哏”道。</p>\n<p>“嗯。。。这个嘛，Pivotal公司的开源优化器ORCA用的就是自顶向下的方法。可以让牛二先给你说说怎么样用动态规划方法搜索最优物理路径。”</p>\n<p>牛二哥拿出纸来，在纸上画了几个圈，然后说：“这代表4个表，自底向上嘛，所以是从底下向上堆积，这是最底层，我们叫它第一层”。</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-9/1.png\"> </p>\n<p>“动态规划方法首先考虑两个表的连接，其中优先考虑有连接关系的表进行连接，两个表的连接可以建立一个新的表，我们把这些新表叫做第二层。”牛二哥通过连线，产生了一些新的“表”。</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-9/2.png\"> </p>\n<p>“第二层的表和第一层的表再连接，可以生成基于3个表连接的新的‘表’，这样就又向前推进了一层，我们产生了第三层”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-9/3.png\"> </p>\n<p>“然后再用第三层的表和第一层的表进行连接，最终生成整个问题的最优路径。”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-9/4.png\"> </p>\n<p>“可是，这不就是穷举吗？”小明问道。</p>\n<p>牛二哥解释说：“动态规划有两个特点，一个是要重复的利用子问题的解，这样能减少计算量，降低复杂度，另外一点就是通过子问题的最优解能够构造出最终的最优解，也就是说需要具有最优子结构的性质，所以动态规划的复杂度和穷举是不一样的。”</p>\n<p>大明继续解释说：“还有，虽然你看图里的连线比较多，但在实际情况里，并不是所有的圈圈之间都能产生连线，连接关系也有个合法性的问题嘛，所以复杂度是可以控制住的。”</p>\n<p>小明感觉好像明白了一点，然后赶紧追问：“那遗传算法呢？”</p>\n<p>大明说：“虽然动态规划的复杂度是可以控制的，但是如果表比较多，它的搜索空间还是很大，所以如果在表比较多的时候，可以尝试使遗传算法，这个算法获得的不一定是全局最优解，它获得的可能是局部最优解。”</p>\n<p>“那遗传算法是怎么实现物理路径搜索的呢？”小明问。</p>\n<p>牛二哥去大明的书柜里找到了一本算法的书，恰好里面有遗传算法的介绍，于是朗读了起来：“遗传算法的实现步骤如下：1）种群初始化：对基因进行编码，并通过对基因进行随机的排列组合，生成多个染色体，这些染色体构成一个新的种群，另外，在生成染色体的过程中同时计算染色体的适应度；2）选择染色体：通过随机选择（实际上通过基于概率的随机数生成算法，这样能倾向于选择出优秀的染色体），选择出用于交叉和变异的染色体；3）交叉操作：染色体进行交叉，产生新的染色体并加入到种群；4）变异操作：对染色体进行变异操作，产生新的染色体并加入到种群；5）适应度计算：对不良的染色体进行淘汰。”</p>\n<p>大明笑着说：“尽信书不如无书，我来说一下遗传算法是如何解决货郎问题的。我们可以将城市作为基因，走遍各个城市的路径作为染色体，路径的总长度作为适应度，适应度函数负责筛选掉比较长的路径，保留较短的路径，算法的步骤如下：1）对各个城市进行编号，将各个城市根据编号进行排列组合，生成多条新的路径（染色体），然后根据各城市间的距离计算整体路径长度（适应度），多条新路径构成一个种群；2）选择两个路径进行交叉（需要注意交叉生成新染色体中不能重复出现同一个城市），对交叉操作产生的新路径计算路径长度；3）随机选择染色体进行变异（通常方法是交换城市在路径中的位置），对变异操作后的新路径计算路径长度；4）对种群中所有路径进行基于路径长度有小到大排序，淘汰掉排名靠后的路径。”大明一口气说完了整个流程，长出了一口气，然后继续说：“怎么样，是不是so easy?”</p>\n<p>小明想了想牛二哥和大明说的流程，然后说，“我来猜想一下PostgreSQL是如何实现遗传算法的，PostgreSQL应该是模拟了解决货郎问题的方法，它将表作为基因、最终生成的执行计划作为染色体、执行计划的总代价作为适应度，适应度函数则是基于路径的代价进行筛选，对不对？”</p>\n<p>牛二哥赞叹道：“说得非常好，不过需 PostgreSQL数据库的基因算法实现方式和通常的遗传算法略有不同在于其没有变异的过程，只通过交叉产生新的染色体，不过这都不是重点了。”</p>\n<p>大明说：“哎哎哎，我们不是在搜索饭店吗，怎么搜索起来最优路径了？不要再说优化器了，再晚点饭都没得吃了。”<br>于是三个人又热火朝天的搜起饭店来了。</p>"},{"title":"PostgreSQL优化器白话(10) - 我再补充两句","date":"2020-10-03T01:13:44.000Z","_content":"\n\n**全文目录**\n\n1. {% post_link postgresql-optimizer-outline-1 《PostgreSQL优化器白话》- 为什么优化 %}\n2. {% post_link postgresql-optimizer-outline-2 《PostgreSQL优化器白话》- SQL进化史 %}\n3. {% post_link postgresql-optimizer-outline-3 《PostgreSQL优化器白话》- 提升！提升！ %}\n4. {% post_link postgresql-optimizer-outline-4 《PostgreSQL优化器白话》- 下推！下推！ %}\n5. {% post_link postgresql-optimizer-outline-5 《PostgreSQL优化器白话》- 严格要求自己 %}\n6. {% post_link postgresql-optimizer-outline-6 《PostgreSQL优化器白话》- 统计局旁的泉水 %}\n7. {% post_link postgresql-optimizer-outline-7 《PostgreSQL优化器白话》- 你走你的阳关道 %}\n8. {% post_link postgresql-optimizer-outline-8 《PostgreSQL优化器白话》- 算计不到就受穷 %}\n9. {% post_link postgresql-optimizer-outline-9 《PostgreSQL优化器白话》- 找饭店 %}\n\n《PostgreSQL优化器白话》暂时剧终了，我们基本上涵盖了大部分查询优化的概念，但是由于篇幅比较小，没有把细节说得特别到位，其中有大部分内容是摘抄自《PostgreSQL技术内幕：查询优化深度探索》一书的概念解释的部分，然后以小明、大明和牛二哥进行对话的方式展现出来，对于书中介绍的代码分析的部分以及比较深入的实现细节，由于不太容易通过对话的方式展示，所以在《PostgreSQL优化器白话》中没有涉及到。\n\n我已经尽我所能将这种对话的形式写的具有故事性一些，但是限于作者的语言能力，有些情节的切换上会显得比较生硬，在情节的处理上有时也相对比较单薄了，不过请放心，我即使再努力也写不出来世界名著，所以请不要鄙视我，因为我生气起来连我自己都害怕。","source":"_posts/postgresql-optimizer-outline-10.md","raw":"---\ntitle: PostgreSQL优化器白话(10) - 我再补充两句\ndate: 2020-10-03 09:13:44\ntags:\n---\n\n\n**全文目录**\n\n1. {% post_link postgresql-optimizer-outline-1 《PostgreSQL优化器白话》- 为什么优化 %}\n2. {% post_link postgresql-optimizer-outline-2 《PostgreSQL优化器白话》- SQL进化史 %}\n3. {% post_link postgresql-optimizer-outline-3 《PostgreSQL优化器白话》- 提升！提升！ %}\n4. {% post_link postgresql-optimizer-outline-4 《PostgreSQL优化器白话》- 下推！下推！ %}\n5. {% post_link postgresql-optimizer-outline-5 《PostgreSQL优化器白话》- 严格要求自己 %}\n6. {% post_link postgresql-optimizer-outline-6 《PostgreSQL优化器白话》- 统计局旁的泉水 %}\n7. {% post_link postgresql-optimizer-outline-7 《PostgreSQL优化器白话》- 你走你的阳关道 %}\n8. {% post_link postgresql-optimizer-outline-8 《PostgreSQL优化器白话》- 算计不到就受穷 %}\n9. {% post_link postgresql-optimizer-outline-9 《PostgreSQL优化器白话》- 找饭店 %}\n\n《PostgreSQL优化器白话》暂时剧终了，我们基本上涵盖了大部分查询优化的概念，但是由于篇幅比较小，没有把细节说得特别到位，其中有大部分内容是摘抄自《PostgreSQL技术内幕：查询优化深度探索》一书的概念解释的部分，然后以小明、大明和牛二哥进行对话的方式展现出来，对于书中介绍的代码分析的部分以及比较深入的实现细节，由于不太容易通过对话的方式展示，所以在《PostgreSQL优化器白话》中没有涉及到。\n\n我已经尽我所能将这种对话的形式写的具有故事性一些，但是限于作者的语言能力，有些情节的切换上会显得比较生硬，在情节的处理上有时也相对比较单薄了，不过请放心，我即使再努力也写不出来世界名著，所以请不要鄙视我，因为我生气起来连我自己都害怕。","slug":"postgresql-optimizer-outline-10","published":1,"updated":"2020-10-03T01:29:32.000Z","_id":"ckfszn0xc0000rz9khcerd7qi","comments":1,"layout":"post","photos":[],"link":"","content":"<p><strong>全文目录</strong></p>\n<ol>\n<li><a href=\"/2020/08/02/postgresql-optimizer-outline-1/\" title=\"《PostgreSQL优化器白话》- 为什么优化\">《PostgreSQL优化器白话》- 为什么优化</a></li>\n<li><a href=\"/2020/08/02/postgresql-optimizer-outline-2/\" title=\"《PostgreSQL优化器白话》- SQL进化史\">《PostgreSQL优化器白话》- SQL进化史</a></li>\n<li><a href=\"/2020/08/02/postgresql-optimizer-outline-3/\" title=\"《PostgreSQL优化器白话》- 提升！提升！\">《PostgreSQL优化器白话》- 提升！提升！</a></li>\n<li><a href=\"/2020/08/05/postgresql-optimizer-outline-4/\" title=\"《PostgreSQL优化器白话》- 下推！下推！\">《PostgreSQL优化器白话》- 下推！下推！</a></li>\n<li><a href=\"/2020/08/14/postgresql-optimizer-outline-5/\" title=\"《PostgreSQL优化器白话》- 严格要求自己\">《PostgreSQL优化器白话》- 严格要求自己</a></li>\n<li><a href=\"/2020/10/03/postgresql-optimizer-outline-6/\" title=\"《PostgreSQL优化器白话》- 统计局旁的泉水\">《PostgreSQL优化器白话》- 统计局旁的泉水</a></li>\n<li><a href=\"/2020/10/03/postgresql-optimizer-outline-7/\" title=\"《PostgreSQL优化器白话》- 你走你的阳关道\">《PostgreSQL优化器白话》- 你走你的阳关道</a></li>\n<li><a href=\"/2020/10/03/postgresql-optimizer-outline-8/\" title=\"《PostgreSQL优化器白话》- 算计不到就受穷\">《PostgreSQL优化器白话》- 算计不到就受穷</a></li>\n<li><a href=\"/2020/10/03/postgresql-optimizer-outline-9/\" title=\"《PostgreSQL优化器白话》- 找饭店\">《PostgreSQL优化器白话》- 找饭店</a>\n\n</li>\n</ol>\n<p>《PostgreSQL优化器白话》暂时剧终了，我们基本上涵盖了大部分查询优化的概念，但是由于篇幅比较小，没有把细节说得特别到位，其中有大部分内容是摘抄自《PostgreSQL技术内幕：查询优化深度探索》一书的概念解释的部分，然后以小明、大明和牛二哥进行对话的方式展现出来，对于书中介绍的代码分析的部分以及比较深入的实现细节，由于不太容易通过对话的方式展示，所以在《PostgreSQL优化器白话》中没有涉及到。</p>\n<p>我已经尽我所能将这种对话的形式写的具有故事性一些，但是限于作者的语言能力，有些情节的切换上会显得比较生硬，在情节的处理上有时也相对比较单薄了，不过请放心，我即使再努力也写不出来世界名著，所以请不要鄙视我，因为我生气起来连我自己都害怕。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>全文目录</strong></p>\n<ol>\n<li><a href=\"/2020/08/02/postgresql-optimizer-outline-1/\" title=\"《PostgreSQL优化器白话》- 为什么优化\">《PostgreSQL优化器白话》- 为什么优化</a></li>\n<li><a href=\"/2020/08/02/postgresql-optimizer-outline-2/\" title=\"《PostgreSQL优化器白话》- SQL进化史\">《PostgreSQL优化器白话》- SQL进化史</a></li>\n<li><a href=\"/2020/08/02/postgresql-optimizer-outline-3/\" title=\"《PostgreSQL优化器白话》- 提升！提升！\">《PostgreSQL优化器白话》- 提升！提升！</a></li>\n<li><a href=\"/2020/08/05/postgresql-optimizer-outline-4/\" title=\"《PostgreSQL优化器白话》- 下推！下推！\">《PostgreSQL优化器白话》- 下推！下推！</a></li>\n<li><a href=\"/2020/08/14/postgresql-optimizer-outline-5/\" title=\"《PostgreSQL优化器白话》- 严格要求自己\">《PostgreSQL优化器白话》- 严格要求自己</a></li>\n<li><a href=\"/2020/10/03/postgresql-optimizer-outline-6/\" title=\"《PostgreSQL优化器白话》- 统计局旁的泉水\">《PostgreSQL优化器白话》- 统计局旁的泉水</a></li>\n<li><a href=\"/2020/10/03/postgresql-optimizer-outline-7/\" title=\"《PostgreSQL优化器白话》- 你走你的阳关道\">《PostgreSQL优化器白话》- 你走你的阳关道</a></li>\n<li><a href=\"/2020/10/03/postgresql-optimizer-outline-8/\" title=\"《PostgreSQL优化器白话》- 算计不到就受穷\">《PostgreSQL优化器白话》- 算计不到就受穷</a></li>\n<li><a href=\"/2020/10/03/postgresql-optimizer-outline-9/\" title=\"《PostgreSQL优化器白话》- 找饭店\">《PostgreSQL优化器白话》- 找饭店</a>\n\n</li>\n</ol>\n<p>《PostgreSQL优化器白话》暂时剧终了，我们基本上涵盖了大部分查询优化的概念，但是由于篇幅比较小，没有把细节说得特别到位，其中有大部分内容是摘抄自《PostgreSQL技术内幕：查询优化深度探索》一书的概念解释的部分，然后以小明、大明和牛二哥进行对话的方式展现出来，对于书中介绍的代码分析的部分以及比较深入的实现细节，由于不太容易通过对话的方式展示，所以在《PostgreSQL优化器白话》中没有涉及到。</p>\n<p>我已经尽我所能将这种对话的形式写的具有故事性一些，但是限于作者的语言能力，有些情节的切换上会显得比较生硬，在情节的处理上有时也相对比较单薄了，不过请放心，我即使再努力也写不出来世界名著，所以请不要鄙视我，因为我生气起来连我自己都害怕。</p>\n"}],"PostAsset":[{"_id":"source/_posts/postgresql-optimizer-outline-2/1.jpg","slug":"1.jpg","post":"ckdchg8je0002r2s686meddyz","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-2/2.jpg","slug":"2.jpg","post":"ckdchg8je0002r2s686meddyz","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-4/1.png","slug":"1.png","post":"ckdgkb6d30000mvs61pjfd9kp","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-4/2.png","slug":"2.png","post":"ckdgkb6d30000mvs61pjfd9kp","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-7/1.jpg","slug":"1.jpg","post":"ckfszbzyj0000ro9kgeuy15hy","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-7/2.png","slug":"2.png","post":"ckfszbzyj0000ro9kgeuy15hy","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-7/3.png","slug":"3.png","post":"ckfszbzyj0000ro9kgeuy15hy","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-7/4.png","slug":"4.png","post":"ckfszbzyj0000ro9kgeuy15hy","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-7/5.png","slug":"5.png","post":"ckfszbzyj0000ro9kgeuy15hy","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-7/6.png","slug":"6.png","post":"ckfszbzyj0000ro9kgeuy15hy","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-9/1.png","slug":"1.png","post":"ckfszbzyo0003ro9k3ejk08ql","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-9/2.png","slug":"2.png","post":"ckfszbzyo0003ro9k3ejk08ql","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-9/3.png","slug":"3.png","post":"ckfszbzyo0003ro9k3ejk08ql","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-9/4.png","slug":"4.png","post":"ckfszbzyo0003ro9k3ejk08ql","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"ckfszbzyj0000ro9kgeuy15hy","tag_id":"ckfszbzyl0002ro9kanjefekl","_id":"ckfszbzyp0005ro9kggb76qu5"},{"post_id":"ckfszbzyk0001ro9kakdf920l","tag_id":"ckfszbzyp0004ro9k9lae9crw","_id":"ckfszbzyq0007ro9keajgbmig"},{"post_id":"ckfszbzyo0003ro9k3ejk08ql","tag_id":"ckfszbzyp0006ro9k9jwea22m","_id":"ckfszbzyq0008ro9k7gra9xwm"}],"Tag":[{"name":"路径 Path 顺序扫描 索引扫描 位图扫描 Join","_id":"ckfszbzyl0002ro9kanjefekl"},{"name":"代价 启动代价 IO代价 CPU代价","_id":"ckfszbzyp0004ro9k9lae9crw"},{"name":"动态规划 自底向上 自顶向下","_id":"ckfszbzyp0006ro9k9jwea22m"}]}}