{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/postgresql-optimizer-outline-1.md","hash":"ccb4d8a426b4ca8a11da8960cf456c605796ee69","modified":1596329852000},{"_id":"source/_posts/postgresql-optimizer-outline-2.md","hash":"caff7c412fb258307664f7bc5d1f678f80d78fa7","modified":1596332606000},{"_id":"source/_posts/postgresql-optimizer-outline-3.md","hash":"da8bb9ec39a5f72843a2e9a571aa7a1bb4028c94","modified":1596333291000},{"_id":"source/about/index.md","hash":"d61fe42c8566ae29da7831bda1e50e9eaba884a8","modified":1626738918000},{"_id":"source/.DS_Store","hash":"db36e4842436bc92b1e74de244af8ecf702c28b9","modified":1612599070000},{"_id":"source/_posts/.DS_Store","hash":"29a3cdafe44f8e7a9a2b2809821a5ff8db3839f2","modified":1628178048000},{"_id":"source/CNAME","hash":"1abf4ed9424d03bbf169fb354620f024705bde24","modified":1596323598000},{"_id":"source/_posts/postgresql-optimizer-outline-2/1.jpg","hash":"7dd5636eac16621f1e2923c163c18983a64bf590","modified":1596331070000},{"_id":"source/_posts/postgresql-optimizer-outline-2/2.jpg","hash":"8f1628d4fd45d15e91cf12ae9f5793cacbb0423c","modified":1596331070000},{"_id":"themes/next/.DS_Store","hash":"34aaf2afd98560146e0116b4cea9df723a75bf6b","modified":1612599042000},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1596297190000},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1596297190000},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1596297190000},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1596297190000},{"_id":"themes/next/_config.yml","hash":"ce09b154d140763df464cdb536ac01b2f3f2ea3e","modified":1596931447000},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1596297190000},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1596297190000},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1596297190000},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1596297190000},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1596297190000},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1596297190000},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1596297190000},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1596297190000},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1596297190000},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1596297190000},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1596297190000},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1596297190000},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1596297190000},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1596297190000},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1596297190000},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1596297190000},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1596297190000},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1596297190000},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1596297190000},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1596297190000},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1596297190000},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1596297190000},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1596297190000},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1596297190000},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1596297190000},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1596297190000},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1596297190000},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1596297190000},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1596297190000},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1596297190000},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1596297190000},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1596297190000},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1596297190000},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1596297190000},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1596297190000},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1596297190000},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1596297190000},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1596297190000},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1596297190000},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1596297190000},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1596297190000},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1596297190000},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1596297190000},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1596297190000},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1596297190000},{"_id":"themes/next/source/.DS_Store","hash":"42a735759b4eff69f4200db39d8094082ee38bf7","modified":1596335943000},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1596297190000},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1596297190000},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1596297190000},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1596297190000},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1596297190000},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1596297190000},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1596297190000},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1596297190000},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1596297190000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1596297190000},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1596297190000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1596297190000},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1596297190000},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1596297190000},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1596297190000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1596297190000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"e5a2bdf45fde7cea9cb03993f5a0fd960326ed5d","modified":1596297190000},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1596297190000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1596297190000},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1596297190000},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1596297190000},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1596297190000},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1596297190000},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1596297190000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1596297190000},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1596297190000},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1596297190000},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1596297190000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1596297190000},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1596297190000},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1596297190000},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1596297190000},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1596297190000},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1596297190000},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1596297190000},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1596297190000},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1596297190000},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1596297190000},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1596297190000},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1596297190000},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1596297190000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1596297190000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1596297190000},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1596297190000},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1596297190000},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1596297190000},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1596297190000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1596297190000},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1596297190000},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1596297190000},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1596297190000},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1596297190000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"c98146a0f81666956272fe692c1958fd1cf3d9a1","modified":1596335419000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1596297190000},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1596297190000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1596297190000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1596297190000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1596297190000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1596297190000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1596297190000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"ab599db2348f43f2cd71995e4d27e784847605aa","modified":1596335571000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1596297190000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1596297190000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"25dffea8b5603caf2ea77feb90bd9c1e86738713","modified":1596335608000},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1596297190000},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1596297190000},{"_id":"themes/next/source/js/utils.js","hash":"2c6e6b4d9a592fbb4bf04689524db2cdfcd94ca7","modified":1596297190000},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1596297190000},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1596297190000},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1596297190000},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1596297190000},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1596297190000},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1596297190000},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1596297190000},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1596297190000},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1596297190000},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1596297190000},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1596297190000},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1596297190000},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1596297190000},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1596297190000},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1596297190000},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1596297190000},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1596297190000},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1596297190000},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1596297190000},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1596297190000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1596297190000},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1596297190000},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1596297190000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1596297190000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1596297190000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1596297190000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1596297190000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1596297190000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1596297190000},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1596297190000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1596297190000},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1596297190000},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1596297190000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1596297190000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1596297190000},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1596297190000},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1596297190000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1596297190000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1596297190000},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1596297190000},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1596297190000},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1596297190000},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1596297190000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1596297190000},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1596297190000},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1596297190000},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1596297190000},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1596297190000},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1596297190000},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1596297190000},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1596297190000},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1596297190000},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1596297190000},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1596297190000},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1596297190000},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1596297190000},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1596297190000},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1596297190000},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1596297190000},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1596297190000},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1596297190000},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1596297190000},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1596297190000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1596297190000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1596297190000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1596297190000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1596297190000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1596297190000},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1596297190000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1596297190000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1596297190000},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1596297190000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1596297190000},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1596297190000},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1596297190000},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1596297190000},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1596297190000},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1596297190000},{"_id":"themes/next/source/images/avatar.jpg","hash":"bd42bc2f990d78707c488b99d0d21c3dc587d30e","modified":1596328101000},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1596297190000},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1596297190000},{"_id":"themes/next/source/images/logo.svg","hash":"5a4f99b6915fe7f59e4d1f197ce0d979c57872b2","modified":1596336066000},{"_id":"public/about/index.html","hash":"bcb9aefafab8f83d26b7c7df1f8fe64b9b7f17be","modified":1633614169094},{"_id":"public/archives/index.html","hash":"68e462533a6248af640dd31d5dcbbf8612c7bdba","modified":1633614169094},{"_id":"public/archives/2020/index.html","hash":"d9e7f3e75ca5f5af6b71de507388465cbe5d6e48","modified":1633614169094},{"_id":"public/archives/2020/08/index.html","hash":"689339a48a0ebc37646bf39a37f56ab543ac4d41","modified":1633614169094},{"_id":"public/index.html","hash":"5ff33947d293e0720dfc302dff9c10e03993686d","modified":1633614169094},{"_id":"public/2020/08/02/postgresql-optimizer-outline-3/index.html","hash":"fcc1d8c6b5a9edcc284e461e4130253a8fdbb594","modified":1633614169094},{"_id":"public/2020/08/02/postgresql-optimizer-outline-2/index.html","hash":"594c255dfbd623699b8f4b92e06948bb9db62eda","modified":1633614169094},{"_id":"public/2020/08/02/postgresql-optimizer-outline-1/index.html","hash":"d2480a215b08a49e4cce1969cf68b92d692e9f15","modified":1633614169094},{"_id":"public/CNAME","hash":"1abf4ed9424d03bbf169fb354620f024705bde24","modified":1596336357102},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1596336357102},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1596336357102},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1596336357102},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1596336357102},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1596336357102},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1596336357102},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1596336357102},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1596336357102},{"_id":"public/images/favicon-16x16-next.png","hash":"25dffea8b5603caf2ea77feb90bd9c1e86738713","modified":1596336357102},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1596336357102},{"_id":"public/images/favicon-32x32-next.png","hash":"ab599db2348f43f2cd71995e4d27e784847605aa","modified":1596336357102},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1596336357102},{"_id":"public/2020/08/02/postgresql-optimizer-outline-2/1.jpg","hash":"7dd5636eac16621f1e2923c163c18983a64bf590","modified":1596336357102},{"_id":"public/2020/08/02/postgresql-optimizer-outline-2/2.jpg","hash":"8f1628d4fd45d15e91cf12ae9f5793cacbb0423c","modified":1596336357102},{"_id":"public/images/apple-touch-icon-next.png","hash":"c98146a0f81666956272fe692c1958fd1cf3d9a1","modified":1596336357102},{"_id":"public/images/avatar.jpg","hash":"bd42bc2f990d78707c488b99d0d21c3dc587d30e","modified":1596336357102},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1596336357102},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1596336357102},{"_id":"public/images/logo.svg","hash":"5a4f99b6915fe7f59e4d1f197ce0d979c57872b2","modified":1596336357102},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1596336357102},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1596336357102},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1596336357102},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1596336357102},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1596336357102},{"_id":"public/js/utils.js","hash":"2c6e6b4d9a592fbb4bf04689524db2cdfcd94ca7","modified":1596336357102},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1596336357102},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1596336357102},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1596336357102},{"_id":"public/css/main.css","hash":"38afd92942bc1de414d27567b614c311d1083e5c","modified":1596336357102},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1596336357102},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1596336357102},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1596336357102},{"_id":"source/_posts/postgresql-optimizer-outline-4.md","hash":"2db530cffe38825f62b67ca207b720f17ec5b799","modified":1596583097000},{"_id":"source/_posts/postgresql-optimizer-outline-4/1.png","hash":"8c8c6bf54553e00c4721d0312d99053203076e86","modified":1596582921000},{"_id":"source/_posts/postgresql-optimizer-outline-4/2.png","hash":"fb15c7b6a05bd9b50f72e37899a1e23aada14e9b","modified":1596582921000},{"_id":"public/2020/08/05/postgresql-optimizer-outline-4/index.html","hash":"37ec8b9f94b5f96b5a16cc22b97754a68d41f88a","modified":1633614169094},{"_id":"public/2020/08/05/postgresql-optimizer-outline-4/2.png","hash":"fb15c7b6a05bd9b50f72e37899a1e23aada14e9b","modified":1596583024481},{"_id":"public/2020/08/05/postgresql-optimizer-outline-4/1.png","hash":"8c8c6bf54553e00c4721d0312d99053203076e86","modified":1596583024481},{"_id":"source/_posts/postgresql-optimizer-outline-5.md","hash":"1db7bc5a33099f38a0ab397ce25287fd20a2aa3a","modified":1597419918000},{"_id":"public/2020/08/14/postgresql-optimizer-outline-5/index.html","hash":"6d7c6742a28bc91bcff78457d290225b068b52e3","modified":1633614169094},{"_id":"source/_posts/postgresql-optimizer-outline-6.md","hash":"e1ef8bcea928e0252cac28a5f199b17ab7eeba07","modified":1601685354000},{"_id":"public/2020/10/03/postgresql-optimizer-outline-6/index.html","hash":"1e4e1151b68ffec0c8bdfdc8075d378f66e83b4e","modified":1633614169094},{"_id":"public/archives/2020/10/index.html","hash":"29bb1e59a6c701cab0b49c88d2aea214a28fc3eb","modified":1633614169094},{"_id":"source/_posts/postgresql-optimizer-outline-8.md","hash":"7138a2d74d8b8b92372ee6a6f84ca302a9e056d2","modified":1601686863000},{"_id":"source/_posts/postgresql-optimizer-outline-9.md","hash":"5cbd63018518f572d6cd8d1100972f54686ba4cc","modified":1601687609000},{"_id":"source/_posts/postgresql-optimizer-outline-7/1.jpg","hash":"50c5074e7dbf176d1ebd5b45b5e5a941147126e8","modified":1527260674000},{"_id":"source/_posts/postgresql-optimizer-outline-7/3.png","hash":"6a34d81f9a58d35f6656d8b30ff603afc13eb151","modified":1527260687000},{"_id":"source/_posts/postgresql-optimizer-outline-9/1.png","hash":"7c1477a5ee41d9d541cceaf59f278b1460a857ee","modified":1527260717000},{"_id":"source/_posts/postgresql-optimizer-outline-9/2.png","hash":"1f58087cc2c9f30dba34d0bc6abe6ad34f5fb345","modified":1527260724000},{"_id":"source/_posts/postgresql-optimizer-outline-9/4.png","hash":"404e59978b659c9cf7d56d8dd456851480d0017d","modified":1527260736000},{"_id":"source/_posts/postgresql-optimizer-outline-7/.DS_Store","hash":"872a5b56a7f41a1fc54298a25149a150f2078d00","modified":1601686554000},{"_id":"source/_posts/postgresql-optimizer-outline-9/.DS_Store","hash":"764ae0cbe6b3609133570242eaa44dde709424d4","modified":1601687624000},{"_id":"source/_posts/postgresql-optimizer-outline-7.md","hash":"12b80578f6b1336a487c5ffa3f79d81926ba9f36","modified":1601687567000},{"_id":"source/_posts/postgresql-optimizer-outline-7/2.png","hash":"a73527127e774ddeae33912214b7f04052e7476a","modified":1527260681000},{"_id":"source/_posts/postgresql-optimizer-outline-7/4.png","hash":"e37eef8c2a5e6186fb13c32473984531afcd3301","modified":1527260695000},{"_id":"source/_posts/postgresql-optimizer-outline-7/5.png","hash":"fdc70d5ddabe15a5e324a26944fec62b3a8a3c38","modified":1527260701000},{"_id":"source/_posts/postgresql-optimizer-outline-7/6.png","hash":"16838273101e54a62b7c194c439976c04c031ced","modified":1527260707000},{"_id":"source/_posts/postgresql-optimizer-outline-9/3.png","hash":"84b7b9c69cc069c542bec3c6a48bf9efc6a356da","modified":1527260730000},{"_id":"public/tags/路径-Path-顺序扫描-索引扫描-位图扫描-Join/index.html","hash":"5f8f0b9dfbcacbb6a8f7c0c4c086ca7a4eec9d43","modified":1633614169094},{"_id":"public/tags/代价-启动代价-IO代价-CPU代价/index.html","hash":"36c863be121159f20b074491b9ff8c988f5c5a64","modified":1633614169094},{"_id":"public/tags/动态规划-自底向上-自顶向下/index.html","hash":"7aa3c98c461d049ec6aaab104a4e0f1c11ad3306","modified":1633614169094},{"_id":"public/2020/10/03/postgresql-optimizer-outline-9/index.html","hash":"e78c1d0ccdb558eb9ff9eeeb83e1ee5e2fb5d898","modified":1633614169094},{"_id":"public/2020/10/03/postgresql-optimizer-outline-8/index.html","hash":"97de29c4850415e383987ed58d0b0ea8c809c65e","modified":1633614169094},{"_id":"public/2020/10/03/postgresql-optimizer-outline-7/index.html","hash":"e21c65db2acd293fc30ea83280c063749c40f4f4","modified":1633614169094},{"_id":"public/2020/10/03/postgresql-optimizer-outline-7/1.jpg","hash":"50c5074e7dbf176d1ebd5b45b5e5a941147126e8","modified":1601687415870},{"_id":"public/2020/10/03/postgresql-optimizer-outline-9/1.png","hash":"7c1477a5ee41d9d541cceaf59f278b1460a857ee","modified":1601687415870},{"_id":"public/2020/10/03/postgresql-optimizer-outline-9/2.png","hash":"1f58087cc2c9f30dba34d0bc6abe6ad34f5fb345","modified":1601687415870},{"_id":"public/2020/10/03/postgresql-optimizer-outline-9/4.png","hash":"404e59978b659c9cf7d56d8dd456851480d0017d","modified":1601687415870},{"_id":"public/2020/10/03/postgresql-optimizer-outline-9/3.png","hash":"84b7b9c69cc069c542bec3c6a48bf9efc6a356da","modified":1601687415870},{"_id":"public/2020/10/03/postgresql-optimizer-outline-7/3.png","hash":"6a34d81f9a58d35f6656d8b30ff603afc13eb151","modified":1601687415870},{"_id":"public/2020/10/03/postgresql-optimizer-outline-7/4.png","hash":"e37eef8c2a5e6186fb13c32473984531afcd3301","modified":1601687415870},{"_id":"public/2020/10/03/postgresql-optimizer-outline-7/5.png","hash":"fdc70d5ddabe15a5e324a26944fec62b3a8a3c38","modified":1601687415870},{"_id":"public/2020/10/03/postgresql-optimizer-outline-7/6.png","hash":"16838273101e54a62b7c194c439976c04c031ced","modified":1601687415870},{"_id":"public/2020/10/03/postgresql-optimizer-outline-7/2.png","hash":"a73527127e774ddeae33912214b7f04052e7476a","modified":1601687415870},{"_id":"source/_posts/postgresql-optimizer-outline-10.md","hash":"49dfab0578d37dd292f589d6c6014f0dc6e067f0","modified":1601688572000},{"_id":"public/2020/10/03/postgresql-optimizer-outline-10/index.html","hash":"21d7c6aa32a4591acdeddbc49c3cd7c4316a9f84","modified":1633614169094},{"_id":"source/_posts/postgresql-lock-spinlock-implement.md","hash":"ea26ade52e5315b70bad2ca160a8aa8a5b66bfa6","modified":1612599947000},{"_id":"public/archives/page/2/index.html","hash":"ac0baa5b6370262688ae4cabb680ff280316ebb8","modified":1633614169094},{"_id":"public/archives/2021/index.html","hash":"4394bad57aa61601750a0822e0c53574ec5e0917","modified":1633614169094},{"_id":"public/archives/2021/02/index.html","hash":"489f9b0c971aa450dc21f6a827b46fa3f2c0294c","modified":1633614169094},{"_id":"public/page/2/index.html","hash":"e17ac7dbec05197ba7048df0c36bc3f96ea6ddde","modified":1633614169094},{"_id":"public/tags/lock-spinlock-transaction-postgresql/index.html","hash":"ca19ccf675b60f3e2bd0c26ef1603c5305a65be8","modified":1633614169094},{"_id":"public/2021/02/06/postgresql-lock-spinlock-implement/index.html","hash":"b6dff1303ed28b55f28ddd1f33a489a6e7d1634d","modified":1633614169094},{"_id":"source/_posts/postgresql-lock-lwlock-implement/lockstate.jpg","hash":"b862e97340e5c8ce6ca95a0b4f429ba7b3f8b13d","modified":1553328346000},{"_id":"source/_posts/postgresql-lock-lwlock-implement/sxlock.jpg","hash":"e2c654dc3534222f8c9cca7151ca233b9e92e511","modified":1553438984000},{"_id":"source/_posts/postgresql-lock-lwlock-implement/waitqueue.jpg","hash":"88b3b3119a54e1ab17a0cd8121c292a028b0a217","modified":1554002287000},{"_id":"source/_posts/postgresql-lock-lwlock-implement.md","hash":"60c69cd65a66501b3deb1d499ea7a390a0c0b6e5","modified":1626738251000},{"_id":"public/2021/07/20/postgresql-lock-lwlock-implement/index.html","hash":"0d4050d8ed1d59b5eebcb9c4953973eb1f619ab0","modified":1633614169094},{"_id":"public/archives/2021/07/index.html","hash":"a6770acde5472c5b763e19e556ff802feb85d67c","modified":1633614169094},{"_id":"public/tags/lock-lwlock-transaction-postgresql/index.html","hash":"177f40dfc2deb3fcea1ab3078682a14c47109f28","modified":1633614169094},{"_id":"public/2021/07/20/postgresql-lock-lwlock-implement/lockstate.jpg","hash":"b862e97340e5c8ce6ca95a0b4f429ba7b3f8b13d","modified":1626738144043},{"_id":"public/2021/07/20/postgresql-lock-lwlock-implement/sxlock.jpg","hash":"e2c654dc3534222f8c9cca7151ca233b9e92e511","modified":1626738144043},{"_id":"public/2021/07/20/postgresql-lock-lwlock-implement/waitqueue.jpg","hash":"88b3b3119a54e1ab17a0cd8121c292a028b0a217","modified":1626738144043},{"_id":"source/_posts/postgresql-transaction-internals-introduce.md","hash":"e7fd82aee4a2dace7ad79ca59f6e445a159b24f8","modified":1628179115000},{"_id":"source/_posts/postgresql-transaction-internals-introduce/introduce.jpg","hash":"c256a598269c08804ed69bf3328301985fb178ed","modified":1627911924000},{"_id":"public/archives/2021/08/index.html","hash":"c3f1152a4cca9b374df7a15e2aa1b47c650af44a","modified":1633614169094},{"_id":"public/2021/08/02/postgresql-transaction-internals-introduce/index.html","hash":"68b98f39d7fa970ece69004fc577f673ac0bcd40","modified":1633614169094},{"_id":"public/tags/transaction-事务-新书-技术内幕-PostgreSQL/index.html","hash":"f70e70d64ec5b8f1cfd5deb99e8dd0c9e0915327","modified":1633614169094},{"_id":"public/2021/08/02/postgresql-transaction-internals-introduce/introduce.jpg","hash":"c256a598269c08804ed69bf3328301985fb178ed","modified":1627913400155},{"_id":"source/_posts/database-developer-say-no-to-us/have_no_tech.jpeg","hash":"ad8ef37dedc3e0610e221e498c6be114a82638d5","modified":1628177857000},{"_id":"source/_posts/postgresql-transaction-internals-introduce/.DS_Store","hash":"20b8c643b786d3639845ae6ca7d871362eb0e518","modified":1628178116000},{"_id":"source/_posts/database-developer-say-no-to-us.md","hash":"bceeb32211c1e14c6dd7dda029a841c775d6279d","modified":1628179260000},{"_id":"source/_posts/database-developer-say-no-to-us/buy_link.jpeg","hash":"8bf46356b49f0aedbb773a73990a7be589747902","modified":1628177622000},{"_id":"public/2021/08/05/database-developer-say-no-to-us/index.html","hash":"ee34abfd3fabf129733680ab53b7b08bbe66b321","modified":1633614169094},{"_id":"public/tags/database-transaction/index.html","hash":"51d892c2157e677fb8b85ab8fe4dd6a13a0fe737","modified":1633614169094},{"_id":"public/2021/08/05/database-developer-say-no-to-us/have_no_tech.jpeg","hash":"ad8ef37dedc3e0610e221e498c6be114a82638d5","modified":1628178302551},{"_id":"public/2021/08/05/database-developer-say-no-to-us/buy_link.jpeg","hash":"8bf46356b49f0aedbb773a73990a7be589747902","modified":1628178302551},{"_id":"source/_posts/postgresql-lock-vedio.md","hash":"e80c9e673b51ba16a3de29b166251bf4eee477da","modified":1633614145000},{"_id":"public/2021/10/07/postgresql-lock-vedio/index.html","hash":"675fcaa5de773c90020731bbfd625e880260ac37","modified":1633614169094},{"_id":"public/archives/2021/10/index.html","hash":"afa29e072679ec7db6caf35fec255c5cd76b6cad","modified":1633614169094},{"_id":"public/tags/PostgreSQL-事务-锁-数据库/index.html","hash":"6fddff022f9f9051f37283e8881ae12bd44aa8cb","modified":1633614169094}],"Category":[],"Data":[],"Page":[{"title":"张树杰","date":"2020-08-02T02:00:11.000Z","_content":"\n\n* 《PostgreSQL技术内幕：查询优化深度探索》\n* 《PostgreSQL技术内幕：事务处理深度探索》\n","source":"about/index.md","raw":"---\ntitle: 张树杰\ndate: 2020-08-02 10:00:11\n---\n\n\n* 《PostgreSQL技术内幕：查询优化深度探索》\n* 《PostgreSQL技术内幕：事务处理深度探索》\n","updated":"2021-07-19T23:55:18.000Z","path":"about/index.html","_id":"ckdchg8j80000r2s6dnmidrbh","comments":1,"layout":"page","content":"<ul>\n<li>《PostgreSQL技术内幕：查询优化深度探索》</li>\n<li>《PostgreSQL技术内幕：事务处理深度探索》</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>《PostgreSQL技术内幕：查询优化深度探索》</li>\n<li>《PostgreSQL技术内幕：事务处理深度探索》</li>\n</ul>\n"}],"Post":[{"title":"PostgreSQL优化器白话(1) - 为什么优化","date":"2020-08-02T00:35:06.000Z","_content":"\n\n小明考上了北清大学的计算机研究生，今年学校开了数据库原理的课程，小明对查询优化的部分不是很理解，虽然已经使出了洪荒之力，仍然觉得其中的部分原理有些晦涩难懂，于是小明打算问一下自己的哥哥大明，大明是一位资深的数据库内核开发的老码农，对Greenplum/HAWQ数据库有多年的内核开发经验<!-- more -->，厚厚眼镜片上的圈圈像年轮一样深深的见证着大明十多年的从业经历，知道小明要来问问题，大明有点紧张，虽然自己做数据库内核好多年了，但是对优化器研究却不深入，如果被小明这样的小菜鸟问倒就尴尬了，于是大明只好临时抱佛脚，拿出了好多年不看的《数据库系统实现》啃了起来。\n\n小明提出的第一个问题是：“为什么数据库要进行查询优化？”\n\n大明推了推鼻梁上的眼镜，点上了一根中华深吸一口，火红的烟头奋力燃烧，由明及暗，几片烟灰飘飘渺渺的散落下来，又和大明吐出的云雾交缠在一起，即轻盈又律动，大明弹了弹烟灰，慢条斯理的说：“不止是数据库要进行优化，基本上所有的编程语言在编译的时候都会优化，比如你在编译C语言的时候，可以通过编译选项-o来指定进行哪个级别的优化，但是查询数据库的查询优化和C语言的优化还有些区别。”\n\n“有哪些区别呢？”大明停顿了一下，凝视着小明，仿佛期望小明给出答案，或者是给小明腾挪出足够思考的空间，三五秒之后大明又自问自答道：“C语言是过程化语言，你已经指定好了需要执行的每一个步骤，但是SQL是描述性语言，它只指定了WHAT，而没有指定HOW，这样它的优化空间就大了，你说是不是？”\n\n小明点了点头说：“对，也就是说条条大路通罗马，它比过程语言的选择更多，是不是这样？”大明笑道：“孺子可教也。虽然我们知道它的优化空间大，但具体如何优化呢？”\n\n说着大明将身子向沙发里靠以靠，翘上二郎腿继续说：“通常来说分成两个层面，一个是基于规则的优化，另一个是基于代价的优化，基于规则的优化也可以叫逻辑优化或者规则优化，基于代价的优化也可以叫物理优化或者代价优化。”大明边说边用手比划着，手里的烟火也欢快的跳跃着。\n\n“那为什么要进行这样的区分呢？优化就优化嘛，何必还分什么规则和代价呢？”，小明问道。\n\n“分层不分层不是重点，有些优化器层次分的清楚点，有些优化器层次分的就不那么清楚，都只是优化手段而已。”大明感到有点心虚，再这么问下去恐怕要被问住，于是试图引开话题：“我们继续说说SQL语言吧，我们说它是一种介于关系演算和关系代数之间的语言，关系演算和关系代数你看过吧？”\n\n小明想了想，好像自己上课的时候老师说过关系代数，但是没有说关系演算，于是说：“接触过一点，但也不是特别明白。”大明得意的说：“关系演算是纯描述性的语言，而关系代数呢，则包含了一些基本的关系操作，SQL主要借鉴的是关系演算，也包含了关系代数的一部分特点。”\n\n大明看小明有点懵，顿了一下，然后继续说道：“你们上课的时候老师有没有说过关系代数的基本操作？”小明想了一下说：“好像说了，有投影、选择、连接、交集、差集这几个。”大明点点头说：“对的，还可以有一个叫重命名的，一共6个基本操作，另外结合实际应用在这些基本操作之上又扩展出了外连接、半连接、聚集操作、分组操作等等。”\n\n大明又深吸了一口烟，优雅的吐了个烟圈，继续说道：“SQL语句虽然是描述性的，但是我们可以把它转化成一个关系代数表达式，而关系代数中呢，又有一些等价的规则，这样我们就能结合这些等价规则对关系代数表达式进行等价的转换。”\n\n“进行等价转换的目的是找到性能更好的代数表达式吧？”小明问。\n\n“对，就是这样。”大明投来赞许的目光。\n\n“那么如何确定等价变换之后的表达式就能变得比变换之前性能更好呢？或者说为什么我们要进行这样的等价变换，而不是使用原来的表达式呢？”\n\n大明愣了一下，仿佛没有想到小明会提出这样的问题，但是基于自己多年的忽悠经验，他定了定神，回答道：“这既有经验的成分，也有量化的考虑。例如将选择操作下推，就能优先过滤数据，那么表达式的上层计算结点就能降低计算量，因此很容易可以知道是能降低代价的。再例如我们通常会对相关的子查询进行提升，这是因为如果不提升这种子查询，那么它执行的时候就会产生一个嵌套循环，这种嵌套循环的执行代价是O(N^2)，这种复杂度已经是最坏的情况了，提升上来至少不会比它差，因此提升上来是有价值的。”大明心里对自己的临危不乱暗暗点了个赞。\n\n大明看小明没有提问，继续说道：“这些基于关系代数等价规则做等价变换的优化，就是基于规则的优化，当然数据库本身也会结合实际的经验，产生一些优化规则，比如外连接消除，因为外连接优化起来不太方便，如果能把它消除掉，我们就有了更大的优化空间，这些统统都是基于规则的优化。同时这些都是建立在逻辑操作符上的优化，这也是为什么基于规则的优化也叫做逻辑优化。”\n\n小明想了想，自己好像对逻辑操作符不太理解，连忙问：“逻辑操作符是啥？既然有物理优化，难道还有物理操作符吗？”\n\n大明看自己的烟已经烧的只剩下过滤嘴了，连忙把烟头扔到烟灰缸，伸个懒腰继续说：“比如说吧，你在SQL语句里写上了两个表要做一个左外连接，那么数据库怎么来做这个左外连接呢？”\n\n小明一头雾水的摇摇头，对大明投出了期待的眼神。\n\n大明自问自答的继续说道：“数据库说我也不知道啊，你说的左外连接意思我懂，但我也不知道怎么实现啊？你需要告诉我实现方法啊，因此优化器还承担了一个任务，就是告诉执行器，怎么来实现一个左外连接。”\n\n大明一边说，一边从茶几上把烟拿起来，准备再抽一根，却尴尬的发现，烟盒里一根烟都没有了，大明把空烟盒弹进垃圾桶，继续说：“数据库有哪些方法来实现一个左外连接呢？它可以用嵌套循环连接、哈希连接、归并连接等等，注意了，重要的事情说三遍，你看内连接、外连接是连接操作，嵌套循环连接、归并连接等也叫连接，但内连接、外连接这些就是逻辑操作符，而嵌套循环连接、归并连接这些就是物理操作符。所以你说对了，物理优化就是建立在物理操作符上的优化。”\n\n大明又问小明：“你要从北京去上海，你说你怎么去？”\n\n小明说：“坐高铁啊，又快又方便。”\n\n大明继续问：“做高铁先去广州，然后倒车到上海行不行？”\n\n小明说：“有点扎心了，这不是吃饱了撑的吗？”\n\n大明追问：“为什么？”\n\n小明说：“很明显，我有直达的高铁，即节省时间，又节省费用，先去广州再倒车？我脑子瓦特了？！”\n\n大明笑了笑说：“不知不觉之间，你的大脑就建立了一个代价模型，那就是性价比，优化器作为数据库的大脑，也需要建立代价模型，对物理操作符计算代价，然后筛选出最优的物理操作符来，因此基于代价的优化是建立在物理操作符上的优化，所以也叫物理优化。”\n\n小明觉得似乎懂了：“公司派我去上海出差就是一个逻辑操作符，它和我们写一个SQL语句要求数据库对两个表做左外连接类似，而去上海的实际路径有很多种，这些就像是物理操作符，我们对这些实际的物理路径计算代价之后，就可以选出来最好的路径了。”\n\n大明掏出手机，分别打开了白兔地图APP和高达地图APP，输入了北京到上海的信息，然后拿给小明看，小明发现两家APP给出的最优路径是不一样的。小明若有所思的说：“看来代价模型很重要，代价模型是不是准确决定了最优路径选择的是不是准确。”\n大明一拍大腿，笑着说：“太对了，所以我作为一个数据库内核的资深开发人员，需要不断的调整优化器的代价模型，以期望获得一个相对稳定的代价模型，不过仍然是任重道远啊。”\n","source":"_posts/postgresql-optimizer-outline-1.md","raw":"---\ntitle: PostgreSQL优化器白话(1) - 为什么优化\ndate: 2020-08-02 08:35:06\n---\n\n\n小明考上了北清大学的计算机研究生，今年学校开了数据库原理的课程，小明对查询优化的部分不是很理解，虽然已经使出了洪荒之力，仍然觉得其中的部分原理有些晦涩难懂，于是小明打算问一下自己的哥哥大明，大明是一位资深的数据库内核开发的老码农，对Greenplum/HAWQ数据库有多年的内核开发经验<!-- more -->，厚厚眼镜片上的圈圈像年轮一样深深的见证着大明十多年的从业经历，知道小明要来问问题，大明有点紧张，虽然自己做数据库内核好多年了，但是对优化器研究却不深入，如果被小明这样的小菜鸟问倒就尴尬了，于是大明只好临时抱佛脚，拿出了好多年不看的《数据库系统实现》啃了起来。\n\n小明提出的第一个问题是：“为什么数据库要进行查询优化？”\n\n大明推了推鼻梁上的眼镜，点上了一根中华深吸一口，火红的烟头奋力燃烧，由明及暗，几片烟灰飘飘渺渺的散落下来，又和大明吐出的云雾交缠在一起，即轻盈又律动，大明弹了弹烟灰，慢条斯理的说：“不止是数据库要进行优化，基本上所有的编程语言在编译的时候都会优化，比如你在编译C语言的时候，可以通过编译选项-o来指定进行哪个级别的优化，但是查询数据库的查询优化和C语言的优化还有些区别。”\n\n“有哪些区别呢？”大明停顿了一下，凝视着小明，仿佛期望小明给出答案，或者是给小明腾挪出足够思考的空间，三五秒之后大明又自问自答道：“C语言是过程化语言，你已经指定好了需要执行的每一个步骤，但是SQL是描述性语言，它只指定了WHAT，而没有指定HOW，这样它的优化空间就大了，你说是不是？”\n\n小明点了点头说：“对，也就是说条条大路通罗马，它比过程语言的选择更多，是不是这样？”大明笑道：“孺子可教也。虽然我们知道它的优化空间大，但具体如何优化呢？”\n\n说着大明将身子向沙发里靠以靠，翘上二郎腿继续说：“通常来说分成两个层面，一个是基于规则的优化，另一个是基于代价的优化，基于规则的优化也可以叫逻辑优化或者规则优化，基于代价的优化也可以叫物理优化或者代价优化。”大明边说边用手比划着，手里的烟火也欢快的跳跃着。\n\n“那为什么要进行这样的区分呢？优化就优化嘛，何必还分什么规则和代价呢？”，小明问道。\n\n“分层不分层不是重点，有些优化器层次分的清楚点，有些优化器层次分的就不那么清楚，都只是优化手段而已。”大明感到有点心虚，再这么问下去恐怕要被问住，于是试图引开话题：“我们继续说说SQL语言吧，我们说它是一种介于关系演算和关系代数之间的语言，关系演算和关系代数你看过吧？”\n\n小明想了想，好像自己上课的时候老师说过关系代数，但是没有说关系演算，于是说：“接触过一点，但也不是特别明白。”大明得意的说：“关系演算是纯描述性的语言，而关系代数呢，则包含了一些基本的关系操作，SQL主要借鉴的是关系演算，也包含了关系代数的一部分特点。”\n\n大明看小明有点懵，顿了一下，然后继续说道：“你们上课的时候老师有没有说过关系代数的基本操作？”小明想了一下说：“好像说了，有投影、选择、连接、交集、差集这几个。”大明点点头说：“对的，还可以有一个叫重命名的，一共6个基本操作，另外结合实际应用在这些基本操作之上又扩展出了外连接、半连接、聚集操作、分组操作等等。”\n\n大明又深吸了一口烟，优雅的吐了个烟圈，继续说道：“SQL语句虽然是描述性的，但是我们可以把它转化成一个关系代数表达式，而关系代数中呢，又有一些等价的规则，这样我们就能结合这些等价规则对关系代数表达式进行等价的转换。”\n\n“进行等价转换的目的是找到性能更好的代数表达式吧？”小明问。\n\n“对，就是这样。”大明投来赞许的目光。\n\n“那么如何确定等价变换之后的表达式就能变得比变换之前性能更好呢？或者说为什么我们要进行这样的等价变换，而不是使用原来的表达式呢？”\n\n大明愣了一下，仿佛没有想到小明会提出这样的问题，但是基于自己多年的忽悠经验，他定了定神，回答道：“这既有经验的成分，也有量化的考虑。例如将选择操作下推，就能优先过滤数据，那么表达式的上层计算结点就能降低计算量，因此很容易可以知道是能降低代价的。再例如我们通常会对相关的子查询进行提升，这是因为如果不提升这种子查询，那么它执行的时候就会产生一个嵌套循环，这种嵌套循环的执行代价是O(N^2)，这种复杂度已经是最坏的情况了，提升上来至少不会比它差，因此提升上来是有价值的。”大明心里对自己的临危不乱暗暗点了个赞。\n\n大明看小明没有提问，继续说道：“这些基于关系代数等价规则做等价变换的优化，就是基于规则的优化，当然数据库本身也会结合实际的经验，产生一些优化规则，比如外连接消除，因为外连接优化起来不太方便，如果能把它消除掉，我们就有了更大的优化空间，这些统统都是基于规则的优化。同时这些都是建立在逻辑操作符上的优化，这也是为什么基于规则的优化也叫做逻辑优化。”\n\n小明想了想，自己好像对逻辑操作符不太理解，连忙问：“逻辑操作符是啥？既然有物理优化，难道还有物理操作符吗？”\n\n大明看自己的烟已经烧的只剩下过滤嘴了，连忙把烟头扔到烟灰缸，伸个懒腰继续说：“比如说吧，你在SQL语句里写上了两个表要做一个左外连接，那么数据库怎么来做这个左外连接呢？”\n\n小明一头雾水的摇摇头，对大明投出了期待的眼神。\n\n大明自问自答的继续说道：“数据库说我也不知道啊，你说的左外连接意思我懂，但我也不知道怎么实现啊？你需要告诉我实现方法啊，因此优化器还承担了一个任务，就是告诉执行器，怎么来实现一个左外连接。”\n\n大明一边说，一边从茶几上把烟拿起来，准备再抽一根，却尴尬的发现，烟盒里一根烟都没有了，大明把空烟盒弹进垃圾桶，继续说：“数据库有哪些方法来实现一个左外连接呢？它可以用嵌套循环连接、哈希连接、归并连接等等，注意了，重要的事情说三遍，你看内连接、外连接是连接操作，嵌套循环连接、归并连接等也叫连接，但内连接、外连接这些就是逻辑操作符，而嵌套循环连接、归并连接这些就是物理操作符。所以你说对了，物理优化就是建立在物理操作符上的优化。”\n\n大明又问小明：“你要从北京去上海，你说你怎么去？”\n\n小明说：“坐高铁啊，又快又方便。”\n\n大明继续问：“做高铁先去广州，然后倒车到上海行不行？”\n\n小明说：“有点扎心了，这不是吃饱了撑的吗？”\n\n大明追问：“为什么？”\n\n小明说：“很明显，我有直达的高铁，即节省时间，又节省费用，先去广州再倒车？我脑子瓦特了？！”\n\n大明笑了笑说：“不知不觉之间，你的大脑就建立了一个代价模型，那就是性价比，优化器作为数据库的大脑，也需要建立代价模型，对物理操作符计算代价，然后筛选出最优的物理操作符来，因此基于代价的优化是建立在物理操作符上的优化，所以也叫物理优化。”\n\n小明觉得似乎懂了：“公司派我去上海出差就是一个逻辑操作符，它和我们写一个SQL语句要求数据库对两个表做左外连接类似，而去上海的实际路径有很多种，这些就像是物理操作符，我们对这些实际的物理路径计算代价之后，就可以选出来最好的路径了。”\n\n大明掏出手机，分别打开了白兔地图APP和高达地图APP，输入了北京到上海的信息，然后拿给小明看，小明发现两家APP给出的最优路径是不一样的。小明若有所思的说：“看来代价模型很重要，代价模型是不是准确决定了最优路径选择的是不是准确。”\n大明一拍大腿，笑着说：“太对了，所以我作为一个数据库内核的资深开发人员，需要不断的调整优化器的代价模型，以期望获得一个相对稳定的代价模型，不过仍然是任重道远啊。”\n","slug":"postgresql-optimizer-outline-1","published":1,"updated":"2020-08-02T00:57:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdchg8jc0001r2s695jh2xip","content":"<p>小明考上了北清大学的计算机研究生，今年学校开了数据库原理的课程，小明对查询优化的部分不是很理解，虽然已经使出了洪荒之力，仍然觉得其中的部分原理有些晦涩难懂，于是小明打算问一下自己的哥哥大明，大明是一位资深的数据库内核开发的老码农，对Greenplum/HAWQ数据库有多年的内核开发经验<a id=\"more\"></a>，厚厚眼镜片上的圈圈像年轮一样深深的见证着大明十多年的从业经历，知道小明要来问问题，大明有点紧张，虽然自己做数据库内核好多年了，但是对优化器研究却不深入，如果被小明这样的小菜鸟问倒就尴尬了，于是大明只好临时抱佛脚，拿出了好多年不看的《数据库系统实现》啃了起来。</p>\n<p>小明提出的第一个问题是：“为什么数据库要进行查询优化？”</p>\n<p>大明推了推鼻梁上的眼镜，点上了一根中华深吸一口，火红的烟头奋力燃烧，由明及暗，几片烟灰飘飘渺渺的散落下来，又和大明吐出的云雾交缠在一起，即轻盈又律动，大明弹了弹烟灰，慢条斯理的说：“不止是数据库要进行优化，基本上所有的编程语言在编译的时候都会优化，比如你在编译C语言的时候，可以通过编译选项-o来指定进行哪个级别的优化，但是查询数据库的查询优化和C语言的优化还有些区别。”</p>\n<p>“有哪些区别呢？”大明停顿了一下，凝视着小明，仿佛期望小明给出答案，或者是给小明腾挪出足够思考的空间，三五秒之后大明又自问自答道：“C语言是过程化语言，你已经指定好了需要执行的每一个步骤，但是SQL是描述性语言，它只指定了WHAT，而没有指定HOW，这样它的优化空间就大了，你说是不是？”</p>\n<p>小明点了点头说：“对，也就是说条条大路通罗马，它比过程语言的选择更多，是不是这样？”大明笑道：“孺子可教也。虽然我们知道它的优化空间大，但具体如何优化呢？”</p>\n<p>说着大明将身子向沙发里靠以靠，翘上二郎腿继续说：“通常来说分成两个层面，一个是基于规则的优化，另一个是基于代价的优化，基于规则的优化也可以叫逻辑优化或者规则优化，基于代价的优化也可以叫物理优化或者代价优化。”大明边说边用手比划着，手里的烟火也欢快的跳跃着。</p>\n<p>“那为什么要进行这样的区分呢？优化就优化嘛，何必还分什么规则和代价呢？”，小明问道。</p>\n<p>“分层不分层不是重点，有些优化器层次分的清楚点，有些优化器层次分的就不那么清楚，都只是优化手段而已。”大明感到有点心虚，再这么问下去恐怕要被问住，于是试图引开话题：“我们继续说说SQL语言吧，我们说它是一种介于关系演算和关系代数之间的语言，关系演算和关系代数你看过吧？”</p>\n<p>小明想了想，好像自己上课的时候老师说过关系代数，但是没有说关系演算，于是说：“接触过一点，但也不是特别明白。”大明得意的说：“关系演算是纯描述性的语言，而关系代数呢，则包含了一些基本的关系操作，SQL主要借鉴的是关系演算，也包含了关系代数的一部分特点。”</p>\n<p>大明看小明有点懵，顿了一下，然后继续说道：“你们上课的时候老师有没有说过关系代数的基本操作？”小明想了一下说：“好像说了，有投影、选择、连接、交集、差集这几个。”大明点点头说：“对的，还可以有一个叫重命名的，一共6个基本操作，另外结合实际应用在这些基本操作之上又扩展出了外连接、半连接、聚集操作、分组操作等等。”</p>\n<p>大明又深吸了一口烟，优雅的吐了个烟圈，继续说道：“SQL语句虽然是描述性的，但是我们可以把它转化成一个关系代数表达式，而关系代数中呢，又有一些等价的规则，这样我们就能结合这些等价规则对关系代数表达式进行等价的转换。”</p>\n<p>“进行等价转换的目的是找到性能更好的代数表达式吧？”小明问。</p>\n<p>“对，就是这样。”大明投来赞许的目光。</p>\n<p>“那么如何确定等价变换之后的表达式就能变得比变换之前性能更好呢？或者说为什么我们要进行这样的等价变换，而不是使用原来的表达式呢？”</p>\n<p>大明愣了一下，仿佛没有想到小明会提出这样的问题，但是基于自己多年的忽悠经验，他定了定神，回答道：“这既有经验的成分，也有量化的考虑。例如将选择操作下推，就能优先过滤数据，那么表达式的上层计算结点就能降低计算量，因此很容易可以知道是能降低代价的。再例如我们通常会对相关的子查询进行提升，这是因为如果不提升这种子查询，那么它执行的时候就会产生一个嵌套循环，这种嵌套循环的执行代价是O(N^2)，这种复杂度已经是最坏的情况了，提升上来至少不会比它差，因此提升上来是有价值的。”大明心里对自己的临危不乱暗暗点了个赞。</p>\n<p>大明看小明没有提问，继续说道：“这些基于关系代数等价规则做等价变换的优化，就是基于规则的优化，当然数据库本身也会结合实际的经验，产生一些优化规则，比如外连接消除，因为外连接优化起来不太方便，如果能把它消除掉，我们就有了更大的优化空间，这些统统都是基于规则的优化。同时这些都是建立在逻辑操作符上的优化，这也是为什么基于规则的优化也叫做逻辑优化。”</p>\n<p>小明想了想，自己好像对逻辑操作符不太理解，连忙问：“逻辑操作符是啥？既然有物理优化，难道还有物理操作符吗？”</p>\n<p>大明看自己的烟已经烧的只剩下过滤嘴了，连忙把烟头扔到烟灰缸，伸个懒腰继续说：“比如说吧，你在SQL语句里写上了两个表要做一个左外连接，那么数据库怎么来做这个左外连接呢？”</p>\n<p>小明一头雾水的摇摇头，对大明投出了期待的眼神。</p>\n<p>大明自问自答的继续说道：“数据库说我也不知道啊，你说的左外连接意思我懂，但我也不知道怎么实现啊？你需要告诉我实现方法啊，因此优化器还承担了一个任务，就是告诉执行器，怎么来实现一个左外连接。”</p>\n<p>大明一边说，一边从茶几上把烟拿起来，准备再抽一根，却尴尬的发现，烟盒里一根烟都没有了，大明把空烟盒弹进垃圾桶，继续说：“数据库有哪些方法来实现一个左外连接呢？它可以用嵌套循环连接、哈希连接、归并连接等等，注意了，重要的事情说三遍，你看内连接、外连接是连接操作，嵌套循环连接、归并连接等也叫连接，但内连接、外连接这些就是逻辑操作符，而嵌套循环连接、归并连接这些就是物理操作符。所以你说对了，物理优化就是建立在物理操作符上的优化。”</p>\n<p>大明又问小明：“你要从北京去上海，你说你怎么去？”</p>\n<p>小明说：“坐高铁啊，又快又方便。”</p>\n<p>大明继续问：“做高铁先去广州，然后倒车到上海行不行？”</p>\n<p>小明说：“有点扎心了，这不是吃饱了撑的吗？”</p>\n<p>大明追问：“为什么？”</p>\n<p>小明说：“很明显，我有直达的高铁，即节省时间，又节省费用，先去广州再倒车？我脑子瓦特了？！”</p>\n<p>大明笑了笑说：“不知不觉之间，你的大脑就建立了一个代价模型，那就是性价比，优化器作为数据库的大脑，也需要建立代价模型，对物理操作符计算代价，然后筛选出最优的物理操作符来，因此基于代价的优化是建立在物理操作符上的优化，所以也叫物理优化。”</p>\n<p>小明觉得似乎懂了：“公司派我去上海出差就是一个逻辑操作符，它和我们写一个SQL语句要求数据库对两个表做左外连接类似，而去上海的实际路径有很多种，这些就像是物理操作符，我们对这些实际的物理路径计算代价之后，就可以选出来最好的路径了。”</p>\n<p>大明掏出手机，分别打开了白兔地图APP和高达地图APP，输入了北京到上海的信息，然后拿给小明看，小明发现两家APP给出的最优路径是不一样的。小明若有所思的说：“看来代价模型很重要，代价模型是不是准确决定了最优路径选择的是不是准确。”<br>大明一拍大腿，笑着说：“太对了，所以我作为一个数据库内核的资深开发人员，需要不断的调整优化器的代价模型，以期望获得一个相对稳定的代价模型，不过仍然是任重道远啊。”</p>\n","site":{"data":{}},"excerpt":"<p>小明考上了北清大学的计算机研究生，今年学校开了数据库原理的课程，小明对查询优化的部分不是很理解，虽然已经使出了洪荒之力，仍然觉得其中的部分原理有些晦涩难懂，于是小明打算问一下自己的哥哥大明，大明是一位资深的数据库内核开发的老码农，对Greenplum/HAWQ数据库有多年的内核开发经验</p>","more":"，厚厚眼镜片上的圈圈像年轮一样深深的见证着大明十多年的从业经历，知道小明要来问问题，大明有点紧张，虽然自己做数据库内核好多年了，但是对优化器研究却不深入，如果被小明这样的小菜鸟问倒就尴尬了，于是大明只好临时抱佛脚，拿出了好多年不看的《数据库系统实现》啃了起来。<p></p>\n<p>小明提出的第一个问题是：“为什么数据库要进行查询优化？”</p>\n<p>大明推了推鼻梁上的眼镜，点上了一根中华深吸一口，火红的烟头奋力燃烧，由明及暗，几片烟灰飘飘渺渺的散落下来，又和大明吐出的云雾交缠在一起，即轻盈又律动，大明弹了弹烟灰，慢条斯理的说：“不止是数据库要进行优化，基本上所有的编程语言在编译的时候都会优化，比如你在编译C语言的时候，可以通过编译选项-o来指定进行哪个级别的优化，但是查询数据库的查询优化和C语言的优化还有些区别。”</p>\n<p>“有哪些区别呢？”大明停顿了一下，凝视着小明，仿佛期望小明给出答案，或者是给小明腾挪出足够思考的空间，三五秒之后大明又自问自答道：“C语言是过程化语言，你已经指定好了需要执行的每一个步骤，但是SQL是描述性语言，它只指定了WHAT，而没有指定HOW，这样它的优化空间就大了，你说是不是？”</p>\n<p>小明点了点头说：“对，也就是说条条大路通罗马，它比过程语言的选择更多，是不是这样？”大明笑道：“孺子可教也。虽然我们知道它的优化空间大，但具体如何优化呢？”</p>\n<p>说着大明将身子向沙发里靠以靠，翘上二郎腿继续说：“通常来说分成两个层面，一个是基于规则的优化，另一个是基于代价的优化，基于规则的优化也可以叫逻辑优化或者规则优化，基于代价的优化也可以叫物理优化或者代价优化。”大明边说边用手比划着，手里的烟火也欢快的跳跃着。</p>\n<p>“那为什么要进行这样的区分呢？优化就优化嘛，何必还分什么规则和代价呢？”，小明问道。</p>\n<p>“分层不分层不是重点，有些优化器层次分的清楚点，有些优化器层次分的就不那么清楚，都只是优化手段而已。”大明感到有点心虚，再这么问下去恐怕要被问住，于是试图引开话题：“我们继续说说SQL语言吧，我们说它是一种介于关系演算和关系代数之间的语言，关系演算和关系代数你看过吧？”</p>\n<p>小明想了想，好像自己上课的时候老师说过关系代数，但是没有说关系演算，于是说：“接触过一点，但也不是特别明白。”大明得意的说：“关系演算是纯描述性的语言，而关系代数呢，则包含了一些基本的关系操作，SQL主要借鉴的是关系演算，也包含了关系代数的一部分特点。”</p>\n<p>大明看小明有点懵，顿了一下，然后继续说道：“你们上课的时候老师有没有说过关系代数的基本操作？”小明想了一下说：“好像说了，有投影、选择、连接、交集、差集这几个。”大明点点头说：“对的，还可以有一个叫重命名的，一共6个基本操作，另外结合实际应用在这些基本操作之上又扩展出了外连接、半连接、聚集操作、分组操作等等。”</p>\n<p>大明又深吸了一口烟，优雅的吐了个烟圈，继续说道：“SQL语句虽然是描述性的，但是我们可以把它转化成一个关系代数表达式，而关系代数中呢，又有一些等价的规则，这样我们就能结合这些等价规则对关系代数表达式进行等价的转换。”</p>\n<p>“进行等价转换的目的是找到性能更好的代数表达式吧？”小明问。</p>\n<p>“对，就是这样。”大明投来赞许的目光。</p>\n<p>“那么如何确定等价变换之后的表达式就能变得比变换之前性能更好呢？或者说为什么我们要进行这样的等价变换，而不是使用原来的表达式呢？”</p>\n<p>大明愣了一下，仿佛没有想到小明会提出这样的问题，但是基于自己多年的忽悠经验，他定了定神，回答道：“这既有经验的成分，也有量化的考虑。例如将选择操作下推，就能优先过滤数据，那么表达式的上层计算结点就能降低计算量，因此很容易可以知道是能降低代价的。再例如我们通常会对相关的子查询进行提升，这是因为如果不提升这种子查询，那么它执行的时候就会产生一个嵌套循环，这种嵌套循环的执行代价是O(N^2)，这种复杂度已经是最坏的情况了，提升上来至少不会比它差，因此提升上来是有价值的。”大明心里对自己的临危不乱暗暗点了个赞。</p>\n<p>大明看小明没有提问，继续说道：“这些基于关系代数等价规则做等价变换的优化，就是基于规则的优化，当然数据库本身也会结合实际的经验，产生一些优化规则，比如外连接消除，因为外连接优化起来不太方便，如果能把它消除掉，我们就有了更大的优化空间，这些统统都是基于规则的优化。同时这些都是建立在逻辑操作符上的优化，这也是为什么基于规则的优化也叫做逻辑优化。”</p>\n<p>小明想了想，自己好像对逻辑操作符不太理解，连忙问：“逻辑操作符是啥？既然有物理优化，难道还有物理操作符吗？”</p>\n<p>大明看自己的烟已经烧的只剩下过滤嘴了，连忙把烟头扔到烟灰缸，伸个懒腰继续说：“比如说吧，你在SQL语句里写上了两个表要做一个左外连接，那么数据库怎么来做这个左外连接呢？”</p>\n<p>小明一头雾水的摇摇头，对大明投出了期待的眼神。</p>\n<p>大明自问自答的继续说道：“数据库说我也不知道啊，你说的左外连接意思我懂，但我也不知道怎么实现啊？你需要告诉我实现方法啊，因此优化器还承担了一个任务，就是告诉执行器，怎么来实现一个左外连接。”</p>\n<p>大明一边说，一边从茶几上把烟拿起来，准备再抽一根，却尴尬的发现，烟盒里一根烟都没有了，大明把空烟盒弹进垃圾桶，继续说：“数据库有哪些方法来实现一个左外连接呢？它可以用嵌套循环连接、哈希连接、归并连接等等，注意了，重要的事情说三遍，你看内连接、外连接是连接操作，嵌套循环连接、归并连接等也叫连接，但内连接、外连接这些就是逻辑操作符，而嵌套循环连接、归并连接这些就是物理操作符。所以你说对了，物理优化就是建立在物理操作符上的优化。”</p>\n<p>大明又问小明：“你要从北京去上海，你说你怎么去？”</p>\n<p>小明说：“坐高铁啊，又快又方便。”</p>\n<p>大明继续问：“做高铁先去广州，然后倒车到上海行不行？”</p>\n<p>小明说：“有点扎心了，这不是吃饱了撑的吗？”</p>\n<p>大明追问：“为什么？”</p>\n<p>小明说：“很明显，我有直达的高铁，即节省时间，又节省费用，先去广州再倒车？我脑子瓦特了？！”</p>\n<p>大明笑了笑说：“不知不觉之间，你的大脑就建立了一个代价模型，那就是性价比，优化器作为数据库的大脑，也需要建立代价模型，对物理操作符计算代价，然后筛选出最优的物理操作符来，因此基于代价的优化是建立在物理操作符上的优化，所以也叫物理优化。”</p>\n<p>小明觉得似乎懂了：“公司派我去上海出差就是一个逻辑操作符，它和我们写一个SQL语句要求数据库对两个表做左外连接类似，而去上海的实际路径有很多种，这些就像是物理操作符，我们对这些实际的物理路径计算代价之后，就可以选出来最好的路径了。”</p>\n<p>大明掏出手机，分别打开了白兔地图APP和高达地图APP，输入了北京到上海的信息，然后拿给小明看，小明发现两家APP给出的最优路径是不一样的。小明若有所思的说：“看来代价模型很重要，代价模型是不是准确决定了最优路径选择的是不是准确。”<br>大明一拍大腿，笑着说：“太对了，所以我作为一个数据库内核的资深开发人员，需要不断的调整优化器的代价模型，以期望获得一个相对稳定的代价模型，不过仍然是任重道远啊。”</p>"},{"title":"PostgreSQL优化器白话(2) - SQL进化史","date":"2020-08-02T00:56:06.000Z","_content":"\n通过大明给小明解释了查询优化器的基本原理，小明在学校的数据库原理课堂上顺风顺水，每天吃饭睡觉打豆豆，日子过得非常悠哉，不过眼看就到了数据库原理的实践课了，老师给出的题目是分析一个数据库的某一模块的实现，小明千挑万选，终于选定了要分析PostgreSQL数据库的查询优化器的实现，因为据说PostgreSQL数据库的查询优化器层（相）次（当）清（复）楚（杂），具有教科书级的示范作用。<!-- more -->\n\t\n可是当小明下载了PostgreSQL数据库的源代码，顿时就懵圈了，虽然平时理论说的天花乱坠，但是到了实践的时候却发现，理论和实际对应不上，小明深深的陷入到代码的细节里面不可自拔，小明查阅了好多资料，结果是读破书万卷，下笔如有锤，一点进展就没有。于是小明又想到了自己的哥哥——大明，他作为Greenplum/HAWQ数据库的资深的数据库内核老码农，不是和PostgreSQL数据库有着不解之缘吗？想必他一定能站得更高，看的更远，于是小明蹬着自己的宝马向大明驶去。\n\t\n大明接到了小明要来“视察”的消息，早就做好了准备，大明也只是在工作中偶尔接触一下优化器，也没有对查询优化器有多熟悉，正好借着这次机会自己也对优化器进行了一番学习。看着小明大汗淋漓的走进了门，大明从冰箱里拿了一根从菜市场买的巧牙兹，意味深长的说：“小明同学，PostgreSQL数据库的查询优化器功能比较多，恐怕一次说不完，我们把它分成几次来说清楚吧。”\n\n小明虽然感觉冰棍的味道有点偏差，但觉得大明说得有道理，因为自己通过查看PostgreSQL数据库的源码的确非常复杂，于是说：“的确是的，我在看查询优化器代码的时候，觉得无从下手，虽然查询优化的一些理论我学过了，但是不知道代码和理论如何对应，而且还有一些优化规则好像我们讲数据库原理的时候也没有涉及到，毕竟理论和实践之间还有一些差距。”\n\n大明打开电脑，调出了PostgreSQL的代码，然后说：“我们先来看一下PostgreSQL数据库一个查询执行的基本流程。”，然后大明调出了一张图。\n\n![](./postgresql-optimizer-outline-2/1.jpg) \n \n小明觉得这张图似曾相识，又不知道在哪见过，于是说：“我好像见过这张图。”大明点点头说：“是的，大部分查询优化的培训都是从这张图开始的，不过这张图是我自己画的，你看到的那些图表达的意思应该是一样的，但它的形式可能略有不同，这种图已经成了优化器培训开篇的必备图了，不过我们还是有必要借助这张图来看一下PostgreSQL数据库源码的大体结构，了解查询优化器所处的位置。”\n\t\n大明一边指点着电脑屏幕，一边继续说：“我们要执行一条SQL语句，首先会进行词法分析，也就是说把SQL语句做一个分割，分成很多小段段。。。”小明连忙说：“我们在学编译原理的时候老师说了，分成的小段段可以是关键字、标识符、常量、运算符和边界符，是不是分词之后就会给这些小段段赋予上这些语义？”\n\n“对的！看来你对编译原理的第一章很熟悉嘛。”大明笑着说。\n\t\n“当然，我最擅长写Hello World。”\n\t\n“好吧，Let’s 继续，PostgreSQL的分词是在scan.l文件中完成的，它可能分的更细致一些，比如常量它就分成了SCONST、FCONST、ICONST等等，不过基本的原理是一样的。进行分词并且给每个单词以语义之后，就可以去匹配gram.y里的语法规则了，在gram.y文件里定义了所有的SQL语言的语法规则，我们的查询经过匹配之后，最终形成了一颗语法树。”\n\t\n“语法树？我还听过什么查询树、计划树，这些树要怎么区分呢？”\n\t\n“一个查询语句在不同的阶段，生成的树是不同的，这些树的顺序应该是先生成语法树，然后得到查询树，最终得到计划树，计划树就是我们说的执行计划。”\n\t\n“那么为什么要做这些转换呢？”小明不解的问。\n\t\n“我们通过词法分析、语法分析获得了语法树，但这时的语法树还和SQL语句有很紧密的关系，比如我们在语法树中保存的还是一个表的名字，一个列的名字，但实际上在PostgreSQL数据库数据库中，有很多系统表，比如PG_CLASS用来将表保存成数据库的内部结构，当我们创建一个表的时候，会在PG_CLASS、PG_ATTRIBUTE等等系统表里增加新的元数据，我们要用这些元数据的信息取代语法树中的表的名字、列的名字等等。”\n\t\n小明想了想，说：“这个取代的过程就是语义分析？这样就把语法树转换成了查询树，而查询树是使用元数据来描述的，所以我们在数据库内核中使用它就更方便了？”\n\t\n“是的。”大明肯定的说。“不过语义分析还做了一个工作，那就是检查工作，在语法树是通过分析SQL语句获得的，它还不知道一个表是不是存在，一个列是不是存在，这个转换的过程，也是一个检查的过程。”大明停顿了一下，似乎是做了一下思考，然后拿出一张纸，在上边画了起来。\n\n![](postgresql-optimizer-outline-2/2.jpg) \n\n“这是SQL语句SELECT st.sname, c.cname, sc.degree FROM STUDENT st , COURSE c INNER JOIN SCORE sc ON c.cno = sc.cno WHERE st.sno = sc.sno对应的简版查询树，看着复杂吗？”大明边画边问。小明心中翻腾出千万只泥马，他似乎感觉到自己选择查询优化作为数据库原理课的实践作业是一个错误的决定，现在自己已经受到了冲动的惩罚，这个图里的大部分内容他都不知道是什么东西。\n\n看着小明迷离的眼神，大明有点发慌，说：“我们现在还不用深入到代码层面，你可以忽略这张图，现在可以把查询树认为是一个关系代数表达式。”\n\n小明定了定神，问道：“关系代数表达式？上次我咨询你查询优化原理的时候你是不是说基于规则的优化就是使用关系代数的等价规则对关系代数表达式进行等价的变换，所以查询优化器的工作就是用这个查询树做等价变换？”\n\n“恭喜你，答对了。”大明暗暗赞许小明的理解能力还有记忆力，继续说：“查询树就是查询优化器的输入，经过逻辑优化和物理优化，最终产生一颗最优的计划树，而我们要做的就会看看查询优化器是如何产生这棵最优的计划树的。”\n\n这时门铃响了，小明打开门一看，原来是吃了吗外卖到了，小明拎着外卖说：“看来我们先要饱餐战饭，然后才能看查询树的变换过程了。”说着打开送餐包装，美美的吃起了大腰子，而大明则已经从酒柜里拿出了珍藏的红酒。。。\n","source":"_posts/postgresql-optimizer-outline-2.md","raw":"---\ntitle: PostgreSQL优化器白话(2) - SQL进化史\ndate: 2020-08-02 08:56:06\n---\n\n通过大明给小明解释了查询优化器的基本原理，小明在学校的数据库原理课堂上顺风顺水，每天吃饭睡觉打豆豆，日子过得非常悠哉，不过眼看就到了数据库原理的实践课了，老师给出的题目是分析一个数据库的某一模块的实现，小明千挑万选，终于选定了要分析PostgreSQL数据库的查询优化器的实现，因为据说PostgreSQL数据库的查询优化器层（相）次（当）清（复）楚（杂），具有教科书级的示范作用。<!-- more -->\n\t\n可是当小明下载了PostgreSQL数据库的源代码，顿时就懵圈了，虽然平时理论说的天花乱坠，但是到了实践的时候却发现，理论和实际对应不上，小明深深的陷入到代码的细节里面不可自拔，小明查阅了好多资料，结果是读破书万卷，下笔如有锤，一点进展就没有。于是小明又想到了自己的哥哥——大明，他作为Greenplum/HAWQ数据库的资深的数据库内核老码农，不是和PostgreSQL数据库有着不解之缘吗？想必他一定能站得更高，看的更远，于是小明蹬着自己的宝马向大明驶去。\n\t\n大明接到了小明要来“视察”的消息，早就做好了准备，大明也只是在工作中偶尔接触一下优化器，也没有对查询优化器有多熟悉，正好借着这次机会自己也对优化器进行了一番学习。看着小明大汗淋漓的走进了门，大明从冰箱里拿了一根从菜市场买的巧牙兹，意味深长的说：“小明同学，PostgreSQL数据库的查询优化器功能比较多，恐怕一次说不完，我们把它分成几次来说清楚吧。”\n\n小明虽然感觉冰棍的味道有点偏差，但觉得大明说得有道理，因为自己通过查看PostgreSQL数据库的源码的确非常复杂，于是说：“的确是的，我在看查询优化器代码的时候，觉得无从下手，虽然查询优化的一些理论我学过了，但是不知道代码和理论如何对应，而且还有一些优化规则好像我们讲数据库原理的时候也没有涉及到，毕竟理论和实践之间还有一些差距。”\n\n大明打开电脑，调出了PostgreSQL的代码，然后说：“我们先来看一下PostgreSQL数据库一个查询执行的基本流程。”，然后大明调出了一张图。\n\n![](./postgresql-optimizer-outline-2/1.jpg) \n \n小明觉得这张图似曾相识，又不知道在哪见过，于是说：“我好像见过这张图。”大明点点头说：“是的，大部分查询优化的培训都是从这张图开始的，不过这张图是我自己画的，你看到的那些图表达的意思应该是一样的，但它的形式可能略有不同，这种图已经成了优化器培训开篇的必备图了，不过我们还是有必要借助这张图来看一下PostgreSQL数据库源码的大体结构，了解查询优化器所处的位置。”\n\t\n大明一边指点着电脑屏幕，一边继续说：“我们要执行一条SQL语句，首先会进行词法分析，也就是说把SQL语句做一个分割，分成很多小段段。。。”小明连忙说：“我们在学编译原理的时候老师说了，分成的小段段可以是关键字、标识符、常量、运算符和边界符，是不是分词之后就会给这些小段段赋予上这些语义？”\n\n“对的！看来你对编译原理的第一章很熟悉嘛。”大明笑着说。\n\t\n“当然，我最擅长写Hello World。”\n\t\n“好吧，Let’s 继续，PostgreSQL的分词是在scan.l文件中完成的，它可能分的更细致一些，比如常量它就分成了SCONST、FCONST、ICONST等等，不过基本的原理是一样的。进行分词并且给每个单词以语义之后，就可以去匹配gram.y里的语法规则了，在gram.y文件里定义了所有的SQL语言的语法规则，我们的查询经过匹配之后，最终形成了一颗语法树。”\n\t\n“语法树？我还听过什么查询树、计划树，这些树要怎么区分呢？”\n\t\n“一个查询语句在不同的阶段，生成的树是不同的，这些树的顺序应该是先生成语法树，然后得到查询树，最终得到计划树，计划树就是我们说的执行计划。”\n\t\n“那么为什么要做这些转换呢？”小明不解的问。\n\t\n“我们通过词法分析、语法分析获得了语法树，但这时的语法树还和SQL语句有很紧密的关系，比如我们在语法树中保存的还是一个表的名字，一个列的名字，但实际上在PostgreSQL数据库数据库中，有很多系统表，比如PG_CLASS用来将表保存成数据库的内部结构，当我们创建一个表的时候，会在PG_CLASS、PG_ATTRIBUTE等等系统表里增加新的元数据，我们要用这些元数据的信息取代语法树中的表的名字、列的名字等等。”\n\t\n小明想了想，说：“这个取代的过程就是语义分析？这样就把语法树转换成了查询树，而查询树是使用元数据来描述的，所以我们在数据库内核中使用它就更方便了？”\n\t\n“是的。”大明肯定的说。“不过语义分析还做了一个工作，那就是检查工作，在语法树是通过分析SQL语句获得的，它还不知道一个表是不是存在，一个列是不是存在，这个转换的过程，也是一个检查的过程。”大明停顿了一下，似乎是做了一下思考，然后拿出一张纸，在上边画了起来。\n\n![](postgresql-optimizer-outline-2/2.jpg) \n\n“这是SQL语句SELECT st.sname, c.cname, sc.degree FROM STUDENT st , COURSE c INNER JOIN SCORE sc ON c.cno = sc.cno WHERE st.sno = sc.sno对应的简版查询树，看着复杂吗？”大明边画边问。小明心中翻腾出千万只泥马，他似乎感觉到自己选择查询优化作为数据库原理课的实践作业是一个错误的决定，现在自己已经受到了冲动的惩罚，这个图里的大部分内容他都不知道是什么东西。\n\n看着小明迷离的眼神，大明有点发慌，说：“我们现在还不用深入到代码层面，你可以忽略这张图，现在可以把查询树认为是一个关系代数表达式。”\n\n小明定了定神，问道：“关系代数表达式？上次我咨询你查询优化原理的时候你是不是说基于规则的优化就是使用关系代数的等价规则对关系代数表达式进行等价的变换，所以查询优化器的工作就是用这个查询树做等价变换？”\n\n“恭喜你，答对了。”大明暗暗赞许小明的理解能力还有记忆力，继续说：“查询树就是查询优化器的输入，经过逻辑优化和物理优化，最终产生一颗最优的计划树，而我们要做的就会看看查询优化器是如何产生这棵最优的计划树的。”\n\n这时门铃响了，小明打开门一看，原来是吃了吗外卖到了，小明拎着外卖说：“看来我们先要饱餐战饭，然后才能看查询树的变换过程了。”说着打开送餐包装，美美的吃起了大腰子，而大明则已经从酒柜里拿出了珍藏的红酒。。。\n","slug":"postgresql-optimizer-outline-2","published":1,"updated":"2020-08-02T01:43:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdchg8je0002r2s686meddyz","content":"<p>通过大明给小明解释了查询优化器的基本原理，小明在学校的数据库原理课堂上顺风顺水，每天吃饭睡觉打豆豆，日子过得非常悠哉，不过眼看就到了数据库原理的实践课了，老师给出的题目是分析一个数据库的某一模块的实现，小明千挑万选，终于选定了要分析PostgreSQL数据库的查询优化器的实现，因为据说PostgreSQL数据库的查询优化器层（相）次（当）清（复）楚（杂），具有教科书级的示范作用。<a id=\"more\"></a></p>\n<p>可是当小明下载了PostgreSQL数据库的源代码，顿时就懵圈了，虽然平时理论说的天花乱坠，但是到了实践的时候却发现，理论和实际对应不上，小明深深的陷入到代码的细节里面不可自拔，小明查阅了好多资料，结果是读破书万卷，下笔如有锤，一点进展就没有。于是小明又想到了自己的哥哥——大明，他作为Greenplum/HAWQ数据库的资深的数据库内核老码农，不是和PostgreSQL数据库有着不解之缘吗？想必他一定能站得更高，看的更远，于是小明蹬着自己的宝马向大明驶去。</p>\n<p>大明接到了小明要来“视察”的消息，早就做好了准备，大明也只是在工作中偶尔接触一下优化器，也没有对查询优化器有多熟悉，正好借着这次机会自己也对优化器进行了一番学习。看着小明大汗淋漓的走进了门，大明从冰箱里拿了一根从菜市场买的巧牙兹，意味深长的说：“小明同学，PostgreSQL数据库的查询优化器功能比较多，恐怕一次说不完，我们把它分成几次来说清楚吧。”</p>\n<p>小明虽然感觉冰棍的味道有点偏差，但觉得大明说得有道理，因为自己通过查看PostgreSQL数据库的源码的确非常复杂，于是说：“的确是的，我在看查询优化器代码的时候，觉得无从下手，虽然查询优化的一些理论我学过了，但是不知道代码和理论如何对应，而且还有一些优化规则好像我们讲数据库原理的时候也没有涉及到，毕竟理论和实践之间还有一些差距。”</p>\n<p>大明打开电脑，调出了PostgreSQL的代码，然后说：“我们先来看一下PostgreSQL数据库一个查询执行的基本流程。”，然后大明调出了一张图。</p>\n<p><img src=\"/2020/08/02/postgresql-optimizer-outline-2/1.jpg\"> </p>\n<p>小明觉得这张图似曾相识，又不知道在哪见过，于是说：“我好像见过这张图。”大明点点头说：“是的，大部分查询优化的培训都是从这张图开始的，不过这张图是我自己画的，你看到的那些图表达的意思应该是一样的，但它的形式可能略有不同，这种图已经成了优化器培训开篇的必备图了，不过我们还是有必要借助这张图来看一下PostgreSQL数据库源码的大体结构，了解查询优化器所处的位置。”</p>\n<p>大明一边指点着电脑屏幕，一边继续说：“我们要执行一条SQL语句，首先会进行词法分析，也就是说把SQL语句做一个分割，分成很多小段段。。。”小明连忙说：“我们在学编译原理的时候老师说了，分成的小段段可以是关键字、标识符、常量、运算符和边界符，是不是分词之后就会给这些小段段赋予上这些语义？”</p>\n<p>“对的！看来你对编译原理的第一章很熟悉嘛。”大明笑着说。</p>\n<p>“当然，我最擅长写Hello World。”</p>\n<p>“好吧，Let’s 继续，PostgreSQL的分词是在scan.l文件中完成的，它可能分的更细致一些，比如常量它就分成了SCONST、FCONST、ICONST等等，不过基本的原理是一样的。进行分词并且给每个单词以语义之后，就可以去匹配gram.y里的语法规则了，在gram.y文件里定义了所有的SQL语言的语法规则，我们的查询经过匹配之后，最终形成了一颗语法树。”</p>\n<p>“语法树？我还听过什么查询树、计划树，这些树要怎么区分呢？”</p>\n<p>“一个查询语句在不同的阶段，生成的树是不同的，这些树的顺序应该是先生成语法树，然后得到查询树，最终得到计划树，计划树就是我们说的执行计划。”</p>\n<p>“那么为什么要做这些转换呢？”小明不解的问。</p>\n<p>“我们通过词法分析、语法分析获得了语法树，但这时的语法树还和SQL语句有很紧密的关系，比如我们在语法树中保存的还是一个表的名字，一个列的名字，但实际上在PostgreSQL数据库数据库中，有很多系统表，比如PG_CLASS用来将表保存成数据库的内部结构，当我们创建一个表的时候，会在PG_CLASS、PG_ATTRIBUTE等等系统表里增加新的元数据，我们要用这些元数据的信息取代语法树中的表的名字、列的名字等等。”</p>\n<p>小明想了想，说：“这个取代的过程就是语义分析？这样就把语法树转换成了查询树，而查询树是使用元数据来描述的，所以我们在数据库内核中使用它就更方便了？”</p>\n<p>“是的。”大明肯定的说。“不过语义分析还做了一个工作，那就是检查工作，在语法树是通过分析SQL语句获得的，它还不知道一个表是不是存在，一个列是不是存在，这个转换的过程，也是一个检查的过程。”大明停顿了一下，似乎是做了一下思考，然后拿出一张纸，在上边画了起来。</p>\n<p><img src=\"/2020/08/02/postgresql-optimizer-outline-2/2.jpg\"> </p>\n<p>“这是SQL语句SELECT st.sname, c.cname, sc.degree FROM STUDENT st , COURSE c INNER JOIN SCORE sc ON c.cno = sc.cno WHERE st.sno = sc.sno对应的简版查询树，看着复杂吗？”大明边画边问。小明心中翻腾出千万只泥马，他似乎感觉到自己选择查询优化作为数据库原理课的实践作业是一个错误的决定，现在自己已经受到了冲动的惩罚，这个图里的大部分内容他都不知道是什么东西。</p>\n<p>看着小明迷离的眼神，大明有点发慌，说：“我们现在还不用深入到代码层面，你可以忽略这张图，现在可以把查询树认为是一个关系代数表达式。”</p>\n<p>小明定了定神，问道：“关系代数表达式？上次我咨询你查询优化原理的时候你是不是说基于规则的优化就是使用关系代数的等价规则对关系代数表达式进行等价的变换，所以查询优化器的工作就是用这个查询树做等价变换？”</p>\n<p>“恭喜你，答对了。”大明暗暗赞许小明的理解能力还有记忆力，继续说：“查询树就是查询优化器的输入，经过逻辑优化和物理优化，最终产生一颗最优的计划树，而我们要做的就会看看查询优化器是如何产生这棵最优的计划树的。”</p>\n<p>这时门铃响了，小明打开门一看，原来是吃了吗外卖到了，小明拎着外卖说：“看来我们先要饱餐战饭，然后才能看查询树的变换过程了。”说着打开送餐包装，美美的吃起了大腰子，而大明则已经从酒柜里拿出了珍藏的红酒。。。</p>\n","site":{"data":{}},"excerpt":"<p>通过大明给小明解释了查询优化器的基本原理，小明在学校的数据库原理课堂上顺风顺水，每天吃饭睡觉打豆豆，日子过得非常悠哉，不过眼看就到了数据库原理的实践课了，老师给出的题目是分析一个数据库的某一模块的实现，小明千挑万选，终于选定了要分析PostgreSQL数据库的查询优化器的实现，因为据说PostgreSQL数据库的查询优化器层（相）次（当）清（复）楚（杂），具有教科书级的示范作用。</p>","more":"<p></p>\n<p>可是当小明下载了PostgreSQL数据库的源代码，顿时就懵圈了，虽然平时理论说的天花乱坠，但是到了实践的时候却发现，理论和实际对应不上，小明深深的陷入到代码的细节里面不可自拔，小明查阅了好多资料，结果是读破书万卷，下笔如有锤，一点进展就没有。于是小明又想到了自己的哥哥——大明，他作为Greenplum/HAWQ数据库的资深的数据库内核老码农，不是和PostgreSQL数据库有着不解之缘吗？想必他一定能站得更高，看的更远，于是小明蹬着自己的宝马向大明驶去。</p>\n<p>大明接到了小明要来“视察”的消息，早就做好了准备，大明也只是在工作中偶尔接触一下优化器，也没有对查询优化器有多熟悉，正好借着这次机会自己也对优化器进行了一番学习。看着小明大汗淋漓的走进了门，大明从冰箱里拿了一根从菜市场买的巧牙兹，意味深长的说：“小明同学，PostgreSQL数据库的查询优化器功能比较多，恐怕一次说不完，我们把它分成几次来说清楚吧。”</p>\n<p>小明虽然感觉冰棍的味道有点偏差，但觉得大明说得有道理，因为自己通过查看PostgreSQL数据库的源码的确非常复杂，于是说：“的确是的，我在看查询优化器代码的时候，觉得无从下手，虽然查询优化的一些理论我学过了，但是不知道代码和理论如何对应，而且还有一些优化规则好像我们讲数据库原理的时候也没有涉及到，毕竟理论和实践之间还有一些差距。”</p>\n<p>大明打开电脑，调出了PostgreSQL的代码，然后说：“我们先来看一下PostgreSQL数据库一个查询执行的基本流程。”，然后大明调出了一张图。</p>\n<p><img src=\"/2020/08/02/postgresql-optimizer-outline-2/1.jpg\"> </p>\n<p>小明觉得这张图似曾相识，又不知道在哪见过，于是说：“我好像见过这张图。”大明点点头说：“是的，大部分查询优化的培训都是从这张图开始的，不过这张图是我自己画的，你看到的那些图表达的意思应该是一样的，但它的形式可能略有不同，这种图已经成了优化器培训开篇的必备图了，不过我们还是有必要借助这张图来看一下PostgreSQL数据库源码的大体结构，了解查询优化器所处的位置。”</p>\n<p>大明一边指点着电脑屏幕，一边继续说：“我们要执行一条SQL语句，首先会进行词法分析，也就是说把SQL语句做一个分割，分成很多小段段。。。”小明连忙说：“我们在学编译原理的时候老师说了，分成的小段段可以是关键字、标识符、常量、运算符和边界符，是不是分词之后就会给这些小段段赋予上这些语义？”</p>\n<p>“对的！看来你对编译原理的第一章很熟悉嘛。”大明笑着说。</p>\n<p>“当然，我最擅长写Hello World。”</p>\n<p>“好吧，Let’s 继续，PostgreSQL的分词是在scan.l文件中完成的，它可能分的更细致一些，比如常量它就分成了SCONST、FCONST、ICONST等等，不过基本的原理是一样的。进行分词并且给每个单词以语义之后，就可以去匹配gram.y里的语法规则了，在gram.y文件里定义了所有的SQL语言的语法规则，我们的查询经过匹配之后，最终形成了一颗语法树。”</p>\n<p>“语法树？我还听过什么查询树、计划树，这些树要怎么区分呢？”</p>\n<p>“一个查询语句在不同的阶段，生成的树是不同的，这些树的顺序应该是先生成语法树，然后得到查询树，最终得到计划树，计划树就是我们说的执行计划。”</p>\n<p>“那么为什么要做这些转换呢？”小明不解的问。</p>\n<p>“我们通过词法分析、语法分析获得了语法树，但这时的语法树还和SQL语句有很紧密的关系，比如我们在语法树中保存的还是一个表的名字，一个列的名字，但实际上在PostgreSQL数据库数据库中，有很多系统表，比如PG_CLASS用来将表保存成数据库的内部结构，当我们创建一个表的时候，会在PG_CLASS、PG_ATTRIBUTE等等系统表里增加新的元数据，我们要用这些元数据的信息取代语法树中的表的名字、列的名字等等。”</p>\n<p>小明想了想，说：“这个取代的过程就是语义分析？这样就把语法树转换成了查询树，而查询树是使用元数据来描述的，所以我们在数据库内核中使用它就更方便了？”</p>\n<p>“是的。”大明肯定的说。“不过语义分析还做了一个工作，那就是检查工作，在语法树是通过分析SQL语句获得的，它还不知道一个表是不是存在，一个列是不是存在，这个转换的过程，也是一个检查的过程。”大明停顿了一下，似乎是做了一下思考，然后拿出一张纸，在上边画了起来。</p>\n<p><img src=\"/2020/08/02/postgresql-optimizer-outline-2/2.jpg\"> </p>\n<p>“这是SQL语句SELECT st.sname, c.cname, sc.degree FROM STUDENT st , COURSE c INNER JOIN SCORE sc ON c.cno = sc.cno WHERE st.sno = sc.sno对应的简版查询树，看着复杂吗？”大明边画边问。小明心中翻腾出千万只泥马，他似乎感觉到自己选择查询优化作为数据库原理课的实践作业是一个错误的决定，现在自己已经受到了冲动的惩罚，这个图里的大部分内容他都不知道是什么东西。</p>\n<p>看着小明迷离的眼神，大明有点发慌，说：“我们现在还不用深入到代码层面，你可以忽略这张图，现在可以把查询树认为是一个关系代数表达式。”</p>\n<p>小明定了定神，问道：“关系代数表达式？上次我咨询你查询优化原理的时候你是不是说基于规则的优化就是使用关系代数的等价规则对关系代数表达式进行等价的变换，所以查询优化器的工作就是用这个查询树做等价变换？”</p>\n<p>“恭喜你，答对了。”大明暗暗赞许小明的理解能力还有记忆力，继续说：“查询树就是查询优化器的输入，经过逻辑优化和物理优化，最终产生一颗最优的计划树，而我们要做的就会看看查询优化器是如何产生这棵最优的计划树的。”</p>\n<p>这时门铃响了，小明打开门一看，原来是吃了吗外卖到了，小明拎着外卖说：“看来我们先要饱餐战饭，然后才能看查询树的变换过程了。”说着打开送餐包装，美美的吃起了大腰子，而大明则已经从酒柜里拿出了珍藏的红酒。。。</p>"},{"title":"PostgreSQL优化器白话(3) - 提升！提升！","date":"2020-08-02T01:25:08.000Z","_content":"\n小明发现到大明家里问问题不但能收获知识，还能收获大腰子和红酒，于是更加坚定了常来问问题的决心。\n\n小明和大明吃完了午饭，打开电视看一会电视剧，大明又惬意的惬意的抽起了中华烟，小明闻着二手烟有点心烦，就问大明：“哥，你整天抽抽抽，有那么好抽吗？”大明自豪的说：“咋地，咱爷爷抽烟，咱爸爸也抽烟，到我这不能断了香火，你不抽烟是不孝知道不？”<!-- more -->\n\n小明说：“咱爷爷抽烟是在农村种的烟叶，自给自足，还省钱，你也干脆回农村种烟叶，你这中华烟和农村的自己卷的烟叶，能有什么区别？”\n\n大明看电视剧正看得起劲，心不在焉的说：“自己种的烟叶直接用报纸卷了抽，没有过滤嘴，会吸入有害颗粒物，而且烟叶的味道也不如现在改进的香烟。”说到这里大明好像想到了些什么，继续说：“这就像是查询优化器的逻辑优化，查询树输入之后，需要进行持续的改进，无论是自己用报纸卷的烟，还是在超市买的成品烟，它都是香烟，但是通过改进之后，香烟的毒害作用更低、香型更丰富了，逻辑优化也是这个道理，通过改进查询树，能够得到一个更‘好’的查询树。”\n\n“哦，那逻辑优化是如何在已有的查询树上增加香型的呢？”\n\n大明感觉电视剧没办法看下去了，于是拿起遥控器关了电视，继续说：“我总结，PostgreSQL在逻辑优化阶段有这么几个重要的优化：子查询&子连接提升、表达式预处理、外连接消除、谓词下推、连接顺序交换、等价类推理。”大明又抽了一口烟，接着说到：“从代码逻辑上来看，我们还可以把子查询&子连接提升、表达式预处理、外连接消除叫做逻辑重写优化，因为他们主要是对查询树进行改造，而后面的谓词下推、连接顺序交换、等价类推理则可以称之为逻辑分解优化，他们已经把查询树蹂躏的不成样子了，已经到了看香烟不是香烟的地步了。”\n\n“可是我们的数据库原理课上并没有说有逻辑重写优化和逻辑分解优化啊？”\n\n“嗯，是的，这是我自己根据PostgreSQL的源代码的特征自己总结的，不过它能比较形象的将现有的逻辑优化区分开来，这样就能更好的对逻辑优化进行提炼、总结、分析。”大明想了一下觉得如果把所有的逻辑优化的规则都说完有点多，决定选择其中的一两个说一下，于是对小明说道：“我们就从中挑选一两个详细的说明一下吧，我们先从子查询&子连接的提升开始说起。”\n\n“那。。。子查询和子连接有什么区别呢？我们在数据库原理课里只讲了子查询，没有子连接的概念，这该怎么解释呢？”小明不解的问。\n\n大明去书柜里拿出了《数据库系统实现》这本书，然后翻开了对应的章节，说道：“通常数据库原理书籍中说的子查询，指的是PostgreSQL数据库中的子连接。你看，《数据库系统实现》中说的是从条件中去除子查询，但是PostgreSQL把这种情况归类为子连接。”\n\n“那在PostgreSQL是如何区分子查询和子连接的呢？”大明自问自答道：“在实际应用中可以通过子句所处的位置来区分子连接和子查询，出现在FROM关键字后的子句是子查询语句，出现在WHERE/ON等约束条件中或投影中的子句是子连接语句。”说着大明快速的在电脑上打开了记事本，敲入了几个SQL语句：\n\n```\n1. SELECT * FROM STUDENT, (SELECT * FROM SCORE) as sc;\n2. SELECT (SELECT AVG(degree) FROM SCORE), sname FROM STUDENT;\n3. SELECT * FROM STUDENT WHERE EXISTS (SELECT A FROM SCORE WHERE SCORE.sno = STUDENT.sno);\n```\n\n“这些SQL语句中哪个是子查询？哪个是子连接？”\n\n小明看了一下，然后说：“1是子查询，2和3是子连接，语句1里面的子句出现在FROM后面，它是以‘表’的形式存在的，是子查询，2和3的子句出现在投影和约束条件中，是以表达式的形式存在的，是子连接。”小明不但答对了问题，而且还对问题的答案做了扩展，大明感到很一颗赛艇，于是调侃道：“腰间盘同学，你坐下，你太突出了。”\n\n然后大明正一正颜色，继续说道“从大的方向上分类，子查询还可以分为相关子连接和非相关子连接，相关子连接是指在子查询语句中引用了外层表的列属性，这就导致外层表每获得一个元组，子查询就需要重新执行一次；而非相关子查询是指在子查询语句是独立的，和外层的表没有直接的关联，子查询可以单独执行一次，外层表可以重复利用子查询的执行结果。”\n\n“那么一定是相关子连接才会提升了，因为我记得你在说逻辑优化原理的时候说过，相关子连接会产生‘嵌套循环’，这种情况的复杂度是O(N^2)，提升上来的复杂度肯定不会比O(N^2)差，所以提升是有价值的。”小明问到。\n\n听到这些，大明顿时碉堡了，道理虽然是这个道理，但是PostgreSQL偏偏不走寻常路，和自己之前说过的有些许差异，大明羞涩的说：“虽然话是这样说，但PostgreSQL有点不同，PostgreSQL提升了两种类型的子连接，一种是ANY类型的子连接，一种是EXISTS类型的子连接，对于ANY类型的子连接，只提升非相关子连接，而对于EXISTS类型的子连接，则只提升相关子连接。”\n\n小明顿时想起了自己曾和同学说过相关子连接理论，当时把宿舍同学忽悠的五迷三道的，今天大明又说这可能是错的，心里不太爽利，于是怒道：“你之前教我的都有错误，那我和同学吹过的牛岂不是要成为笑柄？我感觉我受到了一万点上海。”\n\n“小明同学不要急”，大明安抚道：“虽然PostgreSQL对于ANY类型只提升非相关的子连接，但它仍然是只提升产生嵌套循环的那种子连接，你看看这个例子。”说着大明在电脑上又敲了一个SQL语句：\n\n```\nSELECT * FROM STUDENT WHERE sno > ANY (SELECT sno from STUDENT);\n```\n\n“这是一个ANY类型的非相关子连接，但是请注意，在>前面的sno实际上产生了一个天然的相关性，这个天然的相关性就会产生嵌套循环，因此是需要提升的。我们再来看另一个语句。”大明把语句中>前面的sno换成了一个常量：\n\n```\nSELECT * FROM STUDENT WHERE 10 > ANY (SELECT sno from STUDENT);\n```\n\n“这个SQL语句中的子连接就不会提升了，因为我们把sno换成了常量，父子之间的相关性被打破了，明白了吗？”\n\n小明点点头，心里想：子连接是否提升取决于相关性，而这个相关性不只是体现在子句里，也体现在表达式里，也就是说只要能产生嵌套循环，那就有提升的必要啊，但是。。。小明灵机一动，问道：“那ANY类型的相关子连接也会产生嵌套循环啊，为什么不提升呢？”\n\n大明说：“这可能有点历史原因了，PostgreSQL提升ANY类型的子连接的方式和EXISTS类型的子连接的方式不同，他提升EXISTS类型的子连接的时候，是直接把子句中的表提上来做形成一个SemiJoin，可是提升ANY类型的子连接的时候，是把整个子句提上来，和父语句中的表做SemiJoin，这时候这个子句就变成了一个子查询，你看这个例子。”说着大明啪啪啪的在电脑上敲了3个语句：\n\n```\n1. SELECT * FROM TEST_A WHERE a > ANY (SELECT a FROM TEST_B WHERE TEST_A.b = TEST_B.b)；\n2. SELECT * FROM TEST_A, (SELECT a FROM TEST_B WHERE TEST_A.b = TEST_B.b) b WHERE TEST_A.a > b.a;\n3. SELECT * FROM TEST_A, LATERAL (SELECT a FROM TEST_B WHERE TEST_A.b = TEST_B.b) b WHERE TEST_A.a > b.a;\n```\n\n“如果按照目前ANY类型子连接先提升成子查询的方式，第1个语句提升之后会变成等价于第2个语句，而第2个语句本身是无法执行的，在比较新的版本的PostgreSQL上支持了LATERAL之后，只要在第2个语句上加上LATERAL，也就是变成第3个语句就能执行了。”大明在屏幕上比划着说。\n\n小明问道：“那岂不是说，有了LATERAL之后，ANY类型的相关子连接也能提升了？”\n\n大明说：“只能说有一部分ANY类型的相关子连接能够提升了，比如我们上面的例1本质上就是能提升的，而且一些商业数据库确实也对这种语句做了提升，但是PostgreSQL数据库目前还没有处理这种情况。”\n\t\n小明打了个哈欠说：“实在是太累了，让我们休息一下吧，查询优化器太复杂了。”\n\n大明笑着说：“坚持不懈就能成功，万一梦想实现了呢?子连接提升之后，还有子查询提升、表达式预处理、外连接消除，不过，在这之前还是让我们先吃个鸡再说吧。”\n","source":"_posts/postgresql-optimizer-outline-3.md","raw":"---\ntitle: PostgreSQL优化器白话(3) - 提升！提升！\ndate: 2020-08-02 09:25:08\n---\n\n小明发现到大明家里问问题不但能收获知识，还能收获大腰子和红酒，于是更加坚定了常来问问题的决心。\n\n小明和大明吃完了午饭，打开电视看一会电视剧，大明又惬意的惬意的抽起了中华烟，小明闻着二手烟有点心烦，就问大明：“哥，你整天抽抽抽，有那么好抽吗？”大明自豪的说：“咋地，咱爷爷抽烟，咱爸爸也抽烟，到我这不能断了香火，你不抽烟是不孝知道不？”<!-- more -->\n\n小明说：“咱爷爷抽烟是在农村种的烟叶，自给自足，还省钱，你也干脆回农村种烟叶，你这中华烟和农村的自己卷的烟叶，能有什么区别？”\n\n大明看电视剧正看得起劲，心不在焉的说：“自己种的烟叶直接用报纸卷了抽，没有过滤嘴，会吸入有害颗粒物，而且烟叶的味道也不如现在改进的香烟。”说到这里大明好像想到了些什么，继续说：“这就像是查询优化器的逻辑优化，查询树输入之后，需要进行持续的改进，无论是自己用报纸卷的烟，还是在超市买的成品烟，它都是香烟，但是通过改进之后，香烟的毒害作用更低、香型更丰富了，逻辑优化也是这个道理，通过改进查询树，能够得到一个更‘好’的查询树。”\n\n“哦，那逻辑优化是如何在已有的查询树上增加香型的呢？”\n\n大明感觉电视剧没办法看下去了，于是拿起遥控器关了电视，继续说：“我总结，PostgreSQL在逻辑优化阶段有这么几个重要的优化：子查询&子连接提升、表达式预处理、外连接消除、谓词下推、连接顺序交换、等价类推理。”大明又抽了一口烟，接着说到：“从代码逻辑上来看，我们还可以把子查询&子连接提升、表达式预处理、外连接消除叫做逻辑重写优化，因为他们主要是对查询树进行改造，而后面的谓词下推、连接顺序交换、等价类推理则可以称之为逻辑分解优化，他们已经把查询树蹂躏的不成样子了，已经到了看香烟不是香烟的地步了。”\n\n“可是我们的数据库原理课上并没有说有逻辑重写优化和逻辑分解优化啊？”\n\n“嗯，是的，这是我自己根据PostgreSQL的源代码的特征自己总结的，不过它能比较形象的将现有的逻辑优化区分开来，这样就能更好的对逻辑优化进行提炼、总结、分析。”大明想了一下觉得如果把所有的逻辑优化的规则都说完有点多，决定选择其中的一两个说一下，于是对小明说道：“我们就从中挑选一两个详细的说明一下吧，我们先从子查询&子连接的提升开始说起。”\n\n“那。。。子查询和子连接有什么区别呢？我们在数据库原理课里只讲了子查询，没有子连接的概念，这该怎么解释呢？”小明不解的问。\n\n大明去书柜里拿出了《数据库系统实现》这本书，然后翻开了对应的章节，说道：“通常数据库原理书籍中说的子查询，指的是PostgreSQL数据库中的子连接。你看，《数据库系统实现》中说的是从条件中去除子查询，但是PostgreSQL把这种情况归类为子连接。”\n\n“那在PostgreSQL是如何区分子查询和子连接的呢？”大明自问自答道：“在实际应用中可以通过子句所处的位置来区分子连接和子查询，出现在FROM关键字后的子句是子查询语句，出现在WHERE/ON等约束条件中或投影中的子句是子连接语句。”说着大明快速的在电脑上打开了记事本，敲入了几个SQL语句：\n\n```\n1. SELECT * FROM STUDENT, (SELECT * FROM SCORE) as sc;\n2. SELECT (SELECT AVG(degree) FROM SCORE), sname FROM STUDENT;\n3. SELECT * FROM STUDENT WHERE EXISTS (SELECT A FROM SCORE WHERE SCORE.sno = STUDENT.sno);\n```\n\n“这些SQL语句中哪个是子查询？哪个是子连接？”\n\n小明看了一下，然后说：“1是子查询，2和3是子连接，语句1里面的子句出现在FROM后面，它是以‘表’的形式存在的，是子查询，2和3的子句出现在投影和约束条件中，是以表达式的形式存在的，是子连接。”小明不但答对了问题，而且还对问题的答案做了扩展，大明感到很一颗赛艇，于是调侃道：“腰间盘同学，你坐下，你太突出了。”\n\n然后大明正一正颜色，继续说道“从大的方向上分类，子查询还可以分为相关子连接和非相关子连接，相关子连接是指在子查询语句中引用了外层表的列属性，这就导致外层表每获得一个元组，子查询就需要重新执行一次；而非相关子查询是指在子查询语句是独立的，和外层的表没有直接的关联，子查询可以单独执行一次，外层表可以重复利用子查询的执行结果。”\n\n“那么一定是相关子连接才会提升了，因为我记得你在说逻辑优化原理的时候说过，相关子连接会产生‘嵌套循环’，这种情况的复杂度是O(N^2)，提升上来的复杂度肯定不会比O(N^2)差，所以提升是有价值的。”小明问到。\n\n听到这些，大明顿时碉堡了，道理虽然是这个道理，但是PostgreSQL偏偏不走寻常路，和自己之前说过的有些许差异，大明羞涩的说：“虽然话是这样说，但PostgreSQL有点不同，PostgreSQL提升了两种类型的子连接，一种是ANY类型的子连接，一种是EXISTS类型的子连接，对于ANY类型的子连接，只提升非相关子连接，而对于EXISTS类型的子连接，则只提升相关子连接。”\n\n小明顿时想起了自己曾和同学说过相关子连接理论，当时把宿舍同学忽悠的五迷三道的，今天大明又说这可能是错的，心里不太爽利，于是怒道：“你之前教我的都有错误，那我和同学吹过的牛岂不是要成为笑柄？我感觉我受到了一万点上海。”\n\n“小明同学不要急”，大明安抚道：“虽然PostgreSQL对于ANY类型只提升非相关的子连接，但它仍然是只提升产生嵌套循环的那种子连接，你看看这个例子。”说着大明在电脑上又敲了一个SQL语句：\n\n```\nSELECT * FROM STUDENT WHERE sno > ANY (SELECT sno from STUDENT);\n```\n\n“这是一个ANY类型的非相关子连接，但是请注意，在>前面的sno实际上产生了一个天然的相关性，这个天然的相关性就会产生嵌套循环，因此是需要提升的。我们再来看另一个语句。”大明把语句中>前面的sno换成了一个常量：\n\n```\nSELECT * FROM STUDENT WHERE 10 > ANY (SELECT sno from STUDENT);\n```\n\n“这个SQL语句中的子连接就不会提升了，因为我们把sno换成了常量，父子之间的相关性被打破了，明白了吗？”\n\n小明点点头，心里想：子连接是否提升取决于相关性，而这个相关性不只是体现在子句里，也体现在表达式里，也就是说只要能产生嵌套循环，那就有提升的必要啊，但是。。。小明灵机一动，问道：“那ANY类型的相关子连接也会产生嵌套循环啊，为什么不提升呢？”\n\n大明说：“这可能有点历史原因了，PostgreSQL提升ANY类型的子连接的方式和EXISTS类型的子连接的方式不同，他提升EXISTS类型的子连接的时候，是直接把子句中的表提上来做形成一个SemiJoin，可是提升ANY类型的子连接的时候，是把整个子句提上来，和父语句中的表做SemiJoin，这时候这个子句就变成了一个子查询，你看这个例子。”说着大明啪啪啪的在电脑上敲了3个语句：\n\n```\n1. SELECT * FROM TEST_A WHERE a > ANY (SELECT a FROM TEST_B WHERE TEST_A.b = TEST_B.b)；\n2. SELECT * FROM TEST_A, (SELECT a FROM TEST_B WHERE TEST_A.b = TEST_B.b) b WHERE TEST_A.a > b.a;\n3. SELECT * FROM TEST_A, LATERAL (SELECT a FROM TEST_B WHERE TEST_A.b = TEST_B.b) b WHERE TEST_A.a > b.a;\n```\n\n“如果按照目前ANY类型子连接先提升成子查询的方式，第1个语句提升之后会变成等价于第2个语句，而第2个语句本身是无法执行的，在比较新的版本的PostgreSQL上支持了LATERAL之后，只要在第2个语句上加上LATERAL，也就是变成第3个语句就能执行了。”大明在屏幕上比划着说。\n\n小明问道：“那岂不是说，有了LATERAL之后，ANY类型的相关子连接也能提升了？”\n\n大明说：“只能说有一部分ANY类型的相关子连接能够提升了，比如我们上面的例1本质上就是能提升的，而且一些商业数据库确实也对这种语句做了提升，但是PostgreSQL数据库目前还没有处理这种情况。”\n\t\n小明打了个哈欠说：“实在是太累了，让我们休息一下吧，查询优化器太复杂了。”\n\n大明笑着说：“坚持不懈就能成功，万一梦想实现了呢?子连接提升之后，还有子查询提升、表达式预处理、外连接消除，不过，在这之前还是让我们先吃个鸡再说吧。”\n","slug":"postgresql-optimizer-outline-3","published":1,"updated":"2020-08-02T01:54:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdchg8jg0003r2s6aul442ma","content":"<p>小明发现到大明家里问问题不但能收获知识，还能收获大腰子和红酒，于是更加坚定了常来问问题的决心。</p>\n<p>小明和大明吃完了午饭，打开电视看一会电视剧，大明又惬意的惬意的抽起了中华烟，小明闻着二手烟有点心烦，就问大明：“哥，你整天抽抽抽，有那么好抽吗？”大明自豪的说：“咋地，咱爷爷抽烟，咱爸爸也抽烟，到我这不能断了香火，你不抽烟是不孝知道不？”<a id=\"more\"></a></p>\n<p>小明说：“咱爷爷抽烟是在农村种的烟叶，自给自足，还省钱，你也干脆回农村种烟叶，你这中华烟和农村的自己卷的烟叶，能有什么区别？”</p>\n<p>大明看电视剧正看得起劲，心不在焉的说：“自己种的烟叶直接用报纸卷了抽，没有过滤嘴，会吸入有害颗粒物，而且烟叶的味道也不如现在改进的香烟。”说到这里大明好像想到了些什么，继续说：“这就像是查询优化器的逻辑优化，查询树输入之后，需要进行持续的改进，无论是自己用报纸卷的烟，还是在超市买的成品烟，它都是香烟，但是通过改进之后，香烟的毒害作用更低、香型更丰富了，逻辑优化也是这个道理，通过改进查询树，能够得到一个更‘好’的查询树。”</p>\n<p>“哦，那逻辑优化是如何在已有的查询树上增加香型的呢？”</p>\n<p>大明感觉电视剧没办法看下去了，于是拿起遥控器关了电视，继续说：“我总结，PostgreSQL在逻辑优化阶段有这么几个重要的优化：子查询&amp;子连接提升、表达式预处理、外连接消除、谓词下推、连接顺序交换、等价类推理。”大明又抽了一口烟，接着说到：“从代码逻辑上来看，我们还可以把子查询&amp;子连接提升、表达式预处理、外连接消除叫做逻辑重写优化，因为他们主要是对查询树进行改造，而后面的谓词下推、连接顺序交换、等价类推理则可以称之为逻辑分解优化，他们已经把查询树蹂躏的不成样子了，已经到了看香烟不是香烟的地步了。”</p>\n<p>“可是我们的数据库原理课上并没有说有逻辑重写优化和逻辑分解优化啊？”</p>\n<p>“嗯，是的，这是我自己根据PostgreSQL的源代码的特征自己总结的，不过它能比较形象的将现有的逻辑优化区分开来，这样就能更好的对逻辑优化进行提炼、总结、分析。”大明想了一下觉得如果把所有的逻辑优化的规则都说完有点多，决定选择其中的一两个说一下，于是对小明说道：“我们就从中挑选一两个详细的说明一下吧，我们先从子查询&amp;子连接的提升开始说起。”</p>\n<p>“那。。。子查询和子连接有什么区别呢？我们在数据库原理课里只讲了子查询，没有子连接的概念，这该怎么解释呢？”小明不解的问。</p>\n<p>大明去书柜里拿出了《数据库系统实现》这本书，然后翻开了对应的章节，说道：“通常数据库原理书籍中说的子查询，指的是PostgreSQL数据库中的子连接。你看，《数据库系统实现》中说的是从条件中去除子查询，但是PostgreSQL把这种情况归类为子连接。”</p>\n<p>“那在PostgreSQL是如何区分子查询和子连接的呢？”大明自问自答道：“在实际应用中可以通过子句所处的位置来区分子连接和子查询，出现在FROM关键字后的子句是子查询语句，出现在WHERE/ON等约束条件中或投影中的子句是子连接语句。”说着大明快速的在电脑上打开了记事本，敲入了几个SQL语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. SELECT * FROM STUDENT, (SELECT * FROM SCORE) as sc;</span><br><span class=\"line\">2. SELECT (SELECT AVG(degree) FROM SCORE), sname FROM STUDENT;</span><br><span class=\"line\">3. SELECT * FROM STUDENT WHERE EXISTS (SELECT A FROM SCORE WHERE SCORE.sno &#x3D; STUDENT.sno);</span><br></pre></td></tr></table></figure>\n\n<p>“这些SQL语句中哪个是子查询？哪个是子连接？”</p>\n<p>小明看了一下，然后说：“1是子查询，2和3是子连接，语句1里面的子句出现在FROM后面，它是以‘表’的形式存在的，是子查询，2和3的子句出现在投影和约束条件中，是以表达式的形式存在的，是子连接。”小明不但答对了问题，而且还对问题的答案做了扩展，大明感到很一颗赛艇，于是调侃道：“腰间盘同学，你坐下，你太突出了。”</p>\n<p>然后大明正一正颜色，继续说道“从大的方向上分类，子查询还可以分为相关子连接和非相关子连接，相关子连接是指在子查询语句中引用了外层表的列属性，这就导致外层表每获得一个元组，子查询就需要重新执行一次；而非相关子查询是指在子查询语句是独立的，和外层的表没有直接的关联，子查询可以单独执行一次，外层表可以重复利用子查询的执行结果。”</p>\n<p>“那么一定是相关子连接才会提升了，因为我记得你在说逻辑优化原理的时候说过，相关子连接会产生‘嵌套循环’，这种情况的复杂度是O(N^2)，提升上来的复杂度肯定不会比O(N^2)差，所以提升是有价值的。”小明问到。</p>\n<p>听到这些，大明顿时碉堡了，道理虽然是这个道理，但是PostgreSQL偏偏不走寻常路，和自己之前说过的有些许差异，大明羞涩的说：“虽然话是这样说，但PostgreSQL有点不同，PostgreSQL提升了两种类型的子连接，一种是ANY类型的子连接，一种是EXISTS类型的子连接，对于ANY类型的子连接，只提升非相关子连接，而对于EXISTS类型的子连接，则只提升相关子连接。”</p>\n<p>小明顿时想起了自己曾和同学说过相关子连接理论，当时把宿舍同学忽悠的五迷三道的，今天大明又说这可能是错的，心里不太爽利，于是怒道：“你之前教我的都有错误，那我和同学吹过的牛岂不是要成为笑柄？我感觉我受到了一万点上海。”</p>\n<p>“小明同学不要急”，大明安抚道：“虽然PostgreSQL对于ANY类型只提升非相关的子连接，但它仍然是只提升产生嵌套循环的那种子连接，你看看这个例子。”说着大明在电脑上又敲了一个SQL语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM STUDENT WHERE sno &gt; ANY (SELECT sno from STUDENT);</span><br></pre></td></tr></table></figure>\n\n<p>“这是一个ANY类型的非相关子连接，但是请注意，在&gt;前面的sno实际上产生了一个天然的相关性，这个天然的相关性就会产生嵌套循环，因此是需要提升的。我们再来看另一个语句。”大明把语句中&gt;前面的sno换成了一个常量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM STUDENT WHERE 10 &gt; ANY (SELECT sno from STUDENT);</span><br></pre></td></tr></table></figure>\n\n<p>“这个SQL语句中的子连接就不会提升了，因为我们把sno换成了常量，父子之间的相关性被打破了，明白了吗？”</p>\n<p>小明点点头，心里想：子连接是否提升取决于相关性，而这个相关性不只是体现在子句里，也体现在表达式里，也就是说只要能产生嵌套循环，那就有提升的必要啊，但是。。。小明灵机一动，问道：“那ANY类型的相关子连接也会产生嵌套循环啊，为什么不提升呢？”</p>\n<p>大明说：“这可能有点历史原因了，PostgreSQL提升ANY类型的子连接的方式和EXISTS类型的子连接的方式不同，他提升EXISTS类型的子连接的时候，是直接把子句中的表提上来做形成一个SemiJoin，可是提升ANY类型的子连接的时候，是把整个子句提上来，和父语句中的表做SemiJoin，这时候这个子句就变成了一个子查询，你看这个例子。”说着大明啪啪啪的在电脑上敲了3个语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. SELECT * FROM TEST_A WHERE a &gt; ANY (SELECT a FROM TEST_B WHERE TEST_A.b &#x3D; TEST_B.b)；</span><br><span class=\"line\">2. SELECT * FROM TEST_A, (SELECT a FROM TEST_B WHERE TEST_A.b &#x3D; TEST_B.b) b WHERE TEST_A.a &gt; b.a;</span><br><span class=\"line\">3. SELECT * FROM TEST_A, LATERAL (SELECT a FROM TEST_B WHERE TEST_A.b &#x3D; TEST_B.b) b WHERE TEST_A.a &gt; b.a;</span><br></pre></td></tr></table></figure>\n\n<p>“如果按照目前ANY类型子连接先提升成子查询的方式，第1个语句提升之后会变成等价于第2个语句，而第2个语句本身是无法执行的，在比较新的版本的PostgreSQL上支持了LATERAL之后，只要在第2个语句上加上LATERAL，也就是变成第3个语句就能执行了。”大明在屏幕上比划着说。</p>\n<p>小明问道：“那岂不是说，有了LATERAL之后，ANY类型的相关子连接也能提升了？”</p>\n<p>大明说：“只能说有一部分ANY类型的相关子连接能够提升了，比如我们上面的例1本质上就是能提升的，而且一些商业数据库确实也对这种语句做了提升，但是PostgreSQL数据库目前还没有处理这种情况。”</p>\n<p>小明打了个哈欠说：“实在是太累了，让我们休息一下吧，查询优化器太复杂了。”</p>\n<p>大明笑着说：“坚持不懈就能成功，万一梦想实现了呢?子连接提升之后，还有子查询提升、表达式预处理、外连接消除，不过，在这之前还是让我们先吃个鸡再说吧。”</p>\n","site":{"data":{}},"excerpt":"<p>小明发现到大明家里问问题不但能收获知识，还能收获大腰子和红酒，于是更加坚定了常来问问题的决心。</p>\n<p>小明和大明吃完了午饭，打开电视看一会电视剧，大明又惬意的惬意的抽起了中华烟，小明闻着二手烟有点心烦，就问大明：“哥，你整天抽抽抽，有那么好抽吗？”大明自豪的说：“咋地，咱爷爷抽烟，咱爸爸也抽烟，到我这不能断了香火，你不抽烟是不孝知道不？”</p>","more":"<p></p>\n<p>小明说：“咱爷爷抽烟是在农村种的烟叶，自给自足，还省钱，你也干脆回农村种烟叶，你这中华烟和农村的自己卷的烟叶，能有什么区别？”</p>\n<p>大明看电视剧正看得起劲，心不在焉的说：“自己种的烟叶直接用报纸卷了抽，没有过滤嘴，会吸入有害颗粒物，而且烟叶的味道也不如现在改进的香烟。”说到这里大明好像想到了些什么，继续说：“这就像是查询优化器的逻辑优化，查询树输入之后，需要进行持续的改进，无论是自己用报纸卷的烟，还是在超市买的成品烟，它都是香烟，但是通过改进之后，香烟的毒害作用更低、香型更丰富了，逻辑优化也是这个道理，通过改进查询树，能够得到一个更‘好’的查询树。”</p>\n<p>“哦，那逻辑优化是如何在已有的查询树上增加香型的呢？”</p>\n<p>大明感觉电视剧没办法看下去了，于是拿起遥控器关了电视，继续说：“我总结，PostgreSQL在逻辑优化阶段有这么几个重要的优化：子查询&amp;子连接提升、表达式预处理、外连接消除、谓词下推、连接顺序交换、等价类推理。”大明又抽了一口烟，接着说到：“从代码逻辑上来看，我们还可以把子查询&amp;子连接提升、表达式预处理、外连接消除叫做逻辑重写优化，因为他们主要是对查询树进行改造，而后面的谓词下推、连接顺序交换、等价类推理则可以称之为逻辑分解优化，他们已经把查询树蹂躏的不成样子了，已经到了看香烟不是香烟的地步了。”</p>\n<p>“可是我们的数据库原理课上并没有说有逻辑重写优化和逻辑分解优化啊？”</p>\n<p>“嗯，是的，这是我自己根据PostgreSQL的源代码的特征自己总结的，不过它能比较形象的将现有的逻辑优化区分开来，这样就能更好的对逻辑优化进行提炼、总结、分析。”大明想了一下觉得如果把所有的逻辑优化的规则都说完有点多，决定选择其中的一两个说一下，于是对小明说道：“我们就从中挑选一两个详细的说明一下吧，我们先从子查询&amp;子连接的提升开始说起。”</p>\n<p>“那。。。子查询和子连接有什么区别呢？我们在数据库原理课里只讲了子查询，没有子连接的概念，这该怎么解释呢？”小明不解的问。</p>\n<p>大明去书柜里拿出了《数据库系统实现》这本书，然后翻开了对应的章节，说道：“通常数据库原理书籍中说的子查询，指的是PostgreSQL数据库中的子连接。你看，《数据库系统实现》中说的是从条件中去除子查询，但是PostgreSQL把这种情况归类为子连接。”</p>\n<p>“那在PostgreSQL是如何区分子查询和子连接的呢？”大明自问自答道：“在实际应用中可以通过子句所处的位置来区分子连接和子查询，出现在FROM关键字后的子句是子查询语句，出现在WHERE/ON等约束条件中或投影中的子句是子连接语句。”说着大明快速的在电脑上打开了记事本，敲入了几个SQL语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. SELECT * FROM STUDENT, (SELECT * FROM SCORE) as sc;</span><br><span class=\"line\">2. SELECT (SELECT AVG(degree) FROM SCORE), sname FROM STUDENT;</span><br><span class=\"line\">3. SELECT * FROM STUDENT WHERE EXISTS (SELECT A FROM SCORE WHERE SCORE.sno &#x3D; STUDENT.sno);</span><br></pre></td></tr></table></figure>\n\n<p>“这些SQL语句中哪个是子查询？哪个是子连接？”</p>\n<p>小明看了一下，然后说：“1是子查询，2和3是子连接，语句1里面的子句出现在FROM后面，它是以‘表’的形式存在的，是子查询，2和3的子句出现在投影和约束条件中，是以表达式的形式存在的，是子连接。”小明不但答对了问题，而且还对问题的答案做了扩展，大明感到很一颗赛艇，于是调侃道：“腰间盘同学，你坐下，你太突出了。”</p>\n<p>然后大明正一正颜色，继续说道“从大的方向上分类，子查询还可以分为相关子连接和非相关子连接，相关子连接是指在子查询语句中引用了外层表的列属性，这就导致外层表每获得一个元组，子查询就需要重新执行一次；而非相关子查询是指在子查询语句是独立的，和外层的表没有直接的关联，子查询可以单独执行一次，外层表可以重复利用子查询的执行结果。”</p>\n<p>“那么一定是相关子连接才会提升了，因为我记得你在说逻辑优化原理的时候说过，相关子连接会产生‘嵌套循环’，这种情况的复杂度是O(N^2)，提升上来的复杂度肯定不会比O(N^2)差，所以提升是有价值的。”小明问到。</p>\n<p>听到这些，大明顿时碉堡了，道理虽然是这个道理，但是PostgreSQL偏偏不走寻常路，和自己之前说过的有些许差异，大明羞涩的说：“虽然话是这样说，但PostgreSQL有点不同，PostgreSQL提升了两种类型的子连接，一种是ANY类型的子连接，一种是EXISTS类型的子连接，对于ANY类型的子连接，只提升非相关子连接，而对于EXISTS类型的子连接，则只提升相关子连接。”</p>\n<p>小明顿时想起了自己曾和同学说过相关子连接理论，当时把宿舍同学忽悠的五迷三道的，今天大明又说这可能是错的，心里不太爽利，于是怒道：“你之前教我的都有错误，那我和同学吹过的牛岂不是要成为笑柄？我感觉我受到了一万点上海。”</p>\n<p>“小明同学不要急”，大明安抚道：“虽然PostgreSQL对于ANY类型只提升非相关的子连接，但它仍然是只提升产生嵌套循环的那种子连接，你看看这个例子。”说着大明在电脑上又敲了一个SQL语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM STUDENT WHERE sno &gt; ANY (SELECT sno from STUDENT);</span><br></pre></td></tr></table></figure>\n\n<p>“这是一个ANY类型的非相关子连接，但是请注意，在&gt;前面的sno实际上产生了一个天然的相关性，这个天然的相关性就会产生嵌套循环，因此是需要提升的。我们再来看另一个语句。”大明把语句中&gt;前面的sno换成了一个常量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM STUDENT WHERE 10 &gt; ANY (SELECT sno from STUDENT);</span><br></pre></td></tr></table></figure>\n\n<p>“这个SQL语句中的子连接就不会提升了，因为我们把sno换成了常量，父子之间的相关性被打破了，明白了吗？”</p>\n<p>小明点点头，心里想：子连接是否提升取决于相关性，而这个相关性不只是体现在子句里，也体现在表达式里，也就是说只要能产生嵌套循环，那就有提升的必要啊，但是。。。小明灵机一动，问道：“那ANY类型的相关子连接也会产生嵌套循环啊，为什么不提升呢？”</p>\n<p>大明说：“这可能有点历史原因了，PostgreSQL提升ANY类型的子连接的方式和EXISTS类型的子连接的方式不同，他提升EXISTS类型的子连接的时候，是直接把子句中的表提上来做形成一个SemiJoin，可是提升ANY类型的子连接的时候，是把整个子句提上来，和父语句中的表做SemiJoin，这时候这个子句就变成了一个子查询，你看这个例子。”说着大明啪啪啪的在电脑上敲了3个语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. SELECT * FROM TEST_A WHERE a &gt; ANY (SELECT a FROM TEST_B WHERE TEST_A.b &#x3D; TEST_B.b)；</span><br><span class=\"line\">2. SELECT * FROM TEST_A, (SELECT a FROM TEST_B WHERE TEST_A.b &#x3D; TEST_B.b) b WHERE TEST_A.a &gt; b.a;</span><br><span class=\"line\">3. SELECT * FROM TEST_A, LATERAL (SELECT a FROM TEST_B WHERE TEST_A.b &#x3D; TEST_B.b) b WHERE TEST_A.a &gt; b.a;</span><br></pre></td></tr></table></figure>\n\n<p>“如果按照目前ANY类型子连接先提升成子查询的方式，第1个语句提升之后会变成等价于第2个语句，而第2个语句本身是无法执行的，在比较新的版本的PostgreSQL上支持了LATERAL之后，只要在第2个语句上加上LATERAL，也就是变成第3个语句就能执行了。”大明在屏幕上比划着说。</p>\n<p>小明问道：“那岂不是说，有了LATERAL之后，ANY类型的相关子连接也能提升了？”</p>\n<p>大明说：“只能说有一部分ANY类型的相关子连接能够提升了，比如我们上面的例1本质上就是能提升的，而且一些商业数据库确实也对这种语句做了提升，但是PostgreSQL数据库目前还没有处理这种情况。”</p>\n<p>小明打了个哈欠说：“实在是太累了，让我们休息一下吧，查询优化器太复杂了。”</p>\n<p>大明笑着说：“坚持不懈就能成功，万一梦想实现了呢?子连接提升之后，还有子查询提升、表达式预处理、外连接消除，不过，在这之前还是让我们先吃个鸡再说吧。”</p>"},{"title":"PostgreSQL优化器白话(4) - 下推！下推！","date":"2020-08-04T23:06:30.000Z","_content":"\n小明在大明家的书房里摆好了纸砚，在一份过期的报纸上挥毫泼墨：“精推细敲慎思量，雄关漫道两茫茫，夜半挑灯读诗酒，莫谈肉串与烤馕。”大明看了之后笑道：“好诗好诗，来，让我们继续夜半挑灯读优化，莫与扯淡诉衷肠。”\n\n小明说：“再歇会吧，我觉得要深度了解查询优化没希望了。”大明看出了小明对查询优化产生了一点畏难情绪，因为小明本来以为通过大明的讲解能够快速的理解查询优化的本质，但是他通过几次听取大明的讲解之后发现，查询优化器远不是几次讲解就能解决的，大明目前给他讲解的还只是在应用层面的讲解，还没有深入到分析源码阶段，仅仅如此，对小明来说理解上就已经有些困难了，看来要想深度的了解查询优化器，还需要下更大的功夫才行。<!-- more -->\n\t\n大明说：“啥叫成功？成功就是在你坚持不下去的时候再坚持一下，来吧，Let’s继续。”说着拉着小明来到客厅，继续打开了电脑，“我们继续说点啥呢？上次说到了子连接，这次我们简单说说选择下推和等价类吧。”\n\n小明想了想说：“选择下推和等价类是逻辑分解优化中的内容了，可是逻辑重写优化里还有子查询提升、表达式预处理、外连接消除这些大块头你还没有给我讲解过吖。”\n\n大明说：“这些先留给你自己去理解，如果理解不了再来找我吧。逻辑优化的规则实际上还是比较多的，但是是可以逐个击破的，也就是他们之间通常而言并没有多大的关联，我们不打算在这上面纠缠太多时间，我相信以你自己的能力把他们搞定是没有问题的。”\n\n“哦，我觉得是你怕我在你家呆太长时间，把你吃穷吧？”小明偷笑着问。\n\n“是的，半大小子吃死老子，你这饭桶太能吃了，吃饭的速度比选择下推的速度还要快，午饭都被你吃了，我今天中午都没吃饱啊。”\n\n“我记得你说过，选择下推是为了尽早的过滤数据，这样就能在上层结点降低计算量，是吧？”\n\n“是的。”大明点了点头，“还是通过一个关系代数的示例来说明一下它吧，顺便我们把等价类推理也可以说一说，比如说我们想要获得编号为5的老师承担的所有的课程名字，我们可以给出它的关系代数表达式。”说着大明在电脑上敲了一个关系代数表达式：\n\n```\nΠcname (σTEACHER.tno=5∧TEACHER.tno=COURSE.tno (TEACHER×COURSE))\n```\n\n“小明，你看这个关系代数表达式怎么下推选择操作？”\n\n小明看着关系代数表达式思考了一会，说：“我看这个TEACHER.tno = 5比较可疑，你看这个关系代数表达式，先做了TEACHER×COURSE，也就是先做了卡氏积，我要是把TEACHER.tno = 5放到TEACHER上先把一些数据过滤掉，岂不是。。。完美！”说着小明也在电脑上敲出了把TEACHER.tno = 5下推之后的关系代数表达式。\n\n```\nΠcname (σTEACHER.tno=COURSE.tno (σTEACHER.tno=5(TEACHER)×COURSE))\n```\n\n大明说；“对的，你这样下推下来，的确能降低计算量，你这应用的是关系代数表达式中的分配率σF(A × B) == σF1(A) × σF2(B)，那你看看，既然下推这么好，是不是投影也能下推？”小明看了一下，关系代数表达式中值需要对cname进行投影，顿时想到了，COURSE表虽然有很多个列，但是我们只需要使用cname就够了嘛，于是小明在电脑上敲了投影下推的关系代数表达式。\n\n```\nΠcname (σTEACHER.tno=COURSE.tno (σTEACHER.tno=5(TEACHER)× Πcname(COURSE)))\n```\n\n大明拍了小明的头一下说：“笨蛋，你这样下推投影，TEACHER.tno=COURSE.tno还有办法做吗？”小明顿时领悟了，如果只在COURSE上对cname做投影时不行的，上层结点所有的表达式都需要考虑到，于是修改了表达式：\n\n```\nΠcname (σTEACHER.tno=COURSE.tno (σTEACHER.tno=5(TEACHER)× Πcname, tno(COURSE)))\n```\n\n“这还差不多。”大明笑着说：“这是使用的投影的串接率，也是一个非常重要的关系代数等价规则，目前我们对这个表达式的优化主要是使用了选择下推，和投影下推，如果用SQL语句来表示，就像这样。”大明在电脑的记事本上快速的打印出了两个SQL语句：\n\n```\nSELECT sname FROM TEACHER t, COURSE c WHERE t.tno = 5 AND t.tno = c.tno;\nSELECT sname FROM (SELECT * FROM TEACHER WHERE tno = 5) tt, (SELECT cname, tno FROM COURSE) cc WHERE tt.tno = cc.tno;\n```\n\n“你看这两个语句，就是谓词下推和投影下推前后的对照语句。在做卡氏积之前，先做了过滤，这样笛卡尔积的计算量会变小。”\n小明仔细的观察着代数表达式和这两个SQL语句，他发现一个问题，就是关系代数表达式中有TEACHER.tno = 5和TEACHER.tno = COURSE.tno这样的两个约束条件，这是不是意味着COURSE.tno也应该等于5呢？小明然后试着在电脑上写了一个SQL语句：\n\n```\nSELECT sname FROM (SELECT * FROM TEACHER WHERE tno = 5) tt, (SELECT cname, tno FROM COURSE WHERE tno=5) cc WHERE tt.tno = cc.tno;\n```\n\n然后小明说：“你看，由于有TEACHER.tno = 5和TEACHER.tno = COURSE.tno这样的两个约束条件，我们可以是不是可以推理出一个新的COURSE.tno = 5的新的约束条件来呢，这样我们还可以把这个条件下推到COURSE表上，这样也能降低笛卡尔积的计算量。”\n\n大明说：“是的，这就是等价推理，PostgreSQL数据库在查询优化的过程中，会将约束条件中等价的部分都记录到等价类中，这样就能根据等价类生成新的约束条件出来，比如示例的语句中就会产生一个等价类{TEACHER.tno, COURSE.tno, 5}，这是一个含有常量的等价类，是查询优化器比较喜欢的等价类，这种等价类可以得到列属性和常量组合成的约束条件，通常都是能下推的。”\n\n小明心里很高兴，自己通过仔细观察，得到了等价类的优化，感觉自己有了学习的动力，心里美滋滋的，然后就问大明：“那上面的SQL语句还有什么可优化的吗？”\n\n大明观察了一下这个语句，然后说：“你看，我们已经在TEACHER表上进行了TEACHER.tno = 5的过滤，在COURSE表上也做了COURSE.tno = 5的过滤，这样就说明在做笛卡尔积的时候，实际上已经确定了TEACHER.tno = COURSE.tno = 5，也就是说TEACHER.tno = COURSE.tno这个约束条件已经隐含成立了，也就没什么用了，我们可以把它去掉，最终形成一个这样的SQL语句。”大明在记事本中敲下了最终的语句：\n\n```\nSELECT sname FROM (SELECT * FROM TEACHER WHERE tno = 5) tt, (SELECT cname, tno FROM COURSE WHERE tno=5) cc；\n```\n\n同时也敲出了这个语句对应的关系代数表达式：\n\n```\nΠcname (σTEACHER.tno=5(TEACHER)× Πcname, tno(σCOURSE.tno=5(COURSE)))\n```\n\n然后大明说：“经过选择下推、投影下推和等价类推理，我们对这个SQL语句或者说关系代数表达式进行了优化，最终降低了计算量。”\n \n![](./postgresql-optimizer-outline-4/1.png) \n\n![](./postgresql-optimizer-outline-4/1.png) \n \n\n小明感觉对谓词下推已经理解了，然后说：“看上去也不复杂嘛，我发现了可以下推的选择我就下推，完全没有问题啊。”大明笑着说：“甚矣，我从未见过如此厚颜无耻之人，我们现在看的这个例子，只不过是最简单的一种情况啊，你就这样大言不惭，你的人生字典里还有羞耻二字吗？”\n\n小明愤愤的说：“我的人生没有字典。。。”\n\n大明问道：“我们这个例子有一个问题，就是他是内连接，因此我们可以肆意妄为的将选择下推下来，可以没羞没臊的做等价类推理，但是如果是外连接，那还能这么做吗？”\n\n小明顿时陷入了苦苦的沉思。\n","source":"_posts/postgresql-optimizer-outline-4.md","raw":"---\ntitle: PostgreSQL优化器白话(4) - 下推！下推！\ndate: 2020-08-05 07:06:30\ntags:\n---\n\n小明在大明家的书房里摆好了纸砚，在一份过期的报纸上挥毫泼墨：“精推细敲慎思量，雄关漫道两茫茫，夜半挑灯读诗酒，莫谈肉串与烤馕。”大明看了之后笑道：“好诗好诗，来，让我们继续夜半挑灯读优化，莫与扯淡诉衷肠。”\n\n小明说：“再歇会吧，我觉得要深度了解查询优化没希望了。”大明看出了小明对查询优化产生了一点畏难情绪，因为小明本来以为通过大明的讲解能够快速的理解查询优化的本质，但是他通过几次听取大明的讲解之后发现，查询优化器远不是几次讲解就能解决的，大明目前给他讲解的还只是在应用层面的讲解，还没有深入到分析源码阶段，仅仅如此，对小明来说理解上就已经有些困难了，看来要想深度的了解查询优化器，还需要下更大的功夫才行。<!-- more -->\n\t\n大明说：“啥叫成功？成功就是在你坚持不下去的时候再坚持一下，来吧，Let’s继续。”说着拉着小明来到客厅，继续打开了电脑，“我们继续说点啥呢？上次说到了子连接，这次我们简单说说选择下推和等价类吧。”\n\n小明想了想说：“选择下推和等价类是逻辑分解优化中的内容了，可是逻辑重写优化里还有子查询提升、表达式预处理、外连接消除这些大块头你还没有给我讲解过吖。”\n\n大明说：“这些先留给你自己去理解，如果理解不了再来找我吧。逻辑优化的规则实际上还是比较多的，但是是可以逐个击破的，也就是他们之间通常而言并没有多大的关联，我们不打算在这上面纠缠太多时间，我相信以你自己的能力把他们搞定是没有问题的。”\n\n“哦，我觉得是你怕我在你家呆太长时间，把你吃穷吧？”小明偷笑着问。\n\n“是的，半大小子吃死老子，你这饭桶太能吃了，吃饭的速度比选择下推的速度还要快，午饭都被你吃了，我今天中午都没吃饱啊。”\n\n“我记得你说过，选择下推是为了尽早的过滤数据，这样就能在上层结点降低计算量，是吧？”\n\n“是的。”大明点了点头，“还是通过一个关系代数的示例来说明一下它吧，顺便我们把等价类推理也可以说一说，比如说我们想要获得编号为5的老师承担的所有的课程名字，我们可以给出它的关系代数表达式。”说着大明在电脑上敲了一个关系代数表达式：\n\n```\nΠcname (σTEACHER.tno=5∧TEACHER.tno=COURSE.tno (TEACHER×COURSE))\n```\n\n“小明，你看这个关系代数表达式怎么下推选择操作？”\n\n小明看着关系代数表达式思考了一会，说：“我看这个TEACHER.tno = 5比较可疑，你看这个关系代数表达式，先做了TEACHER×COURSE，也就是先做了卡氏积，我要是把TEACHER.tno = 5放到TEACHER上先把一些数据过滤掉，岂不是。。。完美！”说着小明也在电脑上敲出了把TEACHER.tno = 5下推之后的关系代数表达式。\n\n```\nΠcname (σTEACHER.tno=COURSE.tno (σTEACHER.tno=5(TEACHER)×COURSE))\n```\n\n大明说；“对的，你这样下推下来，的确能降低计算量，你这应用的是关系代数表达式中的分配率σF(A × B) == σF1(A) × σF2(B)，那你看看，既然下推这么好，是不是投影也能下推？”小明看了一下，关系代数表达式中值需要对cname进行投影，顿时想到了，COURSE表虽然有很多个列，但是我们只需要使用cname就够了嘛，于是小明在电脑上敲了投影下推的关系代数表达式。\n\n```\nΠcname (σTEACHER.tno=COURSE.tno (σTEACHER.tno=5(TEACHER)× Πcname(COURSE)))\n```\n\n大明拍了小明的头一下说：“笨蛋，你这样下推投影，TEACHER.tno=COURSE.tno还有办法做吗？”小明顿时领悟了，如果只在COURSE上对cname做投影时不行的，上层结点所有的表达式都需要考虑到，于是修改了表达式：\n\n```\nΠcname (σTEACHER.tno=COURSE.tno (σTEACHER.tno=5(TEACHER)× Πcname, tno(COURSE)))\n```\n\n“这还差不多。”大明笑着说：“这是使用的投影的串接率，也是一个非常重要的关系代数等价规则，目前我们对这个表达式的优化主要是使用了选择下推，和投影下推，如果用SQL语句来表示，就像这样。”大明在电脑的记事本上快速的打印出了两个SQL语句：\n\n```\nSELECT sname FROM TEACHER t, COURSE c WHERE t.tno = 5 AND t.tno = c.tno;\nSELECT sname FROM (SELECT * FROM TEACHER WHERE tno = 5) tt, (SELECT cname, tno FROM COURSE) cc WHERE tt.tno = cc.tno;\n```\n\n“你看这两个语句，就是谓词下推和投影下推前后的对照语句。在做卡氏积之前，先做了过滤，这样笛卡尔积的计算量会变小。”\n小明仔细的观察着代数表达式和这两个SQL语句，他发现一个问题，就是关系代数表达式中有TEACHER.tno = 5和TEACHER.tno = COURSE.tno这样的两个约束条件，这是不是意味着COURSE.tno也应该等于5呢？小明然后试着在电脑上写了一个SQL语句：\n\n```\nSELECT sname FROM (SELECT * FROM TEACHER WHERE tno = 5) tt, (SELECT cname, tno FROM COURSE WHERE tno=5) cc WHERE tt.tno = cc.tno;\n```\n\n然后小明说：“你看，由于有TEACHER.tno = 5和TEACHER.tno = COURSE.tno这样的两个约束条件，我们可以是不是可以推理出一个新的COURSE.tno = 5的新的约束条件来呢，这样我们还可以把这个条件下推到COURSE表上，这样也能降低笛卡尔积的计算量。”\n\n大明说：“是的，这就是等价推理，PostgreSQL数据库在查询优化的过程中，会将约束条件中等价的部分都记录到等价类中，这样就能根据等价类生成新的约束条件出来，比如示例的语句中就会产生一个等价类{TEACHER.tno, COURSE.tno, 5}，这是一个含有常量的等价类，是查询优化器比较喜欢的等价类，这种等价类可以得到列属性和常量组合成的约束条件，通常都是能下推的。”\n\n小明心里很高兴，自己通过仔细观察，得到了等价类的优化，感觉自己有了学习的动力，心里美滋滋的，然后就问大明：“那上面的SQL语句还有什么可优化的吗？”\n\n大明观察了一下这个语句，然后说：“你看，我们已经在TEACHER表上进行了TEACHER.tno = 5的过滤，在COURSE表上也做了COURSE.tno = 5的过滤，这样就说明在做笛卡尔积的时候，实际上已经确定了TEACHER.tno = COURSE.tno = 5，也就是说TEACHER.tno = COURSE.tno这个约束条件已经隐含成立了，也就没什么用了，我们可以把它去掉，最终形成一个这样的SQL语句。”大明在记事本中敲下了最终的语句：\n\n```\nSELECT sname FROM (SELECT * FROM TEACHER WHERE tno = 5) tt, (SELECT cname, tno FROM COURSE WHERE tno=5) cc；\n```\n\n同时也敲出了这个语句对应的关系代数表达式：\n\n```\nΠcname (σTEACHER.tno=5(TEACHER)× Πcname, tno(σCOURSE.tno=5(COURSE)))\n```\n\n然后大明说：“经过选择下推、投影下推和等价类推理，我们对这个SQL语句或者说关系代数表达式进行了优化，最终降低了计算量。”\n \n![](./postgresql-optimizer-outline-4/1.png) \n\n![](./postgresql-optimizer-outline-4/1.png) \n \n\n小明感觉对谓词下推已经理解了，然后说：“看上去也不复杂嘛，我发现了可以下推的选择我就下推，完全没有问题啊。”大明笑着说：“甚矣，我从未见过如此厚颜无耻之人，我们现在看的这个例子，只不过是最简单的一种情况啊，你就这样大言不惭，你的人生字典里还有羞耻二字吗？”\n\n小明愤愤的说：“我的人生没有字典。。。”\n\n大明问道：“我们这个例子有一个问题，就是他是内连接，因此我们可以肆意妄为的将选择下推下来，可以没羞没臊的做等价类推理，但是如果是外连接，那还能这么做吗？”\n\n小明顿时陷入了苦苦的沉思。\n","slug":"postgresql-optimizer-outline-4","published":1,"updated":"2020-08-04T23:18:17.000Z","_id":"ckdgkb6d30000mvs61pjfd9kp","comments":1,"layout":"post","photos":[],"link":"","content":"<p>小明在大明家的书房里摆好了纸砚，在一份过期的报纸上挥毫泼墨：“精推细敲慎思量，雄关漫道两茫茫，夜半挑灯读诗酒，莫谈肉串与烤馕。”大明看了之后笑道：“好诗好诗，来，让我们继续夜半挑灯读优化，莫与扯淡诉衷肠。”</p>\n<p>小明说：“再歇会吧，我觉得要深度了解查询优化没希望了。”大明看出了小明对查询优化产生了一点畏难情绪，因为小明本来以为通过大明的讲解能够快速的理解查询优化的本质，但是他通过几次听取大明的讲解之后发现，查询优化器远不是几次讲解就能解决的，大明目前给他讲解的还只是在应用层面的讲解，还没有深入到分析源码阶段，仅仅如此，对小明来说理解上就已经有些困难了，看来要想深度的了解查询优化器，还需要下更大的功夫才行。<a id=\"more\"></a></p>\n<p>大明说：“啥叫成功？成功就是在你坚持不下去的时候再坚持一下，来吧，Let’s继续。”说着拉着小明来到客厅，继续打开了电脑，“我们继续说点啥呢？上次说到了子连接，这次我们简单说说选择下推和等价类吧。”</p>\n<p>小明想了想说：“选择下推和等价类是逻辑分解优化中的内容了，可是逻辑重写优化里还有子查询提升、表达式预处理、外连接消除这些大块头你还没有给我讲解过吖。”</p>\n<p>大明说：“这些先留给你自己去理解，如果理解不了再来找我吧。逻辑优化的规则实际上还是比较多的，但是是可以逐个击破的，也就是他们之间通常而言并没有多大的关联，我们不打算在这上面纠缠太多时间，我相信以你自己的能力把他们搞定是没有问题的。”</p>\n<p>“哦，我觉得是你怕我在你家呆太长时间，把你吃穷吧？”小明偷笑着问。</p>\n<p>“是的，半大小子吃死老子，你这饭桶太能吃了，吃饭的速度比选择下推的速度还要快，午饭都被你吃了，我今天中午都没吃饱啊。”</p>\n<p>“我记得你说过，选择下推是为了尽早的过滤数据，这样就能在上层结点降低计算量，是吧？”</p>\n<p>“是的。”大明点了点头，“还是通过一个关系代数的示例来说明一下它吧，顺便我们把等价类推理也可以说一说，比如说我们想要获得编号为5的老师承担的所有的课程名字，我们可以给出它的关系代数表达式。”说着大明在电脑上敲了一个关系代数表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Πcname (σTEACHER.tno&#x3D;5∧TEACHER.tno&#x3D;COURSE.tno (TEACHER×COURSE))</span><br></pre></td></tr></table></figure>\n\n<p>“小明，你看这个关系代数表达式怎么下推选择操作？”</p>\n<p>小明看着关系代数表达式思考了一会，说：“我看这个TEACHER.tno = 5比较可疑，你看这个关系代数表达式，先做了TEACHER×COURSE，也就是先做了卡氏积，我要是把TEACHER.tno = 5放到TEACHER上先把一些数据过滤掉，岂不是。。。完美！”说着小明也在电脑上敲出了把TEACHER.tno = 5下推之后的关系代数表达式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Πcname (σTEACHER.tno&#x3D;COURSE.tno (σTEACHER.tno&#x3D;5(TEACHER)×COURSE))</span><br></pre></td></tr></table></figure>\n\n<p>大明说；“对的，你这样下推下来，的确能降低计算量，你这应用的是关系代数表达式中的分配率σF(A × B) == σF1(A) × σF2(B)，那你看看，既然下推这么好，是不是投影也能下推？”小明看了一下，关系代数表达式中值需要对cname进行投影，顿时想到了，COURSE表虽然有很多个列，但是我们只需要使用cname就够了嘛，于是小明在电脑上敲了投影下推的关系代数表达式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Πcname (σTEACHER.tno&#x3D;COURSE.tno (σTEACHER.tno&#x3D;5(TEACHER)× Πcname(COURSE)))</span><br></pre></td></tr></table></figure>\n\n<p>大明拍了小明的头一下说：“笨蛋，你这样下推投影，TEACHER.tno=COURSE.tno还有办法做吗？”小明顿时领悟了，如果只在COURSE上对cname做投影时不行的，上层结点所有的表达式都需要考虑到，于是修改了表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Πcname (σTEACHER.tno&#x3D;COURSE.tno (σTEACHER.tno&#x3D;5(TEACHER)× Πcname, tno(COURSE)))</span><br></pre></td></tr></table></figure>\n\n<p>“这还差不多。”大明笑着说：“这是使用的投影的串接率，也是一个非常重要的关系代数等价规则，目前我们对这个表达式的优化主要是使用了选择下推，和投影下推，如果用SQL语句来表示，就像这样。”大明在电脑的记事本上快速的打印出了两个SQL语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sname FROM TEACHER t, COURSE c WHERE t.tno &#x3D; 5 AND t.tno &#x3D; c.tno;</span><br><span class=\"line\">SELECT sname FROM (SELECT * FROM TEACHER WHERE tno &#x3D; 5) tt, (SELECT cname, tno FROM COURSE) cc WHERE tt.tno &#x3D; cc.tno;</span><br></pre></td></tr></table></figure>\n\n<p>“你看这两个语句，就是谓词下推和投影下推前后的对照语句。在做卡氏积之前，先做了过滤，这样笛卡尔积的计算量会变小。”<br>小明仔细的观察着代数表达式和这两个SQL语句，他发现一个问题，就是关系代数表达式中有TEACHER.tno = 5和TEACHER.tno = COURSE.tno这样的两个约束条件，这是不是意味着COURSE.tno也应该等于5呢？小明然后试着在电脑上写了一个SQL语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sname FROM (SELECT * FROM TEACHER WHERE tno &#x3D; 5) tt, (SELECT cname, tno FROM COURSE WHERE tno&#x3D;5) cc WHERE tt.tno &#x3D; cc.tno;</span><br></pre></td></tr></table></figure>\n\n<p>然后小明说：“你看，由于有TEACHER.tno = 5和TEACHER.tno = COURSE.tno这样的两个约束条件，我们可以是不是可以推理出一个新的COURSE.tno = 5的新的约束条件来呢，这样我们还可以把这个条件下推到COURSE表上，这样也能降低笛卡尔积的计算量。”</p>\n<p>大明说：“是的，这就是等价推理，PostgreSQL数据库在查询优化的过程中，会将约束条件中等价的部分都记录到等价类中，这样就能根据等价类生成新的约束条件出来，比如示例的语句中就会产生一个等价类{TEACHER.tno, COURSE.tno, 5}，这是一个含有常量的等价类，是查询优化器比较喜欢的等价类，这种等价类可以得到列属性和常量组合成的约束条件，通常都是能下推的。”</p>\n<p>小明心里很高兴，自己通过仔细观察，得到了等价类的优化，感觉自己有了学习的动力，心里美滋滋的，然后就问大明：“那上面的SQL语句还有什么可优化的吗？”</p>\n<p>大明观察了一下这个语句，然后说：“你看，我们已经在TEACHER表上进行了TEACHER.tno = 5的过滤，在COURSE表上也做了COURSE.tno = 5的过滤，这样就说明在做笛卡尔积的时候，实际上已经确定了TEACHER.tno = COURSE.tno = 5，也就是说TEACHER.tno = COURSE.tno这个约束条件已经隐含成立了，也就没什么用了，我们可以把它去掉，最终形成一个这样的SQL语句。”大明在记事本中敲下了最终的语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sname FROM (SELECT * FROM TEACHER WHERE tno &#x3D; 5) tt, (SELECT cname, tno FROM COURSE WHERE tno&#x3D;5) cc；</span><br></pre></td></tr></table></figure>\n\n<p>同时也敲出了这个语句对应的关系代数表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Πcname (σTEACHER.tno&#x3D;5(TEACHER)× Πcname, tno(σCOURSE.tno&#x3D;5(COURSE)))</span><br></pre></td></tr></table></figure>\n\n<p>然后大明说：“经过选择下推、投影下推和等价类推理，我们对这个SQL语句或者说关系代数表达式进行了优化，最终降低了计算量。”</p>\n<p><img src=\"/2020/08/05/postgresql-optimizer-outline-4/1.png\"> </p>\n<p><img src=\"/2020/08/05/postgresql-optimizer-outline-4/1.png\"> </p>\n<p>小明感觉对谓词下推已经理解了，然后说：“看上去也不复杂嘛，我发现了可以下推的选择我就下推，完全没有问题啊。”大明笑着说：“甚矣，我从未见过如此厚颜无耻之人，我们现在看的这个例子，只不过是最简单的一种情况啊，你就这样大言不惭，你的人生字典里还有羞耻二字吗？”</p>\n<p>小明愤愤的说：“我的人生没有字典。。。”</p>\n<p>大明问道：“我们这个例子有一个问题，就是他是内连接，因此我们可以肆意妄为的将选择下推下来，可以没羞没臊的做等价类推理，但是如果是外连接，那还能这么做吗？”</p>\n<p>小明顿时陷入了苦苦的沉思。</p>\n","site":{"data":{}},"excerpt":"<p>小明在大明家的书房里摆好了纸砚，在一份过期的报纸上挥毫泼墨：“精推细敲慎思量，雄关漫道两茫茫，夜半挑灯读诗酒，莫谈肉串与烤馕。”大明看了之后笑道：“好诗好诗，来，让我们继续夜半挑灯读优化，莫与扯淡诉衷肠。”</p>\n<p>小明说：“再歇会吧，我觉得要深度了解查询优化没希望了。”大明看出了小明对查询优化产生了一点畏难情绪，因为小明本来以为通过大明的讲解能够快速的理解查询优化的本质，但是他通过几次听取大明的讲解之后发现，查询优化器远不是几次讲解就能解决的，大明目前给他讲解的还只是在应用层面的讲解，还没有深入到分析源码阶段，仅仅如此，对小明来说理解上就已经有些困难了，看来要想深度的了解查询优化器，还需要下更大的功夫才行。</p>","more":"<p></p>\n<p>大明说：“啥叫成功？成功就是在你坚持不下去的时候再坚持一下，来吧，Let’s继续。”说着拉着小明来到客厅，继续打开了电脑，“我们继续说点啥呢？上次说到了子连接，这次我们简单说说选择下推和等价类吧。”</p>\n<p>小明想了想说：“选择下推和等价类是逻辑分解优化中的内容了，可是逻辑重写优化里还有子查询提升、表达式预处理、外连接消除这些大块头你还没有给我讲解过吖。”</p>\n<p>大明说：“这些先留给你自己去理解，如果理解不了再来找我吧。逻辑优化的规则实际上还是比较多的，但是是可以逐个击破的，也就是他们之间通常而言并没有多大的关联，我们不打算在这上面纠缠太多时间，我相信以你自己的能力把他们搞定是没有问题的。”</p>\n<p>“哦，我觉得是你怕我在你家呆太长时间，把你吃穷吧？”小明偷笑着问。</p>\n<p>“是的，半大小子吃死老子，你这饭桶太能吃了，吃饭的速度比选择下推的速度还要快，午饭都被你吃了，我今天中午都没吃饱啊。”</p>\n<p>“我记得你说过，选择下推是为了尽早的过滤数据，这样就能在上层结点降低计算量，是吧？”</p>\n<p>“是的。”大明点了点头，“还是通过一个关系代数的示例来说明一下它吧，顺便我们把等价类推理也可以说一说，比如说我们想要获得编号为5的老师承担的所有的课程名字，我们可以给出它的关系代数表达式。”说着大明在电脑上敲了一个关系代数表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Πcname (σTEACHER.tno&#x3D;5∧TEACHER.tno&#x3D;COURSE.tno (TEACHER×COURSE))</span><br></pre></td></tr></table></figure>\n\n<p>“小明，你看这个关系代数表达式怎么下推选择操作？”</p>\n<p>小明看着关系代数表达式思考了一会，说：“我看这个TEACHER.tno = 5比较可疑，你看这个关系代数表达式，先做了TEACHER×COURSE，也就是先做了卡氏积，我要是把TEACHER.tno = 5放到TEACHER上先把一些数据过滤掉，岂不是。。。完美！”说着小明也在电脑上敲出了把TEACHER.tno = 5下推之后的关系代数表达式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Πcname (σTEACHER.tno&#x3D;COURSE.tno (σTEACHER.tno&#x3D;5(TEACHER)×COURSE))</span><br></pre></td></tr></table></figure>\n\n<p>大明说；“对的，你这样下推下来，的确能降低计算量，你这应用的是关系代数表达式中的分配率σF(A × B) == σF1(A) × σF2(B)，那你看看，既然下推这么好，是不是投影也能下推？”小明看了一下，关系代数表达式中值需要对cname进行投影，顿时想到了，COURSE表虽然有很多个列，但是我们只需要使用cname就够了嘛，于是小明在电脑上敲了投影下推的关系代数表达式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Πcname (σTEACHER.tno&#x3D;COURSE.tno (σTEACHER.tno&#x3D;5(TEACHER)× Πcname(COURSE)))</span><br></pre></td></tr></table></figure>\n\n<p>大明拍了小明的头一下说：“笨蛋，你这样下推投影，TEACHER.tno=COURSE.tno还有办法做吗？”小明顿时领悟了，如果只在COURSE上对cname做投影时不行的，上层结点所有的表达式都需要考虑到，于是修改了表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Πcname (σTEACHER.tno&#x3D;COURSE.tno (σTEACHER.tno&#x3D;5(TEACHER)× Πcname, tno(COURSE)))</span><br></pre></td></tr></table></figure>\n\n<p>“这还差不多。”大明笑着说：“这是使用的投影的串接率，也是一个非常重要的关系代数等价规则，目前我们对这个表达式的优化主要是使用了选择下推，和投影下推，如果用SQL语句来表示，就像这样。”大明在电脑的记事本上快速的打印出了两个SQL语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sname FROM TEACHER t, COURSE c WHERE t.tno &#x3D; 5 AND t.tno &#x3D; c.tno;</span><br><span class=\"line\">SELECT sname FROM (SELECT * FROM TEACHER WHERE tno &#x3D; 5) tt, (SELECT cname, tno FROM COURSE) cc WHERE tt.tno &#x3D; cc.tno;</span><br></pre></td></tr></table></figure>\n\n<p>“你看这两个语句，就是谓词下推和投影下推前后的对照语句。在做卡氏积之前，先做了过滤，这样笛卡尔积的计算量会变小。”<br>小明仔细的观察着代数表达式和这两个SQL语句，他发现一个问题，就是关系代数表达式中有TEACHER.tno = 5和TEACHER.tno = COURSE.tno这样的两个约束条件，这是不是意味着COURSE.tno也应该等于5呢？小明然后试着在电脑上写了一个SQL语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sname FROM (SELECT * FROM TEACHER WHERE tno &#x3D; 5) tt, (SELECT cname, tno FROM COURSE WHERE tno&#x3D;5) cc WHERE tt.tno &#x3D; cc.tno;</span><br></pre></td></tr></table></figure>\n\n<p>然后小明说：“你看，由于有TEACHER.tno = 5和TEACHER.tno = COURSE.tno这样的两个约束条件，我们可以是不是可以推理出一个新的COURSE.tno = 5的新的约束条件来呢，这样我们还可以把这个条件下推到COURSE表上，这样也能降低笛卡尔积的计算量。”</p>\n<p>大明说：“是的，这就是等价推理，PostgreSQL数据库在查询优化的过程中，会将约束条件中等价的部分都记录到等价类中，这样就能根据等价类生成新的约束条件出来，比如示例的语句中就会产生一个等价类{TEACHER.tno, COURSE.tno, 5}，这是一个含有常量的等价类，是查询优化器比较喜欢的等价类，这种等价类可以得到列属性和常量组合成的约束条件，通常都是能下推的。”</p>\n<p>小明心里很高兴，自己通过仔细观察，得到了等价类的优化，感觉自己有了学习的动力，心里美滋滋的，然后就问大明：“那上面的SQL语句还有什么可优化的吗？”</p>\n<p>大明观察了一下这个语句，然后说：“你看，我们已经在TEACHER表上进行了TEACHER.tno = 5的过滤，在COURSE表上也做了COURSE.tno = 5的过滤，这样就说明在做笛卡尔积的时候，实际上已经确定了TEACHER.tno = COURSE.tno = 5，也就是说TEACHER.tno = COURSE.tno这个约束条件已经隐含成立了，也就没什么用了，我们可以把它去掉，最终形成一个这样的SQL语句。”大明在记事本中敲下了最终的语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sname FROM (SELECT * FROM TEACHER WHERE tno &#x3D; 5) tt, (SELECT cname, tno FROM COURSE WHERE tno&#x3D;5) cc；</span><br></pre></td></tr></table></figure>\n\n<p>同时也敲出了这个语句对应的关系代数表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Πcname (σTEACHER.tno&#x3D;5(TEACHER)× Πcname, tno(σCOURSE.tno&#x3D;5(COURSE)))</span><br></pre></td></tr></table></figure>\n\n<p>然后大明说：“经过选择下推、投影下推和等价类推理，我们对这个SQL语句或者说关系代数表达式进行了优化，最终降低了计算量。”</p>\n<p><img src=\"/2020/08/05/postgresql-optimizer-outline-4/1.png\"> </p>\n<p><img src=\"/2020/08/05/postgresql-optimizer-outline-4/1.png\"> </p>\n<p>小明感觉对谓词下推已经理解了，然后说：“看上去也不复杂嘛，我发现了可以下推的选择我就下推，完全没有问题啊。”大明笑着说：“甚矣，我从未见过如此厚颜无耻之人，我们现在看的这个例子，只不过是最简单的一种情况啊，你就这样大言不惭，你的人生字典里还有羞耻二字吗？”</p>\n<p>小明愤愤的说：“我的人生没有字典。。。”</p>\n<p>大明问道：“我们这个例子有一个问题，就是他是内连接，因此我们可以肆意妄为的将选择下推下来，可以没羞没臊的做等价类推理，但是如果是外连接，那还能这么做吗？”</p>\n<p>小明顿时陷入了苦苦的沉思。</p>"},{"title":"PostgreSQL优化器白话(5) - 严格要求自己","date":"2020-08-14T15:40:53.000Z","_content":"\n小明被大明将了一军，于是心里开始合计起来，假如是外连接，可能会对某一方补NULL值，这样的话TEACHER.tno = COURSE.tno这样的约束条件就无法构成等价类了啊，然后小在电脑上默默的敲了一个SQL语句：<!-- more -->\n\n```\nSELECT sname FROM TEACHER t LEFT JOIN COURSE c ON t.tno = 5 AND t.tno = c.tno;\n```\n\n然后小明发现不但等价类可能产生不了了，而且选择下推也无法进行了，于是说：“这个语句中的TEACHER.tno=5不能下推了，因为左连接的语义是外表的所有的数据都要输出出来，如果把TEACHER.tno=5下推到TEACHER表上，那就会在做左连接之前先对TEACHER表做过滤，导致查询结果的不等价，而且由于补NULL值，等价类也生成不了了。”\n\n大明说：“对的，小明同学你理解的很快，由于外连接补NULL值的关系，确实导致无法做谓词下推，不过你可以看一下下面的这个语句，看看有什么区别。”然后大明在电脑里输入了另一个类似的SQL语句：\n\n```\nSELECT sname FROM TEACHER t LEFT JOIN COURSE c ON TRUE WHERE t.tno = 5 AND t.tno = c.tno;\n```\n\n小明仔细的观察上面的例句和当前这个例句，发现约束条件一个处在ON后面，另一个是处在WHERE后面，小明好像还不是很理解他们的含义，于是向大明投去了咨询的目光。大明说：“我们粗略的分一下，ON后面的约束条件是连接条件，WHERE后面的约束条件是过滤条件，连接条件和过滤条件是不同的。”\n\n小明好像悟到了什么，抢着说：“我知道了，一个是连接中的，一个是连接后的，可以这么理解吧？你看，连接条件会参与到连接操作的过程中，满足连接条件的会显示出来，不满足连接条件的，根据连接的类型还会决定是否补NULL值，而过滤条件是在连接操作之后对连接的结果进行过滤。。。”小明又对大明投去了期待的眼神，这种眼神是期望得到一点肯定，大明笑着说：“对，可以这么理解。”\n\n小明赶紧说：“你先别讲，让我看看这个带有过滤条件的SQL语句是不是能下推。”，然后小明对着这个SQL语句仔细观察起来，口中念念有词，似乎是已经走火入魔了。\n\n小明观察了半天，好无收获，只好说：“我掐指一算，觉得这个约束条件是能下推的，而且等价类也能建立起来。”\n\n“为什么？”大明追问道。\n\n“不为什么，我脑海中灵光乍现，我是一个佛系的程序员。”\n\n“你果然没有人生的字典，想必你即使有人生字典，你也把羞耻二字给扣掉了。”\n\n小明笑着说：“是的，像我这样优秀的人，本该灿烂过一生啊。。。”\n\n大明看小明竟然唱起了歌，愤怒的说：“不要胡闹，再胡闹我就让你一杯敬自由，一杯敬死亡。。。”大明停顿了一下，继续说道：“实际上这里还有一个严格的概念，什么叫严格呢？一个表达式，如果它的输入是NULL并且输出也是NULL，那么我们就说这个表达式是严格的，另外我们可以扩展一下严格的定义，从而定义出一个叫做‘宽泛的严格’的概念，就是说如果一个表达式它的输入是NULL，它的输出是NULL或者false，那么我们就说它符合宽泛的严格。”\n\n“那么严格有什么用呢？”\n\n“如果对一个元组应用约束条件，如果约束条件求值返回的是NULL值或者FALSE，实际上代表的是这一条元组不输出，明白吗？”\n“哦，那就是说我们补的NULL值如果遇到这种过滤条件，就不会输出出来喽。”小明停了一下，突然想到了些什么，继续问道，“那这种外连接还补NULL值干嘛，岂不是没有什么卵用了？”\n\n“对头，这就是外连接消除的基本原理，遇上这种严格的约束条件，外连接补的NULL值没有什么用，那也就转变成内连接就好了。问题来了，如果变成了内连接，我们又能肆意妄为的选择下推、没羞没臊的做等价推理了，惊不惊喜，意不意外？”\n\n“哈哈，那你能给我一个不严格的例子不？让我见识一下不严格的表达式。”\n\n“比如说IS NOT NULL，输入是NULL值，输出竟然是TRUE，还有COALESCE函数，输入是NULL值，输出是啥随你定。”\n\n小明说：“看来表达式是否严格是很重要的一个概念，通过这个概念我们能做外连接消除，外连接消除又能够导致选择能够下推。。。这我就明白了为什么要做外连接消除了。”\n\n“嗯，外连接消除不只是将外连接转换成内连接，其实还有一种情况，它也和我们要说的表达式的条件是否严格有关，那就是可以将外连接转换成AntiJoin，我们来看这样一个例子。”\n\n```\nSELECT * FROM STUDENT LEFT JOIN SCORE ON STUDENT.sno = SCORE.sno WHERE SCORE.sno IS NULL;\n```\n\n“由于STUDENT.sno = SCORE.sno是严格的，而且是连接条件，这样在连接的过程中他会将在STUDENT表和SCORE表中原有的NULL值去除掉，反而由于SOCRE.sno IS NULL是过滤条件，它起到了过滤作用，会将外连接补充NULL值的数据全部保留下来，这个语句的执行结果实际上就相当于做了一个Anti Join，因此这个语句可以转换成为Anti Join，它转换的结果相当于下面这个语句。”大明在电脑上敲出了等价语句，啪啪啪。。。\n\n```\nSELECT * FROM STUDENT ANTI JOIN SCORE ON STUDENT.sno = SCORE.sno\n```\n\n“不过需要注意，SQL语法中是没有ANTI JOIN的，这只是一个等价的语句，但是它无法直接执行。另外在外连接消除的阶段还有一个“很重大”的举措，就是把左外连接全部转换成了右外连接，这样就可以在后续的代码中少处理一种情况，简化了后面的代码逻辑。”\n\n“严格果然是太有用了，可是我怎么知道一个表达式是不是严格呢？”\n\n“对于函数而言，在PG_PROC系统表中的proisstrict列属性代表了当前函数是否严格，如果是操作符表达式，在PostgreSQL数据库中操作符实际都转成了对应的函数，因此也可以用proisstrict来表示是否严格，而对基于IS [NOT] NULL产生的NullTest表达式需要单独处理，其中IS NOT NULL是严格的，IS NULL是不严格的，大体上我们可以分成这么几类。”\n\n小明感觉自己今天好像学到了好多知识，幸好自己有个哥哥，不然很难有人这么教自己，于是发自内心的说：“OK，我又增加了新的知识，谢谢。”\n\n“不要谢我，我是雷锋，我们都是在为中华之崛起而读书，想想我们可是社会主义接班人啊。。。”大明感觉自己胸前的仿佛有红领巾在迎风飘扬，而且更加鲜艳了。\n","source":"_posts/postgresql-optimizer-outline-5.md","raw":"---\ntitle: PostgreSQL优化器白话(5) - 严格要求自己\ndate: 2020-08-14 23:40:53\n---\n\n小明被大明将了一军，于是心里开始合计起来，假如是外连接，可能会对某一方补NULL值，这样的话TEACHER.tno = COURSE.tno这样的约束条件就无法构成等价类了啊，然后小在电脑上默默的敲了一个SQL语句：<!-- more -->\n\n```\nSELECT sname FROM TEACHER t LEFT JOIN COURSE c ON t.tno = 5 AND t.tno = c.tno;\n```\n\n然后小明发现不但等价类可能产生不了了，而且选择下推也无法进行了，于是说：“这个语句中的TEACHER.tno=5不能下推了，因为左连接的语义是外表的所有的数据都要输出出来，如果把TEACHER.tno=5下推到TEACHER表上，那就会在做左连接之前先对TEACHER表做过滤，导致查询结果的不等价，而且由于补NULL值，等价类也生成不了了。”\n\n大明说：“对的，小明同学你理解的很快，由于外连接补NULL值的关系，确实导致无法做谓词下推，不过你可以看一下下面的这个语句，看看有什么区别。”然后大明在电脑里输入了另一个类似的SQL语句：\n\n```\nSELECT sname FROM TEACHER t LEFT JOIN COURSE c ON TRUE WHERE t.tno = 5 AND t.tno = c.tno;\n```\n\n小明仔细的观察上面的例句和当前这个例句，发现约束条件一个处在ON后面，另一个是处在WHERE后面，小明好像还不是很理解他们的含义，于是向大明投去了咨询的目光。大明说：“我们粗略的分一下，ON后面的约束条件是连接条件，WHERE后面的约束条件是过滤条件，连接条件和过滤条件是不同的。”\n\n小明好像悟到了什么，抢着说：“我知道了，一个是连接中的，一个是连接后的，可以这么理解吧？你看，连接条件会参与到连接操作的过程中，满足连接条件的会显示出来，不满足连接条件的，根据连接的类型还会决定是否补NULL值，而过滤条件是在连接操作之后对连接的结果进行过滤。。。”小明又对大明投去了期待的眼神，这种眼神是期望得到一点肯定，大明笑着说：“对，可以这么理解。”\n\n小明赶紧说：“你先别讲，让我看看这个带有过滤条件的SQL语句是不是能下推。”，然后小明对着这个SQL语句仔细观察起来，口中念念有词，似乎是已经走火入魔了。\n\n小明观察了半天，好无收获，只好说：“我掐指一算，觉得这个约束条件是能下推的，而且等价类也能建立起来。”\n\n“为什么？”大明追问道。\n\n“不为什么，我脑海中灵光乍现，我是一个佛系的程序员。”\n\n“你果然没有人生的字典，想必你即使有人生字典，你也把羞耻二字给扣掉了。”\n\n小明笑着说：“是的，像我这样优秀的人，本该灿烂过一生啊。。。”\n\n大明看小明竟然唱起了歌，愤怒的说：“不要胡闹，再胡闹我就让你一杯敬自由，一杯敬死亡。。。”大明停顿了一下，继续说道：“实际上这里还有一个严格的概念，什么叫严格呢？一个表达式，如果它的输入是NULL并且输出也是NULL，那么我们就说这个表达式是严格的，另外我们可以扩展一下严格的定义，从而定义出一个叫做‘宽泛的严格’的概念，就是说如果一个表达式它的输入是NULL，它的输出是NULL或者false，那么我们就说它符合宽泛的严格。”\n\n“那么严格有什么用呢？”\n\n“如果对一个元组应用约束条件，如果约束条件求值返回的是NULL值或者FALSE，实际上代表的是这一条元组不输出，明白吗？”\n“哦，那就是说我们补的NULL值如果遇到这种过滤条件，就不会输出出来喽。”小明停了一下，突然想到了些什么，继续问道，“那这种外连接还补NULL值干嘛，岂不是没有什么卵用了？”\n\n“对头，这就是外连接消除的基本原理，遇上这种严格的约束条件，外连接补的NULL值没有什么用，那也就转变成内连接就好了。问题来了，如果变成了内连接，我们又能肆意妄为的选择下推、没羞没臊的做等价推理了，惊不惊喜，意不意外？”\n\n“哈哈，那你能给我一个不严格的例子不？让我见识一下不严格的表达式。”\n\n“比如说IS NOT NULL，输入是NULL值，输出竟然是TRUE，还有COALESCE函数，输入是NULL值，输出是啥随你定。”\n\n小明说：“看来表达式是否严格是很重要的一个概念，通过这个概念我们能做外连接消除，外连接消除又能够导致选择能够下推。。。这我就明白了为什么要做外连接消除了。”\n\n“嗯，外连接消除不只是将外连接转换成内连接，其实还有一种情况，它也和我们要说的表达式的条件是否严格有关，那就是可以将外连接转换成AntiJoin，我们来看这样一个例子。”\n\n```\nSELECT * FROM STUDENT LEFT JOIN SCORE ON STUDENT.sno = SCORE.sno WHERE SCORE.sno IS NULL;\n```\n\n“由于STUDENT.sno = SCORE.sno是严格的，而且是连接条件，这样在连接的过程中他会将在STUDENT表和SCORE表中原有的NULL值去除掉，反而由于SOCRE.sno IS NULL是过滤条件，它起到了过滤作用，会将外连接补充NULL值的数据全部保留下来，这个语句的执行结果实际上就相当于做了一个Anti Join，因此这个语句可以转换成为Anti Join，它转换的结果相当于下面这个语句。”大明在电脑上敲出了等价语句，啪啪啪。。。\n\n```\nSELECT * FROM STUDENT ANTI JOIN SCORE ON STUDENT.sno = SCORE.sno\n```\n\n“不过需要注意，SQL语法中是没有ANTI JOIN的，这只是一个等价的语句，但是它无法直接执行。另外在外连接消除的阶段还有一个“很重大”的举措，就是把左外连接全部转换成了右外连接，这样就可以在后续的代码中少处理一种情况，简化了后面的代码逻辑。”\n\n“严格果然是太有用了，可是我怎么知道一个表达式是不是严格呢？”\n\n“对于函数而言，在PG_PROC系统表中的proisstrict列属性代表了当前函数是否严格，如果是操作符表达式，在PostgreSQL数据库中操作符实际都转成了对应的函数，因此也可以用proisstrict来表示是否严格，而对基于IS [NOT] NULL产生的NullTest表达式需要单独处理，其中IS NOT NULL是严格的，IS NULL是不严格的，大体上我们可以分成这么几类。”\n\n小明感觉自己今天好像学到了好多知识，幸好自己有个哥哥，不然很难有人这么教自己，于是发自内心的说：“OK，我又增加了新的知识，谢谢。”\n\n“不要谢我，我是雷锋，我们都是在为中华之崛起而读书，想想我们可是社会主义接班人啊。。。”大明感觉自己胸前的仿佛有红领巾在迎风飘扬，而且更加鲜艳了。\n","slug":"postgresql-optimizer-outline-5","published":1,"updated":"2020-08-14T15:45:18.000Z","_id":"ckduejkln0000ox9k0nxvhd01","comments":1,"layout":"post","photos":[],"link":"","content":"<p>小明被大明将了一军，于是心里开始合计起来，假如是外连接，可能会对某一方补NULL值，这样的话TEACHER.tno = COURSE.tno这样的约束条件就无法构成等价类了啊，然后小在电脑上默默的敲了一个SQL语句：<a id=\"more\"></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sname FROM TEACHER t LEFT JOIN COURSE c ON t.tno &#x3D; 5 AND t.tno &#x3D; c.tno;</span><br></pre></td></tr></table></figure>\n\n<p>然后小明发现不但等价类可能产生不了了，而且选择下推也无法进行了，于是说：“这个语句中的TEACHER.tno=5不能下推了，因为左连接的语义是外表的所有的数据都要输出出来，如果把TEACHER.tno=5下推到TEACHER表上，那就会在做左连接之前先对TEACHER表做过滤，导致查询结果的不等价，而且由于补NULL值，等价类也生成不了了。”</p>\n<p>大明说：“对的，小明同学你理解的很快，由于外连接补NULL值的关系，确实导致无法做谓词下推，不过你可以看一下下面的这个语句，看看有什么区别。”然后大明在电脑里输入了另一个类似的SQL语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sname FROM TEACHER t LEFT JOIN COURSE c ON TRUE WHERE t.tno &#x3D; 5 AND t.tno &#x3D; c.tno;</span><br></pre></td></tr></table></figure>\n\n<p>小明仔细的观察上面的例句和当前这个例句，发现约束条件一个处在ON后面，另一个是处在WHERE后面，小明好像还不是很理解他们的含义，于是向大明投去了咨询的目光。大明说：“我们粗略的分一下，ON后面的约束条件是连接条件，WHERE后面的约束条件是过滤条件，连接条件和过滤条件是不同的。”</p>\n<p>小明好像悟到了什么，抢着说：“我知道了，一个是连接中的，一个是连接后的，可以这么理解吧？你看，连接条件会参与到连接操作的过程中，满足连接条件的会显示出来，不满足连接条件的，根据连接的类型还会决定是否补NULL值，而过滤条件是在连接操作之后对连接的结果进行过滤。。。”小明又对大明投去了期待的眼神，这种眼神是期望得到一点肯定，大明笑着说：“对，可以这么理解。”</p>\n<p>小明赶紧说：“你先别讲，让我看看这个带有过滤条件的SQL语句是不是能下推。”，然后小明对着这个SQL语句仔细观察起来，口中念念有词，似乎是已经走火入魔了。</p>\n<p>小明观察了半天，好无收获，只好说：“我掐指一算，觉得这个约束条件是能下推的，而且等价类也能建立起来。”</p>\n<p>“为什么？”大明追问道。</p>\n<p>“不为什么，我脑海中灵光乍现，我是一个佛系的程序员。”</p>\n<p>“你果然没有人生的字典，想必你即使有人生字典，你也把羞耻二字给扣掉了。”</p>\n<p>小明笑着说：“是的，像我这样优秀的人，本该灿烂过一生啊。。。”</p>\n<p>大明看小明竟然唱起了歌，愤怒的说：“不要胡闹，再胡闹我就让你一杯敬自由，一杯敬死亡。。。”大明停顿了一下，继续说道：“实际上这里还有一个严格的概念，什么叫严格呢？一个表达式，如果它的输入是NULL并且输出也是NULL，那么我们就说这个表达式是严格的，另外我们可以扩展一下严格的定义，从而定义出一个叫做‘宽泛的严格’的概念，就是说如果一个表达式它的输入是NULL，它的输出是NULL或者false，那么我们就说它符合宽泛的严格。”</p>\n<p>“那么严格有什么用呢？”</p>\n<p>“如果对一个元组应用约束条件，如果约束条件求值返回的是NULL值或者FALSE，实际上代表的是这一条元组不输出，明白吗？”<br>“哦，那就是说我们补的NULL值如果遇到这种过滤条件，就不会输出出来喽。”小明停了一下，突然想到了些什么，继续问道，“那这种外连接还补NULL值干嘛，岂不是没有什么卵用了？”</p>\n<p>“对头，这就是外连接消除的基本原理，遇上这种严格的约束条件，外连接补的NULL值没有什么用，那也就转变成内连接就好了。问题来了，如果变成了内连接，我们又能肆意妄为的选择下推、没羞没臊的做等价推理了，惊不惊喜，意不意外？”</p>\n<p>“哈哈，那你能给我一个不严格的例子不？让我见识一下不严格的表达式。”</p>\n<p>“比如说IS NOT NULL，输入是NULL值，输出竟然是TRUE，还有COALESCE函数，输入是NULL值，输出是啥随你定。”</p>\n<p>小明说：“看来表达式是否严格是很重要的一个概念，通过这个概念我们能做外连接消除，外连接消除又能够导致选择能够下推。。。这我就明白了为什么要做外连接消除了。”</p>\n<p>“嗯，外连接消除不只是将外连接转换成内连接，其实还有一种情况，它也和我们要说的表达式的条件是否严格有关，那就是可以将外连接转换成AntiJoin，我们来看这样一个例子。”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM STUDENT LEFT JOIN SCORE ON STUDENT.sno &#x3D; SCORE.sno WHERE SCORE.sno IS NULL;</span><br></pre></td></tr></table></figure>\n\n<p>“由于STUDENT.sno = SCORE.sno是严格的，而且是连接条件，这样在连接的过程中他会将在STUDENT表和SCORE表中原有的NULL值去除掉，反而由于SOCRE.sno IS NULL是过滤条件，它起到了过滤作用，会将外连接补充NULL值的数据全部保留下来，这个语句的执行结果实际上就相当于做了一个Anti Join，因此这个语句可以转换成为Anti Join，它转换的结果相当于下面这个语句。”大明在电脑上敲出了等价语句，啪啪啪。。。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM STUDENT ANTI JOIN SCORE ON STUDENT.sno &#x3D; SCORE.sno</span><br></pre></td></tr></table></figure>\n\n<p>“不过需要注意，SQL语法中是没有ANTI JOIN的，这只是一个等价的语句，但是它无法直接执行。另外在外连接消除的阶段还有一个“很重大”的举措，就是把左外连接全部转换成了右外连接，这样就可以在后续的代码中少处理一种情况，简化了后面的代码逻辑。”</p>\n<p>“严格果然是太有用了，可是我怎么知道一个表达式是不是严格呢？”</p>\n<p>“对于函数而言，在PG_PROC系统表中的proisstrict列属性代表了当前函数是否严格，如果是操作符表达式，在PostgreSQL数据库中操作符实际都转成了对应的函数，因此也可以用proisstrict来表示是否严格，而对基于IS [NOT] NULL产生的NullTest表达式需要单独处理，其中IS NOT NULL是严格的，IS NULL是不严格的，大体上我们可以分成这么几类。”</p>\n<p>小明感觉自己今天好像学到了好多知识，幸好自己有个哥哥，不然很难有人这么教自己，于是发自内心的说：“OK，我又增加了新的知识，谢谢。”</p>\n<p>“不要谢我，我是雷锋，我们都是在为中华之崛起而读书，想想我们可是社会主义接班人啊。。。”大明感觉自己胸前的仿佛有红领巾在迎风飘扬，而且更加鲜艳了。</p>\n","site":{"data":{}},"excerpt":"<p>小明被大明将了一军，于是心里开始合计起来，假如是外连接，可能会对某一方补NULL值，这样的话TEACHER.tno = COURSE.tno这样的约束条件就无法构成等价类了啊，然后小在电脑上默默的敲了一个SQL语句：</p>","more":"<p></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sname FROM TEACHER t LEFT JOIN COURSE c ON t.tno &#x3D; 5 AND t.tno &#x3D; c.tno;</span><br></pre></td></tr></table></figure>\n\n<p>然后小明发现不但等价类可能产生不了了，而且选择下推也无法进行了，于是说：“这个语句中的TEACHER.tno=5不能下推了，因为左连接的语义是外表的所有的数据都要输出出来，如果把TEACHER.tno=5下推到TEACHER表上，那就会在做左连接之前先对TEACHER表做过滤，导致查询结果的不等价，而且由于补NULL值，等价类也生成不了了。”</p>\n<p>大明说：“对的，小明同学你理解的很快，由于外连接补NULL值的关系，确实导致无法做谓词下推，不过你可以看一下下面的这个语句，看看有什么区别。”然后大明在电脑里输入了另一个类似的SQL语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sname FROM TEACHER t LEFT JOIN COURSE c ON TRUE WHERE t.tno &#x3D; 5 AND t.tno &#x3D; c.tno;</span><br></pre></td></tr></table></figure>\n\n<p>小明仔细的观察上面的例句和当前这个例句，发现约束条件一个处在ON后面，另一个是处在WHERE后面，小明好像还不是很理解他们的含义，于是向大明投去了咨询的目光。大明说：“我们粗略的分一下，ON后面的约束条件是连接条件，WHERE后面的约束条件是过滤条件，连接条件和过滤条件是不同的。”</p>\n<p>小明好像悟到了什么，抢着说：“我知道了，一个是连接中的，一个是连接后的，可以这么理解吧？你看，连接条件会参与到连接操作的过程中，满足连接条件的会显示出来，不满足连接条件的，根据连接的类型还会决定是否补NULL值，而过滤条件是在连接操作之后对连接的结果进行过滤。。。”小明又对大明投去了期待的眼神，这种眼神是期望得到一点肯定，大明笑着说：“对，可以这么理解。”</p>\n<p>小明赶紧说：“你先别讲，让我看看这个带有过滤条件的SQL语句是不是能下推。”，然后小明对着这个SQL语句仔细观察起来，口中念念有词，似乎是已经走火入魔了。</p>\n<p>小明观察了半天，好无收获，只好说：“我掐指一算，觉得这个约束条件是能下推的，而且等价类也能建立起来。”</p>\n<p>“为什么？”大明追问道。</p>\n<p>“不为什么，我脑海中灵光乍现，我是一个佛系的程序员。”</p>\n<p>“你果然没有人生的字典，想必你即使有人生字典，你也把羞耻二字给扣掉了。”</p>\n<p>小明笑着说：“是的，像我这样优秀的人，本该灿烂过一生啊。。。”</p>\n<p>大明看小明竟然唱起了歌，愤怒的说：“不要胡闹，再胡闹我就让你一杯敬自由，一杯敬死亡。。。”大明停顿了一下，继续说道：“实际上这里还有一个严格的概念，什么叫严格呢？一个表达式，如果它的输入是NULL并且输出也是NULL，那么我们就说这个表达式是严格的，另外我们可以扩展一下严格的定义，从而定义出一个叫做‘宽泛的严格’的概念，就是说如果一个表达式它的输入是NULL，它的输出是NULL或者false，那么我们就说它符合宽泛的严格。”</p>\n<p>“那么严格有什么用呢？”</p>\n<p>“如果对一个元组应用约束条件，如果约束条件求值返回的是NULL值或者FALSE，实际上代表的是这一条元组不输出，明白吗？”<br>“哦，那就是说我们补的NULL值如果遇到这种过滤条件，就不会输出出来喽。”小明停了一下，突然想到了些什么，继续问道，“那这种外连接还补NULL值干嘛，岂不是没有什么卵用了？”</p>\n<p>“对头，这就是外连接消除的基本原理，遇上这种严格的约束条件，外连接补的NULL值没有什么用，那也就转变成内连接就好了。问题来了，如果变成了内连接，我们又能肆意妄为的选择下推、没羞没臊的做等价推理了，惊不惊喜，意不意外？”</p>\n<p>“哈哈，那你能给我一个不严格的例子不？让我见识一下不严格的表达式。”</p>\n<p>“比如说IS NOT NULL，输入是NULL值，输出竟然是TRUE，还有COALESCE函数，输入是NULL值，输出是啥随你定。”</p>\n<p>小明说：“看来表达式是否严格是很重要的一个概念，通过这个概念我们能做外连接消除，外连接消除又能够导致选择能够下推。。。这我就明白了为什么要做外连接消除了。”</p>\n<p>“嗯，外连接消除不只是将外连接转换成内连接，其实还有一种情况，它也和我们要说的表达式的条件是否严格有关，那就是可以将外连接转换成AntiJoin，我们来看这样一个例子。”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM STUDENT LEFT JOIN SCORE ON STUDENT.sno &#x3D; SCORE.sno WHERE SCORE.sno IS NULL;</span><br></pre></td></tr></table></figure>\n\n<p>“由于STUDENT.sno = SCORE.sno是严格的，而且是连接条件，这样在连接的过程中他会将在STUDENT表和SCORE表中原有的NULL值去除掉，反而由于SOCRE.sno IS NULL是过滤条件，它起到了过滤作用，会将外连接补充NULL值的数据全部保留下来，这个语句的执行结果实际上就相当于做了一个Anti Join，因此这个语句可以转换成为Anti Join，它转换的结果相当于下面这个语句。”大明在电脑上敲出了等价语句，啪啪啪。。。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM STUDENT ANTI JOIN SCORE ON STUDENT.sno &#x3D; SCORE.sno</span><br></pre></td></tr></table></figure>\n\n<p>“不过需要注意，SQL语法中是没有ANTI JOIN的，这只是一个等价的语句，但是它无法直接执行。另外在外连接消除的阶段还有一个“很重大”的举措，就是把左外连接全部转换成了右外连接，这样就可以在后续的代码中少处理一种情况，简化了后面的代码逻辑。”</p>\n<p>“严格果然是太有用了，可是我怎么知道一个表达式是不是严格呢？”</p>\n<p>“对于函数而言，在PG_PROC系统表中的proisstrict列属性代表了当前函数是否严格，如果是操作符表达式，在PostgreSQL数据库中操作符实际都转成了对应的函数，因此也可以用proisstrict来表示是否严格，而对基于IS [NOT] NULL产生的NullTest表达式需要单独处理，其中IS NOT NULL是严格的，IS NULL是不严格的，大体上我们可以分成这么几类。”</p>\n<p>小明感觉自己今天好像学到了好多知识，幸好自己有个哥哥，不然很难有人这么教自己，于是发自内心的说：“OK，我又增加了新的知识，谢谢。”</p>\n<p>“不要谢我，我是雷锋，我们都是在为中华之崛起而读书，想想我们可是社会主义接班人啊。。。”大明感觉自己胸前的仿佛有红领巾在迎风飘扬，而且更加鲜艳了。</p>"},{"title":"PostgreSQL优化器白话(6) - 统计局旁的泉水","date":"2020-10-03T00:23:35.000Z","_content":"\n\n“咚咚咚。。。咚咚咚”门外传来了敲门声，大明去打开房门一看，进来的原来是自己的同事牛二哥，牛二哥是专门从事数据库查询优化开发的码农，也有十几年的从业经验了，大明感到非常happy，因为这两天给小明讲查询优化器干到有些吃力，今天牛二哥来了，可以帮助自己给小明来讲查询优化器了，于是和牛二哥说：“牛二同志，来了就别走了，今天大腰子加红酒管够，你来帮我个忙。”\n\n牛二哥是大腰子爱好者，听说有大腰子，顿时感觉浑身鸡血翻腾，连忙说：“没问题，不过要帮什么忙？”\n<!-- more -->\n大明说：“我的弟弟小明最近在学校要进行数据库原理实践，最近总来问我优化器的问题，可我对优化器也是一知半解，这下你来了，你可以帮我弟弟讲讲优化器了。”\n\n牛二哥痛快的说：“这难不倒我，随时都可以讲。”\n\n大明说：“好嘞，我先给我的弟弟小明打个电话，和他说有优化器高手来了，赶紧过来请教。”\n\n……（此处略去近千字）\n\n小明早就听说过牛二哥的名字，据说对查询优化非常了解，没想到牛二哥竟然和自己的哥哥是同事，于是赶紧来到了大明家，看到牛二哥的洗旧的格子衫和半秃的发型，感觉就像少林寺的扫地僧一样，于是赶紧说：“我这最近正在查看基于代价的优化，感觉付出了很多代价，但收获甚微啊，期望今天能得到牛二哥的指导。”\n\n牛二哥说：“不客气，我是也是受到了大腰子和红酒的诱惑，估计今天也要付出惨痛的代价。。。。你有什么问题尽管问，我捡我会的回答。”看着小明稚嫩的脸庞，牛二哥突然想起了自己刚开始从事数据库内核开发的日子，心底翻腾起一股悲凉感，那是一段不堪回首的血泪史啊，有血、有泪、有。。。\n\n牛二哥突然想到了什么，继续说道：“说到代价，我觉得有个东西是绕不过去的，那就是统计信息和选择率，PostgreSQL数据库的物理优化需要计算各种物理路径的代价，而代价估算的过程严重的依赖于数据库的统计信息，统计信息是否能准确的描述表中的数据分布情况是决定代价的准确性的重要条件之一。”\n\n小明说：“大明和我说过，数据库有很多的物理路径，这些物理路径我们也叫他们物理算子，和逻辑算子不同，物理算子是查询执行器的执行方法，我们只需要计算物理算子每个步骤的代价，汇总起来就是路径的代价了，那要统计信息有什么用呢？”\n\n牛二哥看了看大明，意思是让大明来说，不过大明正在专心的查吃了吗外卖APP，找大腰子和红酒，并没有看到牛二哥的眼神，牛二哥只好尴尬的说：“是的，我们就是要计算一个物理算子的代价，但是物理算子的计算量并不是一成不变的。”说着牛二哥从旁边的书桌上拿来纸和笔，在纸上写了两个SQL语句。\n\n```\n\tSELECT A+B FROM TEST_A WHERE A > 1;\n\tSELECT A+B FROM TEST_A WHERE A > 100000000;\n```\n\t\n然后牛二哥说：“你看，这两个语句可以用同样的物理算子来完成，但是他们的计算量一样吗？”\n\n小明心想：A > 1和A > 1000000000都是过滤条件，经过过滤之后，他们产生的数据量就不同了，这样投影中的A+B的计算的次数就不同了，所以他们的代价应该是不同的，那它和统计信息有什么关系呢？小明感觉灵光一闪，马上说：“我知道了，我在计算物理算子的代价的时候，要知道A > 1之后还剩下多少数据或者A > 1000000000之后还剩下多少数据，如果我们提前对表上的数据内容做了统计，剩下多少数据就不难计算了，所以必须要有统计信息。”\n\n牛二哥点了点头，说：“嗯，通过统计信息，代价估算系统就可以了解一个表有多少行数据、用了多少个数据页面、某个值出现的频率等等，然后就能根据这些信息计算出一个约束条件能过滤掉多少数据，这种约束条件过滤出的数据占总数据量的比例称之为‘选择率’，所谓选择率就是一个比例，它的公式是这样的。”说着牛二哥继续在纸上写了选择率的公式：\n选择率=约束条件过滤后的元组数/约束条件过滤前的总元组数\n\n“不过上面的示例有点简单了，实际应用中通常约束条件会比较多，而且比较复杂，通常我们会计算每个子约束条件的选择率，然后就可以根据AND运算符和OR运算符计算它们的综合的选择率，AND运算符和OR运算符的选择率计算是基于概率的，你看这里的概率公式。”说着，牛二哥又继续在纸上写起来。\n\n```\nP(A+B)=P(A)+P(B)-P(AB)\nP(AB)=P(A)×P(B)\n```\n\n“有了这些，我们就可以求解多种类型的约束条件的选择率了，比如。。。”牛二哥继续在纸上画起来：\n\n```\n    P(ssex IS NOT NULL OR sno > 5) \n  = P(ssex IS NOT NULL) + P(sno > 5) – P(ssex IS NOT NULL AND sno > 5)\n  = P(ssex IS NOT NULL) + P(sno > 5) – P(ssex IS NOT NULL) × P(no > 5)\n```\n\n小明觉得牛二哥的进展有点快，赶紧问：“那么统计信息是什么形式的呢？”\n\n牛二哥挠挠头，说：“这个还真是有点麻烦，我们说常用的统计信息的形式就是distinct率、NULL值率、高频值、直方图、相关系数这些，他们分别有不同的作用，比如说distinct率，你可以获知某一列有多少个独立值，这种信息对于像性别这种列就显得特别有用，NULL值率呢？在统计的过程中，NULL值是不好处理的，因此把它独立出来，形成NULL值率，这样在高频值、直方图这些里面就不用考虑NULL值的情况了，高频值属于奇异值，顾名思义，就是出现的比较多的一些列值，去掉了NULL值，再去掉高频值，剩下的值可以用来做一个等频的直方图。。。。”\n \n“呃。。。”小明感觉跟不上牛二哥的速度了，于是说：“有点快，我有点跟不上了。”\n\t\n这时大明已经点完了外卖，过来说：“别急，外卖没有那么快送到，至于统计信息嘛，主要的还是高频值、直方图和相关系数，实际上我建议还是不要纠结于统计信息有哪些形式，我们只要知道它是用来算代价的就可以了。”\n\n牛二哥对大明说：“这怎么可以，我还没有说统计信息是如何生成的呢，比如它通过了两阶段采样，然后对样本进行统计时使用的统计方法，哪些值可以作为高频值，直方图有几个桶，相关系数是怎么计算的，相关系数在计算索引扫描路径代价的时候怎么用的，而且我和你说，PostgreSQL还出了基于多列的扩展统计信息，多列统计信息分成了哪些类型，分别是什么含义，各自是怎么计算的，还有选择率是怎么结合统计信息计算的，这些我还没说呢。。。”\n\n大明说：“你快闭嘴吧，像你这样讲优化器，岂不是要出一本书。”\n\n牛二哥做痛苦状：“那好吧，统计信息我们就说到这里吧，但是它确实是代价计算的基石，小明同学，你理解了它的作用就可以了。”\n\n小明痛苦的说：“牛二哥，你说了这么多，都不告诉我答案，我感觉要学的内容好多啊。”\n\n大明笑着说：“不用这么痛苦嘛，没有啥事是一顿烧烤不能解决的，如果有，那就是两顿。”然后大明继续神秘的说：“实际上统计信息往往也不准，你想想本来就是采样的结果嘛，样本是否显著压根就不好说，而且随着应用程序对表的更新，统计信息可能更新不及时，那就更会出现偏差。更严重的是，如果我们遇到a > b这样的约束条件，使用统计信息计算选择率也很不好计算，即使算出来，也不准嘛。”\n\n牛二哥说：“是的，统计信息确实也有不准确的问题，我听说有个DBA，他家祖坟旁边出了一口泉水，他爸爸觉得是吉兆，去找风水大师看一看，风水大师掐指算一算，说：你儿子是个DBA，每次数据库性能慢就知道更新统计信息，可是统计信息太水了，都从你家祖坟冒出来了。”\n\n三个人顿时笑做一团，气氛从痛苦又恢复到了活泼，大明说：“学习查询优化器确实还是比较繁琐的，绝对不是我们通过一两次讲解就能让你变得精通的，这个学习的曲线还是比较陡峭的。”\n\n小明点了点头说：“好吧，有了两位师傅，再加上我自己天资聪慧、风流倜傥、玉树临风、高大威武、骨骼惊奇，我相信一定能将优化器搞定。”\n\n大明和牛二哥都晕倒在地上。。。\n","source":"_posts/postgresql-optimizer-outline-6.md","raw":"---\ntitle: PostgreSQL优化器白话(6) - 统计局旁的泉水\ndate: 2020-10-03 08:23:35\n---\n\n\n“咚咚咚。。。咚咚咚”门外传来了敲门声，大明去打开房门一看，进来的原来是自己的同事牛二哥，牛二哥是专门从事数据库查询优化开发的码农，也有十几年的从业经验了，大明感到非常happy，因为这两天给小明讲查询优化器干到有些吃力，今天牛二哥来了，可以帮助自己给小明来讲查询优化器了，于是和牛二哥说：“牛二同志，来了就别走了，今天大腰子加红酒管够，你来帮我个忙。”\n\n牛二哥是大腰子爱好者，听说有大腰子，顿时感觉浑身鸡血翻腾，连忙说：“没问题，不过要帮什么忙？”\n<!-- more -->\n大明说：“我的弟弟小明最近在学校要进行数据库原理实践，最近总来问我优化器的问题，可我对优化器也是一知半解，这下你来了，你可以帮我弟弟讲讲优化器了。”\n\n牛二哥痛快的说：“这难不倒我，随时都可以讲。”\n\n大明说：“好嘞，我先给我的弟弟小明打个电话，和他说有优化器高手来了，赶紧过来请教。”\n\n……（此处略去近千字）\n\n小明早就听说过牛二哥的名字，据说对查询优化非常了解，没想到牛二哥竟然和自己的哥哥是同事，于是赶紧来到了大明家，看到牛二哥的洗旧的格子衫和半秃的发型，感觉就像少林寺的扫地僧一样，于是赶紧说：“我这最近正在查看基于代价的优化，感觉付出了很多代价，但收获甚微啊，期望今天能得到牛二哥的指导。”\n\n牛二哥说：“不客气，我是也是受到了大腰子和红酒的诱惑，估计今天也要付出惨痛的代价。。。。你有什么问题尽管问，我捡我会的回答。”看着小明稚嫩的脸庞，牛二哥突然想起了自己刚开始从事数据库内核开发的日子，心底翻腾起一股悲凉感，那是一段不堪回首的血泪史啊，有血、有泪、有。。。\n\n牛二哥突然想到了什么，继续说道：“说到代价，我觉得有个东西是绕不过去的，那就是统计信息和选择率，PostgreSQL数据库的物理优化需要计算各种物理路径的代价，而代价估算的过程严重的依赖于数据库的统计信息，统计信息是否能准确的描述表中的数据分布情况是决定代价的准确性的重要条件之一。”\n\n小明说：“大明和我说过，数据库有很多的物理路径，这些物理路径我们也叫他们物理算子，和逻辑算子不同，物理算子是查询执行器的执行方法，我们只需要计算物理算子每个步骤的代价，汇总起来就是路径的代价了，那要统计信息有什么用呢？”\n\n牛二哥看了看大明，意思是让大明来说，不过大明正在专心的查吃了吗外卖APP，找大腰子和红酒，并没有看到牛二哥的眼神，牛二哥只好尴尬的说：“是的，我们就是要计算一个物理算子的代价，但是物理算子的计算量并不是一成不变的。”说着牛二哥从旁边的书桌上拿来纸和笔，在纸上写了两个SQL语句。\n\n```\n\tSELECT A+B FROM TEST_A WHERE A > 1;\n\tSELECT A+B FROM TEST_A WHERE A > 100000000;\n```\n\t\n然后牛二哥说：“你看，这两个语句可以用同样的物理算子来完成，但是他们的计算量一样吗？”\n\n小明心想：A > 1和A > 1000000000都是过滤条件，经过过滤之后，他们产生的数据量就不同了，这样投影中的A+B的计算的次数就不同了，所以他们的代价应该是不同的，那它和统计信息有什么关系呢？小明感觉灵光一闪，马上说：“我知道了，我在计算物理算子的代价的时候，要知道A > 1之后还剩下多少数据或者A > 1000000000之后还剩下多少数据，如果我们提前对表上的数据内容做了统计，剩下多少数据就不难计算了，所以必须要有统计信息。”\n\n牛二哥点了点头，说：“嗯，通过统计信息，代价估算系统就可以了解一个表有多少行数据、用了多少个数据页面、某个值出现的频率等等，然后就能根据这些信息计算出一个约束条件能过滤掉多少数据，这种约束条件过滤出的数据占总数据量的比例称之为‘选择率’，所谓选择率就是一个比例，它的公式是这样的。”说着牛二哥继续在纸上写了选择率的公式：\n选择率=约束条件过滤后的元组数/约束条件过滤前的总元组数\n\n“不过上面的示例有点简单了，实际应用中通常约束条件会比较多，而且比较复杂，通常我们会计算每个子约束条件的选择率，然后就可以根据AND运算符和OR运算符计算它们的综合的选择率，AND运算符和OR运算符的选择率计算是基于概率的，你看这里的概率公式。”说着，牛二哥又继续在纸上写起来。\n\n```\nP(A+B)=P(A)+P(B)-P(AB)\nP(AB)=P(A)×P(B)\n```\n\n“有了这些，我们就可以求解多种类型的约束条件的选择率了，比如。。。”牛二哥继续在纸上画起来：\n\n```\n    P(ssex IS NOT NULL OR sno > 5) \n  = P(ssex IS NOT NULL) + P(sno > 5) – P(ssex IS NOT NULL AND sno > 5)\n  = P(ssex IS NOT NULL) + P(sno > 5) – P(ssex IS NOT NULL) × P(no > 5)\n```\n\n小明觉得牛二哥的进展有点快，赶紧问：“那么统计信息是什么形式的呢？”\n\n牛二哥挠挠头，说：“这个还真是有点麻烦，我们说常用的统计信息的形式就是distinct率、NULL值率、高频值、直方图、相关系数这些，他们分别有不同的作用，比如说distinct率，你可以获知某一列有多少个独立值，这种信息对于像性别这种列就显得特别有用，NULL值率呢？在统计的过程中，NULL值是不好处理的，因此把它独立出来，形成NULL值率，这样在高频值、直方图这些里面就不用考虑NULL值的情况了，高频值属于奇异值，顾名思义，就是出现的比较多的一些列值，去掉了NULL值，再去掉高频值，剩下的值可以用来做一个等频的直方图。。。。”\n \n“呃。。。”小明感觉跟不上牛二哥的速度了，于是说：“有点快，我有点跟不上了。”\n\t\n这时大明已经点完了外卖，过来说：“别急，外卖没有那么快送到，至于统计信息嘛，主要的还是高频值、直方图和相关系数，实际上我建议还是不要纠结于统计信息有哪些形式，我们只要知道它是用来算代价的就可以了。”\n\n牛二哥对大明说：“这怎么可以，我还没有说统计信息是如何生成的呢，比如它通过了两阶段采样，然后对样本进行统计时使用的统计方法，哪些值可以作为高频值，直方图有几个桶，相关系数是怎么计算的，相关系数在计算索引扫描路径代价的时候怎么用的，而且我和你说，PostgreSQL还出了基于多列的扩展统计信息，多列统计信息分成了哪些类型，分别是什么含义，各自是怎么计算的，还有选择率是怎么结合统计信息计算的，这些我还没说呢。。。”\n\n大明说：“你快闭嘴吧，像你这样讲优化器，岂不是要出一本书。”\n\n牛二哥做痛苦状：“那好吧，统计信息我们就说到这里吧，但是它确实是代价计算的基石，小明同学，你理解了它的作用就可以了。”\n\n小明痛苦的说：“牛二哥，你说了这么多，都不告诉我答案，我感觉要学的内容好多啊。”\n\n大明笑着说：“不用这么痛苦嘛，没有啥事是一顿烧烤不能解决的，如果有，那就是两顿。”然后大明继续神秘的说：“实际上统计信息往往也不准，你想想本来就是采样的结果嘛，样本是否显著压根就不好说，而且随着应用程序对表的更新，统计信息可能更新不及时，那就更会出现偏差。更严重的是，如果我们遇到a > b这样的约束条件，使用统计信息计算选择率也很不好计算，即使算出来，也不准嘛。”\n\n牛二哥说：“是的，统计信息确实也有不准确的问题，我听说有个DBA，他家祖坟旁边出了一口泉水，他爸爸觉得是吉兆，去找风水大师看一看，风水大师掐指算一算，说：你儿子是个DBA，每次数据库性能慢就知道更新统计信息，可是统计信息太水了，都从你家祖坟冒出来了。”\n\n三个人顿时笑做一团，气氛从痛苦又恢复到了活泼，大明说：“学习查询优化器确实还是比较繁琐的，绝对不是我们通过一两次讲解就能让你变得精通的，这个学习的曲线还是比较陡峭的。”\n\n小明点了点头说：“好吧，有了两位师傅，再加上我自己天资聪慧、风流倜傥、玉树临风、高大威武、骨骼惊奇，我相信一定能将优化器搞定。”\n\n大明和牛二哥都晕倒在地上。。。\n","slug":"postgresql-optimizer-outline-6","published":1,"updated":"2020-10-03T00:35:54.000Z","_id":"ckfsy1s6g0000nw9ke9283mf0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>“咚咚咚。。。咚咚咚”门外传来了敲门声，大明去打开房门一看，进来的原来是自己的同事牛二哥，牛二哥是专门从事数据库查询优化开发的码农，也有十几年的从业经验了，大明感到非常happy，因为这两天给小明讲查询优化器干到有些吃力，今天牛二哥来了，可以帮助自己给小明来讲查询优化器了，于是和牛二哥说：“牛二同志，来了就别走了，今天大腰子加红酒管够，你来帮我个忙。”</p>\n<p>牛二哥是大腰子爱好者，听说有大腰子，顿时感觉浑身鸡血翻腾，连忙说：“没问题，不过要帮什么忙？”</p>\n<a id=\"more\"></a>\n<p>大明说：“我的弟弟小明最近在学校要进行数据库原理实践，最近总来问我优化器的问题，可我对优化器也是一知半解，这下你来了，你可以帮我弟弟讲讲优化器了。”</p>\n<p>牛二哥痛快的说：“这难不倒我，随时都可以讲。”</p>\n<p>大明说：“好嘞，我先给我的弟弟小明打个电话，和他说有优化器高手来了，赶紧过来请教。”</p>\n<p>……（此处略去近千字）</p>\n<p>小明早就听说过牛二哥的名字，据说对查询优化非常了解，没想到牛二哥竟然和自己的哥哥是同事，于是赶紧来到了大明家，看到牛二哥的洗旧的格子衫和半秃的发型，感觉就像少林寺的扫地僧一样，于是赶紧说：“我这最近正在查看基于代价的优化，感觉付出了很多代价，但收获甚微啊，期望今天能得到牛二哥的指导。”</p>\n<p>牛二哥说：“不客气，我是也是受到了大腰子和红酒的诱惑，估计今天也要付出惨痛的代价。。。。你有什么问题尽管问，我捡我会的回答。”看着小明稚嫩的脸庞，牛二哥突然想起了自己刚开始从事数据库内核开发的日子，心底翻腾起一股悲凉感，那是一段不堪回首的血泪史啊，有血、有泪、有。。。</p>\n<p>牛二哥突然想到了什么，继续说道：“说到代价，我觉得有个东西是绕不过去的，那就是统计信息和选择率，PostgreSQL数据库的物理优化需要计算各种物理路径的代价，而代价估算的过程严重的依赖于数据库的统计信息，统计信息是否能准确的描述表中的数据分布情况是决定代价的准确性的重要条件之一。”</p>\n<p>小明说：“大明和我说过，数据库有很多的物理路径，这些物理路径我们也叫他们物理算子，和逻辑算子不同，物理算子是查询执行器的执行方法，我们只需要计算物理算子每个步骤的代价，汇总起来就是路径的代价了，那要统计信息有什么用呢？”</p>\n<p>牛二哥看了看大明，意思是让大明来说，不过大明正在专心的查吃了吗外卖APP，找大腰子和红酒，并没有看到牛二哥的眼神，牛二哥只好尴尬的说：“是的，我们就是要计算一个物理算子的代价，但是物理算子的计算量并不是一成不变的。”说着牛二哥从旁边的书桌上拿来纸和笔，在纸上写了两个SQL语句。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT A+B FROM TEST_A WHERE A &gt; 1;</span><br><span class=\"line\">SELECT A+B FROM TEST_A WHERE A &gt; 100000000;</span><br></pre></td></tr></table></figure>\n\n<p>然后牛二哥说：“你看，这两个语句可以用同样的物理算子来完成，但是他们的计算量一样吗？”</p>\n<p>小明心想：A &gt; 1和A &gt; 1000000000都是过滤条件，经过过滤之后，他们产生的数据量就不同了，这样投影中的A+B的计算的次数就不同了，所以他们的代价应该是不同的，那它和统计信息有什么关系呢？小明感觉灵光一闪，马上说：“我知道了，我在计算物理算子的代价的时候，要知道A &gt; 1之后还剩下多少数据或者A &gt; 1000000000之后还剩下多少数据，如果我们提前对表上的数据内容做了统计，剩下多少数据就不难计算了，所以必须要有统计信息。”</p>\n<p>牛二哥点了点头，说：“嗯，通过统计信息，代价估算系统就可以了解一个表有多少行数据、用了多少个数据页面、某个值出现的频率等等，然后就能根据这些信息计算出一个约束条件能过滤掉多少数据，这种约束条件过滤出的数据占总数据量的比例称之为‘选择率’，所谓选择率就是一个比例，它的公式是这样的。”说着牛二哥继续在纸上写了选择率的公式：<br>选择率=约束条件过滤后的元组数/约束条件过滤前的总元组数</p>\n<p>“不过上面的示例有点简单了，实际应用中通常约束条件会比较多，而且比较复杂，通常我们会计算每个子约束条件的选择率，然后就可以根据AND运算符和OR运算符计算它们的综合的选择率，AND运算符和OR运算符的选择率计算是基于概率的，你看这里的概率公式。”说着，牛二哥又继续在纸上写起来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P(A+B)&#x3D;P(A)+P(B)-P(AB)</span><br><span class=\"line\">P(AB)&#x3D;P(A)×P(B)</span><br></pre></td></tr></table></figure>\n\n<p>“有了这些，我们就可以求解多种类型的约束条件的选择率了，比如。。。”牛二哥继续在纸上画起来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  P(ssex IS NOT NULL OR sno &gt; 5) </span><br><span class=\"line\">&#x3D; P(ssex IS NOT NULL) + P(sno &gt; 5) – P(ssex IS NOT NULL AND sno &gt; 5)</span><br><span class=\"line\">&#x3D; P(ssex IS NOT NULL) + P(sno &gt; 5) – P(ssex IS NOT NULL) × P(no &gt; 5)</span><br></pre></td></tr></table></figure>\n\n<p>小明觉得牛二哥的进展有点快，赶紧问：“那么统计信息是什么形式的呢？”</p>\n<p>牛二哥挠挠头，说：“这个还真是有点麻烦，我们说常用的统计信息的形式就是distinct率、NULL值率、高频值、直方图、相关系数这些，他们分别有不同的作用，比如说distinct率，你可以获知某一列有多少个独立值，这种信息对于像性别这种列就显得特别有用，NULL值率呢？在统计的过程中，NULL值是不好处理的，因此把它独立出来，形成NULL值率，这样在高频值、直方图这些里面就不用考虑NULL值的情况了，高频值属于奇异值，顾名思义，就是出现的比较多的一些列值，去掉了NULL值，再去掉高频值，剩下的值可以用来做一个等频的直方图。。。。”</p>\n<p>“呃。。。”小明感觉跟不上牛二哥的速度了，于是说：“有点快，我有点跟不上了。”</p>\n<p>这时大明已经点完了外卖，过来说：“别急，外卖没有那么快送到，至于统计信息嘛，主要的还是高频值、直方图和相关系数，实际上我建议还是不要纠结于统计信息有哪些形式，我们只要知道它是用来算代价的就可以了。”</p>\n<p>牛二哥对大明说：“这怎么可以，我还没有说统计信息是如何生成的呢，比如它通过了两阶段采样，然后对样本进行统计时使用的统计方法，哪些值可以作为高频值，直方图有几个桶，相关系数是怎么计算的，相关系数在计算索引扫描路径代价的时候怎么用的，而且我和你说，PostgreSQL还出了基于多列的扩展统计信息，多列统计信息分成了哪些类型，分别是什么含义，各自是怎么计算的，还有选择率是怎么结合统计信息计算的，这些我还没说呢。。。”</p>\n<p>大明说：“你快闭嘴吧，像你这样讲优化器，岂不是要出一本书。”</p>\n<p>牛二哥做痛苦状：“那好吧，统计信息我们就说到这里吧，但是它确实是代价计算的基石，小明同学，你理解了它的作用就可以了。”</p>\n<p>小明痛苦的说：“牛二哥，你说了这么多，都不告诉我答案，我感觉要学的内容好多啊。”</p>\n<p>大明笑着说：“不用这么痛苦嘛，没有啥事是一顿烧烤不能解决的，如果有，那就是两顿。”然后大明继续神秘的说：“实际上统计信息往往也不准，你想想本来就是采样的结果嘛，样本是否显著压根就不好说，而且随着应用程序对表的更新，统计信息可能更新不及时，那就更会出现偏差。更严重的是，如果我们遇到a &gt; b这样的约束条件，使用统计信息计算选择率也很不好计算，即使算出来，也不准嘛。”</p>\n<p>牛二哥说：“是的，统计信息确实也有不准确的问题，我听说有个DBA，他家祖坟旁边出了一口泉水，他爸爸觉得是吉兆，去找风水大师看一看，风水大师掐指算一算，说：你儿子是个DBA，每次数据库性能慢就知道更新统计信息，可是统计信息太水了，都从你家祖坟冒出来了。”</p>\n<p>三个人顿时笑做一团，气氛从痛苦又恢复到了活泼，大明说：“学习查询优化器确实还是比较繁琐的，绝对不是我们通过一两次讲解就能让你变得精通的，这个学习的曲线还是比较陡峭的。”</p>\n<p>小明点了点头说：“好吧，有了两位师傅，再加上我自己天资聪慧、风流倜傥、玉树临风、高大威武、骨骼惊奇，我相信一定能将优化器搞定。”</p>\n<p>大明和牛二哥都晕倒在地上。。。</p>\n","site":{"data":{}},"excerpt":"<p>“咚咚咚。。。咚咚咚”门外传来了敲门声，大明去打开房门一看，进来的原来是自己的同事牛二哥，牛二哥是专门从事数据库查询优化开发的码农，也有十几年的从业经验了，大明感到非常happy，因为这两天给小明讲查询优化器干到有些吃力，今天牛二哥来了，可以帮助自己给小明来讲查询优化器了，于是和牛二哥说：“牛二同志，来了就别走了，今天大腰子加红酒管够，你来帮我个忙。”</p>\n<p>牛二哥是大腰子爱好者，听说有大腰子，顿时感觉浑身鸡血翻腾，连忙说：“没问题，不过要帮什么忙？”</p>","more":"<p>大明说：“我的弟弟小明最近在学校要进行数据库原理实践，最近总来问我优化器的问题，可我对优化器也是一知半解，这下你来了，你可以帮我弟弟讲讲优化器了。”</p>\n<p>牛二哥痛快的说：“这难不倒我，随时都可以讲。”</p>\n<p>大明说：“好嘞，我先给我的弟弟小明打个电话，和他说有优化器高手来了，赶紧过来请教。”</p>\n<p>……（此处略去近千字）</p>\n<p>小明早就听说过牛二哥的名字，据说对查询优化非常了解，没想到牛二哥竟然和自己的哥哥是同事，于是赶紧来到了大明家，看到牛二哥的洗旧的格子衫和半秃的发型，感觉就像少林寺的扫地僧一样，于是赶紧说：“我这最近正在查看基于代价的优化，感觉付出了很多代价，但收获甚微啊，期望今天能得到牛二哥的指导。”</p>\n<p>牛二哥说：“不客气，我是也是受到了大腰子和红酒的诱惑，估计今天也要付出惨痛的代价。。。。你有什么问题尽管问，我捡我会的回答。”看着小明稚嫩的脸庞，牛二哥突然想起了自己刚开始从事数据库内核开发的日子，心底翻腾起一股悲凉感，那是一段不堪回首的血泪史啊，有血、有泪、有。。。</p>\n<p>牛二哥突然想到了什么，继续说道：“说到代价，我觉得有个东西是绕不过去的，那就是统计信息和选择率，PostgreSQL数据库的物理优化需要计算各种物理路径的代价，而代价估算的过程严重的依赖于数据库的统计信息，统计信息是否能准确的描述表中的数据分布情况是决定代价的准确性的重要条件之一。”</p>\n<p>小明说：“大明和我说过，数据库有很多的物理路径，这些物理路径我们也叫他们物理算子，和逻辑算子不同，物理算子是查询执行器的执行方法，我们只需要计算物理算子每个步骤的代价，汇总起来就是路径的代价了，那要统计信息有什么用呢？”</p>\n<p>牛二哥看了看大明，意思是让大明来说，不过大明正在专心的查吃了吗外卖APP，找大腰子和红酒，并没有看到牛二哥的眼神，牛二哥只好尴尬的说：“是的，我们就是要计算一个物理算子的代价，但是物理算子的计算量并不是一成不变的。”说着牛二哥从旁边的书桌上拿来纸和笔，在纸上写了两个SQL语句。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT A+B FROM TEST_A WHERE A &gt; 1;</span><br><span class=\"line\">SELECT A+B FROM TEST_A WHERE A &gt; 100000000;</span><br></pre></td></tr></table></figure>\n\n<p>然后牛二哥说：“你看，这两个语句可以用同样的物理算子来完成，但是他们的计算量一样吗？”</p>\n<p>小明心想：A &gt; 1和A &gt; 1000000000都是过滤条件，经过过滤之后，他们产生的数据量就不同了，这样投影中的A+B的计算的次数就不同了，所以他们的代价应该是不同的，那它和统计信息有什么关系呢？小明感觉灵光一闪，马上说：“我知道了，我在计算物理算子的代价的时候，要知道A &gt; 1之后还剩下多少数据或者A &gt; 1000000000之后还剩下多少数据，如果我们提前对表上的数据内容做了统计，剩下多少数据就不难计算了，所以必须要有统计信息。”</p>\n<p>牛二哥点了点头，说：“嗯，通过统计信息，代价估算系统就可以了解一个表有多少行数据、用了多少个数据页面、某个值出现的频率等等，然后就能根据这些信息计算出一个约束条件能过滤掉多少数据，这种约束条件过滤出的数据占总数据量的比例称之为‘选择率’，所谓选择率就是一个比例，它的公式是这样的。”说着牛二哥继续在纸上写了选择率的公式：<br>选择率=约束条件过滤后的元组数/约束条件过滤前的总元组数</p>\n<p>“不过上面的示例有点简单了，实际应用中通常约束条件会比较多，而且比较复杂，通常我们会计算每个子约束条件的选择率，然后就可以根据AND运算符和OR运算符计算它们的综合的选择率，AND运算符和OR运算符的选择率计算是基于概率的，你看这里的概率公式。”说着，牛二哥又继续在纸上写起来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P(A+B)&#x3D;P(A)+P(B)-P(AB)</span><br><span class=\"line\">P(AB)&#x3D;P(A)×P(B)</span><br></pre></td></tr></table></figure>\n\n<p>“有了这些，我们就可以求解多种类型的约束条件的选择率了，比如。。。”牛二哥继续在纸上画起来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  P(ssex IS NOT NULL OR sno &gt; 5) </span><br><span class=\"line\">&#x3D; P(ssex IS NOT NULL) + P(sno &gt; 5) – P(ssex IS NOT NULL AND sno &gt; 5)</span><br><span class=\"line\">&#x3D; P(ssex IS NOT NULL) + P(sno &gt; 5) – P(ssex IS NOT NULL) × P(no &gt; 5)</span><br></pre></td></tr></table></figure>\n\n<p>小明觉得牛二哥的进展有点快，赶紧问：“那么统计信息是什么形式的呢？”</p>\n<p>牛二哥挠挠头，说：“这个还真是有点麻烦，我们说常用的统计信息的形式就是distinct率、NULL值率、高频值、直方图、相关系数这些，他们分别有不同的作用，比如说distinct率，你可以获知某一列有多少个独立值，这种信息对于像性别这种列就显得特别有用，NULL值率呢？在统计的过程中，NULL值是不好处理的，因此把它独立出来，形成NULL值率，这样在高频值、直方图这些里面就不用考虑NULL值的情况了，高频值属于奇异值，顾名思义，就是出现的比较多的一些列值，去掉了NULL值，再去掉高频值，剩下的值可以用来做一个等频的直方图。。。。”</p>\n<p>“呃。。。”小明感觉跟不上牛二哥的速度了，于是说：“有点快，我有点跟不上了。”</p>\n<p>这时大明已经点完了外卖，过来说：“别急，外卖没有那么快送到，至于统计信息嘛，主要的还是高频值、直方图和相关系数，实际上我建议还是不要纠结于统计信息有哪些形式，我们只要知道它是用来算代价的就可以了。”</p>\n<p>牛二哥对大明说：“这怎么可以，我还没有说统计信息是如何生成的呢，比如它通过了两阶段采样，然后对样本进行统计时使用的统计方法，哪些值可以作为高频值，直方图有几个桶，相关系数是怎么计算的，相关系数在计算索引扫描路径代价的时候怎么用的，而且我和你说，PostgreSQL还出了基于多列的扩展统计信息，多列统计信息分成了哪些类型，分别是什么含义，各自是怎么计算的，还有选择率是怎么结合统计信息计算的，这些我还没说呢。。。”</p>\n<p>大明说：“你快闭嘴吧，像你这样讲优化器，岂不是要出一本书。”</p>\n<p>牛二哥做痛苦状：“那好吧，统计信息我们就说到这里吧，但是它确实是代价计算的基石，小明同学，你理解了它的作用就可以了。”</p>\n<p>小明痛苦的说：“牛二哥，你说了这么多，都不告诉我答案，我感觉要学的内容好多啊。”</p>\n<p>大明笑着说：“不用这么痛苦嘛，没有啥事是一顿烧烤不能解决的，如果有，那就是两顿。”然后大明继续神秘的说：“实际上统计信息往往也不准，你想想本来就是采样的结果嘛，样本是否显著压根就不好说，而且随着应用程序对表的更新，统计信息可能更新不及时，那就更会出现偏差。更严重的是，如果我们遇到a &gt; b这样的约束条件，使用统计信息计算选择率也很不好计算，即使算出来，也不准嘛。”</p>\n<p>牛二哥说：“是的，统计信息确实也有不准确的问题，我听说有个DBA，他家祖坟旁边出了一口泉水，他爸爸觉得是吉兆，去找风水大师看一看，风水大师掐指算一算，说：你儿子是个DBA，每次数据库性能慢就知道更新统计信息，可是统计信息太水了，都从你家祖坟冒出来了。”</p>\n<p>三个人顿时笑做一团，气氛从痛苦又恢复到了活泼，大明说：“学习查询优化器确实还是比较繁琐的，绝对不是我们通过一两次讲解就能让你变得精通的，这个学习的曲线还是比较陡峭的。”</p>\n<p>小明点了点头说：“好吧，有了两位师傅，再加上我自己天资聪慧、风流倜傥、玉树临风、高大威武、骨骼惊奇，我相信一定能将优化器搞定。”</p>\n<p>大明和牛二哥都晕倒在地上。。。</p>"},{"title":"PostgreSQL优化器白话(7) - 你走你的阳关道","date":"2020-10-03T00:36:07.000Z","_content":"\n小明“摇醒”了晕倒的大明和牛二哥，然后说：“趁着大腰子和红酒还没送到，不如给我说说物理路径吧，虽然我们代价计算来计算去，最终还是为物理路径计算代价嘛。”\n\n大明愤怒的说：“讲物理路径可以，不过你如果再这么吹嘘自己，咱俩就势不两立，你走你的阳关道，我过我的独木桥。”\n\n牛二哥笑着说：“我看还是先算算走阳关道合算还是走独木桥合算吧，同样一件事，既可以走阳关道，也可以走独木桥，所谓殊途同归于尽嘛，不过我们还是得知道哪一个适合自己。”<!-- more -->\n\n小明说：“大明和我说过这些阳关道和独木桥，它大体上分成扫描路径和连接路径，我查过一些查询优化器的说明，我知道扫描路径有顺序扫描路径、索引扫描路径、位图扫描路径等等，而连接路径通常有嵌套循环连接路径、哈希连接路径、归并连接路径，另外还有一些其他的路径，比如排序路径、物化路径等等。”\n\n牛二哥说：“是的，我们就来说说这些路径的含义吧。如果要获得一个表中的数据，最基础的方法就是将表中的所有的数据都遍历一遍，从中挑选出符合条件的数据，这种方式就是顺序扫描路径，顺序扫描路径的优点是其具有广泛的适用性，各种表都可以用这种方法，它缺点自然是代价通常比较高，因为要把所有的数据都遍历一遍。”大明趁着牛二哥说顺序扫描路径的时候，在纸上画了个图，说：“这个图大概就是顺序扫描路径。”\n\n![](./postgresql-optimizer-outline-7/1.jpg) \n\n牛二哥则继续说：“如果将数据做一些预处理，比如建立一个索引，如果要想获得一个表的数据，可以通过扫描索引获得所需数据的“地址”，然后通过地址将需要的数据获取出来，尤其是在选择操作带有约束条件的情况下，在索引和约束条件共同的作用下，表中的有些数据就不用再遍历了，因为通过索引就很容易知道这些数据是不符合约束条件的，更有甚者，因为索引上也保存了数据，它的数据和关系中的数据是一致的，因此如果索引上的数据就能满足要求，就只需要扫描索引就可以获得所需的数据了，也就是说在扫描路径中还可以有索引扫描路径和快速索引扫描路径两种方式。”\n\n大明则继续为牛二哥“捧哏”，在纸上画上了索引扫描和快速索引扫描的图。\n\n![](./postgresql-optimizer-outline-7/2.png) \n \n小明看到大明特意在图里写上了“随机读”三个字，于是问道：“我看这个索引扫描有随机读的问题，这个问题能否把它解决掉呢？也就是说即利用了索引，还避免了随机读的问题，有这样的办法吗？”\n\n牛二哥说：“索引扫描路径确实带来随机读的问题，因为索引中记录的是数据元组的地址，索引扫描是通过扫描索引获得元组地址，然后通过元组地址访问数据，索引中保存的“有序”的地址，到数据中就可能是随机的了，位图扫描就能解决这个问题，它通过位图将地址保存起来，把地址收集起来之后，然后让地址变得有序，这样就通过中间的位图把随机读消解掉了。”大明则继续在纸上画上了位图扫描的示意图。\n\n![](./postgresql-optimizer-outline-7/3.png) \n \n不过大明不甘心一直“站在桌子里面”，也想“站到桌子外面”承担一下“逗哏”的角色，于是说道：“扫描的过程中还会结合一些特殊的情况有一些非常高效的扫描路径，比如TID扫描路径，TID实际上是元组在磁盘上的存储地址，我们能够根据TID直接就获得元组，这样查询的效率就非常高了。”\n\n牛二哥点了点头继续说到：“扫描路径通常是执行计划中的叶子结点，也就是在最底层对表进行扫描的结点，扫描路径就是为连接路径做准备的，扫描出来的数据就可以给连接路径来实现连接操作了。”\n\n大明一边在纸上画一边说道：“要对两个关系做连接，受笛卡尔积的启发，可以用一个算法复杂度是O(mn)的方法来实现，我们叫它Nestlooped Join方法，这种方法虽然复杂度比较高，但是和顺序扫描一样，胜在具有普适性。”\n\n牛二哥说：“嵌套循环连接这种方法的复杂度比较高，看上去没什么意义，但是如果Nestlooped Join的内表的路径是一个索引扫描路径，那么算法的复杂度就会降下来，索引扫描的算法复杂度是O(logn)，因此如果Nestlooped Join的内表是一个索引扫描，它的整体的算法复杂度就变成了O(mlogn)，看上去这样也是可以接受的。”\n\n![](./postgresql-optimizer-outline-7/4.png) \n\n小明点了点头说：“嗯，索引实际上是对数据做了一些预处理，我想如果哈希连接方法就是将内表做一个哈希表，这样也等于将内表的数据做了预处理，也能方便外表的元组在里面探测吧？”\n\n牛二哥点了点头说：“假设Hash表有N个桶，内表数据均匀的分布在各个桶中，那么Hash Join的时间复杂度就是O(m * n /N)，当然，这里我们没有考虑上建立Hash表的代价。”\n\n大明则在纸上画出了Hash连接的示意图，并且补充道：“Hash连接通常只能用来做等值判断。”\n\n![](./postgresql-optimizer-outline-7/5.png) \n \n牛二哥继续说：“如果将两个表先排序，那么就可以引入第三种连接方式，Merge Join，这种连接方式的代价主要浪费在排序上，如果两个关系的数据量都比较小，那么排序的代价是可控的，MergeJoin就是适用的，另外如果关系上有有序的索引，那么就可以不用单独排序了，这样也比较适用于MergeJoin。你看我画的这个归并连接的示意图，外表是需要排序的，而内表则借用了原有的索引的顺序，消除了排序的时间，降低了物理路径的代价。”\n\n![](./postgresql-optimizer-outline-7/6.png) \n \n“这些路径属于SPJ路径，在PostgreSQL的优化器中，通常会先生成SPJ的路径，然后在这基础上再叠加Non-SPJ的路径，比如说聚集操作、排序操作、limit操作、分组操作。。。。”牛二哥继续补充道。\n\n“咚咚咚，咚咚咚”敲门声响了，吃了吗外卖东来了三个人最爱的大腰子，吃大腰子的感觉完全停不下来，至于优化器。。。先让它见鬼去吧。\n","source":"_posts/postgresql-optimizer-outline-7.md","raw":"---\ntitle: PostgreSQL优化器白话(7) - 你走你的阳关道\ndate: 2020-10-03 08:36:07\ntags: 路径 Path 顺序扫描 索引扫描 位图扫描 Join\n---\n\n小明“摇醒”了晕倒的大明和牛二哥，然后说：“趁着大腰子和红酒还没送到，不如给我说说物理路径吧，虽然我们代价计算来计算去，最终还是为物理路径计算代价嘛。”\n\n大明愤怒的说：“讲物理路径可以，不过你如果再这么吹嘘自己，咱俩就势不两立，你走你的阳关道，我过我的独木桥。”\n\n牛二哥笑着说：“我看还是先算算走阳关道合算还是走独木桥合算吧，同样一件事，既可以走阳关道，也可以走独木桥，所谓殊途同归于尽嘛，不过我们还是得知道哪一个适合自己。”<!-- more -->\n\n小明说：“大明和我说过这些阳关道和独木桥，它大体上分成扫描路径和连接路径，我查过一些查询优化器的说明，我知道扫描路径有顺序扫描路径、索引扫描路径、位图扫描路径等等，而连接路径通常有嵌套循环连接路径、哈希连接路径、归并连接路径，另外还有一些其他的路径，比如排序路径、物化路径等等。”\n\n牛二哥说：“是的，我们就来说说这些路径的含义吧。如果要获得一个表中的数据，最基础的方法就是将表中的所有的数据都遍历一遍，从中挑选出符合条件的数据，这种方式就是顺序扫描路径，顺序扫描路径的优点是其具有广泛的适用性，各种表都可以用这种方法，它缺点自然是代价通常比较高，因为要把所有的数据都遍历一遍。”大明趁着牛二哥说顺序扫描路径的时候，在纸上画了个图，说：“这个图大概就是顺序扫描路径。”\n\n![](./postgresql-optimizer-outline-7/1.jpg) \n\n牛二哥则继续说：“如果将数据做一些预处理，比如建立一个索引，如果要想获得一个表的数据，可以通过扫描索引获得所需数据的“地址”，然后通过地址将需要的数据获取出来，尤其是在选择操作带有约束条件的情况下，在索引和约束条件共同的作用下，表中的有些数据就不用再遍历了，因为通过索引就很容易知道这些数据是不符合约束条件的，更有甚者，因为索引上也保存了数据，它的数据和关系中的数据是一致的，因此如果索引上的数据就能满足要求，就只需要扫描索引就可以获得所需的数据了，也就是说在扫描路径中还可以有索引扫描路径和快速索引扫描路径两种方式。”\n\n大明则继续为牛二哥“捧哏”，在纸上画上了索引扫描和快速索引扫描的图。\n\n![](./postgresql-optimizer-outline-7/2.png) \n \n小明看到大明特意在图里写上了“随机读”三个字，于是问道：“我看这个索引扫描有随机读的问题，这个问题能否把它解决掉呢？也就是说即利用了索引，还避免了随机读的问题，有这样的办法吗？”\n\n牛二哥说：“索引扫描路径确实带来随机读的问题，因为索引中记录的是数据元组的地址，索引扫描是通过扫描索引获得元组地址，然后通过元组地址访问数据，索引中保存的“有序”的地址，到数据中就可能是随机的了，位图扫描就能解决这个问题，它通过位图将地址保存起来，把地址收集起来之后，然后让地址变得有序，这样就通过中间的位图把随机读消解掉了。”大明则继续在纸上画上了位图扫描的示意图。\n\n![](./postgresql-optimizer-outline-7/3.png) \n \n不过大明不甘心一直“站在桌子里面”，也想“站到桌子外面”承担一下“逗哏”的角色，于是说道：“扫描的过程中还会结合一些特殊的情况有一些非常高效的扫描路径，比如TID扫描路径，TID实际上是元组在磁盘上的存储地址，我们能够根据TID直接就获得元组，这样查询的效率就非常高了。”\n\n牛二哥点了点头继续说到：“扫描路径通常是执行计划中的叶子结点，也就是在最底层对表进行扫描的结点，扫描路径就是为连接路径做准备的，扫描出来的数据就可以给连接路径来实现连接操作了。”\n\n大明一边在纸上画一边说道：“要对两个关系做连接，受笛卡尔积的启发，可以用一个算法复杂度是O(mn)的方法来实现，我们叫它Nestlooped Join方法，这种方法虽然复杂度比较高，但是和顺序扫描一样，胜在具有普适性。”\n\n牛二哥说：“嵌套循环连接这种方法的复杂度比较高，看上去没什么意义，但是如果Nestlooped Join的内表的路径是一个索引扫描路径，那么算法的复杂度就会降下来，索引扫描的算法复杂度是O(logn)，因此如果Nestlooped Join的内表是一个索引扫描，它的整体的算法复杂度就变成了O(mlogn)，看上去这样也是可以接受的。”\n\n![](./postgresql-optimizer-outline-7/4.png) \n\n小明点了点头说：“嗯，索引实际上是对数据做了一些预处理，我想如果哈希连接方法就是将内表做一个哈希表，这样也等于将内表的数据做了预处理，也能方便外表的元组在里面探测吧？”\n\n牛二哥点了点头说：“假设Hash表有N个桶，内表数据均匀的分布在各个桶中，那么Hash Join的时间复杂度就是O(m * n /N)，当然，这里我们没有考虑上建立Hash表的代价。”\n\n大明则在纸上画出了Hash连接的示意图，并且补充道：“Hash连接通常只能用来做等值判断。”\n\n![](./postgresql-optimizer-outline-7/5.png) \n \n牛二哥继续说：“如果将两个表先排序，那么就可以引入第三种连接方式，Merge Join，这种连接方式的代价主要浪费在排序上，如果两个关系的数据量都比较小，那么排序的代价是可控的，MergeJoin就是适用的，另外如果关系上有有序的索引，那么就可以不用单独排序了，这样也比较适用于MergeJoin。你看我画的这个归并连接的示意图，外表是需要排序的，而内表则借用了原有的索引的顺序，消除了排序的时间，降低了物理路径的代价。”\n\n![](./postgresql-optimizer-outline-7/6.png) \n \n“这些路径属于SPJ路径，在PostgreSQL的优化器中，通常会先生成SPJ的路径，然后在这基础上再叠加Non-SPJ的路径，比如说聚集操作、排序操作、limit操作、分组操作。。。。”牛二哥继续补充道。\n\n“咚咚咚，咚咚咚”敲门声响了，吃了吗外卖东来了三个人最爱的大腰子，吃大腰子的感觉完全停不下来，至于优化器。。。先让它见鬼去吧。\n","slug":"postgresql-optimizer-outline-7","published":1,"updated":"2020-10-03T01:12:47.000Z","_id":"ckfszbzyj0000ro9kgeuy15hy","comments":1,"layout":"post","photos":[],"link":"","content":"<p>小明“摇醒”了晕倒的大明和牛二哥，然后说：“趁着大腰子和红酒还没送到，不如给我说说物理路径吧，虽然我们代价计算来计算去，最终还是为物理路径计算代价嘛。”</p>\n<p>大明愤怒的说：“讲物理路径可以，不过你如果再这么吹嘘自己，咱俩就势不两立，你走你的阳关道，我过我的独木桥。”</p>\n<p>牛二哥笑着说：“我看还是先算算走阳关道合算还是走独木桥合算吧，同样一件事，既可以走阳关道，也可以走独木桥，所谓殊途同归于尽嘛，不过我们还是得知道哪一个适合自己。”<a id=\"more\"></a></p>\n<p>小明说：“大明和我说过这些阳关道和独木桥，它大体上分成扫描路径和连接路径，我查过一些查询优化器的说明，我知道扫描路径有顺序扫描路径、索引扫描路径、位图扫描路径等等，而连接路径通常有嵌套循环连接路径、哈希连接路径、归并连接路径，另外还有一些其他的路径，比如排序路径、物化路径等等。”</p>\n<p>牛二哥说：“是的，我们就来说说这些路径的含义吧。如果要获得一个表中的数据，最基础的方法就是将表中的所有的数据都遍历一遍，从中挑选出符合条件的数据，这种方式就是顺序扫描路径，顺序扫描路径的优点是其具有广泛的适用性，各种表都可以用这种方法，它缺点自然是代价通常比较高，因为要把所有的数据都遍历一遍。”大明趁着牛二哥说顺序扫描路径的时候，在纸上画了个图，说：“这个图大概就是顺序扫描路径。”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/1.jpg\"> </p>\n<p>牛二哥则继续说：“如果将数据做一些预处理，比如建立一个索引，如果要想获得一个表的数据，可以通过扫描索引获得所需数据的“地址”，然后通过地址将需要的数据获取出来，尤其是在选择操作带有约束条件的情况下，在索引和约束条件共同的作用下，表中的有些数据就不用再遍历了，因为通过索引就很容易知道这些数据是不符合约束条件的，更有甚者，因为索引上也保存了数据，它的数据和关系中的数据是一致的，因此如果索引上的数据就能满足要求，就只需要扫描索引就可以获得所需的数据了，也就是说在扫描路径中还可以有索引扫描路径和快速索引扫描路径两种方式。”</p>\n<p>大明则继续为牛二哥“捧哏”，在纸上画上了索引扫描和快速索引扫描的图。</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/2.png\"> </p>\n<p>小明看到大明特意在图里写上了“随机读”三个字，于是问道：“我看这个索引扫描有随机读的问题，这个问题能否把它解决掉呢？也就是说即利用了索引，还避免了随机读的问题，有这样的办法吗？”</p>\n<p>牛二哥说：“索引扫描路径确实带来随机读的问题，因为索引中记录的是数据元组的地址，索引扫描是通过扫描索引获得元组地址，然后通过元组地址访问数据，索引中保存的“有序”的地址，到数据中就可能是随机的了，位图扫描就能解决这个问题，它通过位图将地址保存起来，把地址收集起来之后，然后让地址变得有序，这样就通过中间的位图把随机读消解掉了。”大明则继续在纸上画上了位图扫描的示意图。</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/3.png\"> </p>\n<p>不过大明不甘心一直“站在桌子里面”，也想“站到桌子外面”承担一下“逗哏”的角色，于是说道：“扫描的过程中还会结合一些特殊的情况有一些非常高效的扫描路径，比如TID扫描路径，TID实际上是元组在磁盘上的存储地址，我们能够根据TID直接就获得元组，这样查询的效率就非常高了。”</p>\n<p>牛二哥点了点头继续说到：“扫描路径通常是执行计划中的叶子结点，也就是在最底层对表进行扫描的结点，扫描路径就是为连接路径做准备的，扫描出来的数据就可以给连接路径来实现连接操作了。”</p>\n<p>大明一边在纸上画一边说道：“要对两个关系做连接，受笛卡尔积的启发，可以用一个算法复杂度是O(mn)的方法来实现，我们叫它Nestlooped Join方法，这种方法虽然复杂度比较高，但是和顺序扫描一样，胜在具有普适性。”</p>\n<p>牛二哥说：“嵌套循环连接这种方法的复杂度比较高，看上去没什么意义，但是如果Nestlooped Join的内表的路径是一个索引扫描路径，那么算法的复杂度就会降下来，索引扫描的算法复杂度是O(logn)，因此如果Nestlooped Join的内表是一个索引扫描，它的整体的算法复杂度就变成了O(mlogn)，看上去这样也是可以接受的。”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/4.png\"> </p>\n<p>小明点了点头说：“嗯，索引实际上是对数据做了一些预处理，我想如果哈希连接方法就是将内表做一个哈希表，这样也等于将内表的数据做了预处理，也能方便外表的元组在里面探测吧？”</p>\n<p>牛二哥点了点头说：“假设Hash表有N个桶，内表数据均匀的分布在各个桶中，那么Hash Join的时间复杂度就是O(m * n /N)，当然，这里我们没有考虑上建立Hash表的代价。”</p>\n<p>大明则在纸上画出了Hash连接的示意图，并且补充道：“Hash连接通常只能用来做等值判断。”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/5.png\"> </p>\n<p>牛二哥继续说：“如果将两个表先排序，那么就可以引入第三种连接方式，Merge Join，这种连接方式的代价主要浪费在排序上，如果两个关系的数据量都比较小，那么排序的代价是可控的，MergeJoin就是适用的，另外如果关系上有有序的索引，那么就可以不用单独排序了，这样也比较适用于MergeJoin。你看我画的这个归并连接的示意图，外表是需要排序的，而内表则借用了原有的索引的顺序，消除了排序的时间，降低了物理路径的代价。”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/6.png\"> </p>\n<p>“这些路径属于SPJ路径，在PostgreSQL的优化器中，通常会先生成SPJ的路径，然后在这基础上再叠加Non-SPJ的路径，比如说聚集操作、排序操作、limit操作、分组操作。。。。”牛二哥继续补充道。</p>\n<p>“咚咚咚，咚咚咚”敲门声响了，吃了吗外卖东来了三个人最爱的大腰子，吃大腰子的感觉完全停不下来，至于优化器。。。先让它见鬼去吧。</p>\n","site":{"data":{}},"excerpt":"<p>小明“摇醒”了晕倒的大明和牛二哥，然后说：“趁着大腰子和红酒还没送到，不如给我说说物理路径吧，虽然我们代价计算来计算去，最终还是为物理路径计算代价嘛。”</p>\n<p>大明愤怒的说：“讲物理路径可以，不过你如果再这么吹嘘自己，咱俩就势不两立，你走你的阳关道，我过我的独木桥。”</p>\n<p>牛二哥笑着说：“我看还是先算算走阳关道合算还是走独木桥合算吧，同样一件事，既可以走阳关道，也可以走独木桥，所谓殊途同归于尽嘛，不过我们还是得知道哪一个适合自己。”</p>","more":"<p></p>\n<p>小明说：“大明和我说过这些阳关道和独木桥，它大体上分成扫描路径和连接路径，我查过一些查询优化器的说明，我知道扫描路径有顺序扫描路径、索引扫描路径、位图扫描路径等等，而连接路径通常有嵌套循环连接路径、哈希连接路径、归并连接路径，另外还有一些其他的路径，比如排序路径、物化路径等等。”</p>\n<p>牛二哥说：“是的，我们就来说说这些路径的含义吧。如果要获得一个表中的数据，最基础的方法就是将表中的所有的数据都遍历一遍，从中挑选出符合条件的数据，这种方式就是顺序扫描路径，顺序扫描路径的优点是其具有广泛的适用性，各种表都可以用这种方法，它缺点自然是代价通常比较高，因为要把所有的数据都遍历一遍。”大明趁着牛二哥说顺序扫描路径的时候，在纸上画了个图，说：“这个图大概就是顺序扫描路径。”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/1.jpg\"> </p>\n<p>牛二哥则继续说：“如果将数据做一些预处理，比如建立一个索引，如果要想获得一个表的数据，可以通过扫描索引获得所需数据的“地址”，然后通过地址将需要的数据获取出来，尤其是在选择操作带有约束条件的情况下，在索引和约束条件共同的作用下，表中的有些数据就不用再遍历了，因为通过索引就很容易知道这些数据是不符合约束条件的，更有甚者，因为索引上也保存了数据，它的数据和关系中的数据是一致的，因此如果索引上的数据就能满足要求，就只需要扫描索引就可以获得所需的数据了，也就是说在扫描路径中还可以有索引扫描路径和快速索引扫描路径两种方式。”</p>\n<p>大明则继续为牛二哥“捧哏”，在纸上画上了索引扫描和快速索引扫描的图。</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/2.png\"> </p>\n<p>小明看到大明特意在图里写上了“随机读”三个字，于是问道：“我看这个索引扫描有随机读的问题，这个问题能否把它解决掉呢？也就是说即利用了索引，还避免了随机读的问题，有这样的办法吗？”</p>\n<p>牛二哥说：“索引扫描路径确实带来随机读的问题，因为索引中记录的是数据元组的地址，索引扫描是通过扫描索引获得元组地址，然后通过元组地址访问数据，索引中保存的“有序”的地址，到数据中就可能是随机的了，位图扫描就能解决这个问题，它通过位图将地址保存起来，把地址收集起来之后，然后让地址变得有序，这样就通过中间的位图把随机读消解掉了。”大明则继续在纸上画上了位图扫描的示意图。</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/3.png\"> </p>\n<p>不过大明不甘心一直“站在桌子里面”，也想“站到桌子外面”承担一下“逗哏”的角色，于是说道：“扫描的过程中还会结合一些特殊的情况有一些非常高效的扫描路径，比如TID扫描路径，TID实际上是元组在磁盘上的存储地址，我们能够根据TID直接就获得元组，这样查询的效率就非常高了。”</p>\n<p>牛二哥点了点头继续说到：“扫描路径通常是执行计划中的叶子结点，也就是在最底层对表进行扫描的结点，扫描路径就是为连接路径做准备的，扫描出来的数据就可以给连接路径来实现连接操作了。”</p>\n<p>大明一边在纸上画一边说道：“要对两个关系做连接，受笛卡尔积的启发，可以用一个算法复杂度是O(mn)的方法来实现，我们叫它Nestlooped Join方法，这种方法虽然复杂度比较高，但是和顺序扫描一样，胜在具有普适性。”</p>\n<p>牛二哥说：“嵌套循环连接这种方法的复杂度比较高，看上去没什么意义，但是如果Nestlooped Join的内表的路径是一个索引扫描路径，那么算法的复杂度就会降下来，索引扫描的算法复杂度是O(logn)，因此如果Nestlooped Join的内表是一个索引扫描，它的整体的算法复杂度就变成了O(mlogn)，看上去这样也是可以接受的。”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/4.png\"> </p>\n<p>小明点了点头说：“嗯，索引实际上是对数据做了一些预处理，我想如果哈希连接方法就是将内表做一个哈希表，这样也等于将内表的数据做了预处理，也能方便外表的元组在里面探测吧？”</p>\n<p>牛二哥点了点头说：“假设Hash表有N个桶，内表数据均匀的分布在各个桶中，那么Hash Join的时间复杂度就是O(m * n /N)，当然，这里我们没有考虑上建立Hash表的代价。”</p>\n<p>大明则在纸上画出了Hash连接的示意图，并且补充道：“Hash连接通常只能用来做等值判断。”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/5.png\"> </p>\n<p>牛二哥继续说：“如果将两个表先排序，那么就可以引入第三种连接方式，Merge Join，这种连接方式的代价主要浪费在排序上，如果两个关系的数据量都比较小，那么排序的代价是可控的，MergeJoin就是适用的，另外如果关系上有有序的索引，那么就可以不用单独排序了，这样也比较适用于MergeJoin。你看我画的这个归并连接的示意图，外表是需要排序的，而内表则借用了原有的索引的顺序，消除了排序的时间，降低了物理路径的代价。”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-7/6.png\"> </p>\n<p>“这些路径属于SPJ路径，在PostgreSQL的优化器中，通常会先生成SPJ的路径，然后在这基础上再叠加Non-SPJ的路径，比如说聚集操作、排序操作、limit操作、分组操作。。。。”牛二哥继续补充道。</p>\n<p>“咚咚咚，咚咚咚”敲门声响了，吃了吗外卖东来了三个人最爱的大腰子，吃大腰子的感觉完全停不下来，至于优化器。。。先让它见鬼去吧。</p>"},{"title":"PostgreSQL优化器白话(8) - 算计不到就受穷","date":"2020-10-03T00:55:42.000Z","_content":"\n“俗话说啊，吃不穷，穿不穷，算计不到就受穷。”大明一边啃着大腰子，一边说：“所以该吃就得吃，吃是吃不穷的。”\n\t\n小明说：“可是算来算去，物理路径的代价还是有选不准的时候啊。”\n\n牛二哥说：“小明你已经走火入魔了，我们正在美美的吃饭，你看大明啃得竹签子都冒火星子，你非要扯到优化器，太扫兴了，好了，我吃饱了，我来和你聊聊。”说着牛二哥抽了张纸巾擦了擦嘴，纸巾被嘴角的油浸成透明状，飘悠悠的被牛二哥弹进了垃圾筐，然后牛二哥抚摸着自己沟满壕平的肚子，慢条斯理的说：“最优路径选的不准是谁的原因，那就是代价模型不行啊，代价模型不行赖谁，那就是程序员没建好啊，所以要怪就要怪到程序员自己头上。”\n<!-- more -->\n\n小明问道：“可是我看PostgreSQL数据库的代价计算已经很复杂了啊？”\n\n“可是数据库的周边环境更复杂啊。你想想，在实际应用中，数据库用户的配置硬件环境千差万别，CPU的频率、主存的大小和磁盘介质的性质都会影响执行计划在实际执行时的效率。”牛二哥说完，喝了一口红酒。\n\n大明接过来继续说道；“虽然在代价估算的过程中，我们无法获得‘绝对真实’的代价，但是‘绝对真实’的代价也是不必要的，因为我们只是想从多个路径（Path）中找到一个代价最小的路径，只要这些路径的代价是可以‘相互比较’的就可以了，因此可以设定一个‘相对’的代价的单位1，同一个查询中所有的物理路径都基于这个“相对”的单位1来计算的代价，这样计算出来的代价就是可以比较的，也就能用来对路径进行挑选了。”\n\n然后大明给牛二哥递了根中华烟，说：“饭后一根烟，赛过活神仙，来，抽一根。”牛二哥接过烟，大明把火递了过来，牛二哥点上了烟，把打火机扔到茶几上，然后深吸了一口，喷云吐雾的说：“PostgreSQL数据库采用顺序读写一个页面的IO代价作为单位1，而把随机IO定位了顺序IO的4倍”\n\n小明说：“我知道，我知道，这个我查过相关的书，首先，目前的存储介质很大部分仍然是机械硬盘，机械硬盘的磁头在获得数据库的时候需要付出寻道时间，如果要读写的是一串在磁盘上连续的数据，就可以节省寻道时间，提高IO性能，而如果随机读写磁盘上任意扇区的数据，那么会有大量的时间浪费在寻道上。其次，大部分磁盘本身带有缓存，这就形成了主存->磁盘缓存->磁盘的三级结构，在将磁盘的内容加载到内存的时候，考虑到磁盘的IO性能，磁盘会进行数据的预读，把预读到的数据保存在磁盘的缓存中，也就是说如果用户只打算从磁盘读取100个字节的数据，那么磁盘可能会连续的读取磁盘中的512字节（不同的磁盘预读的数量可能不同）并将其保存到磁盘缓存，如果下一次是顺序读取100个字节之后的内容，那么预读的512字节的数据就会发挥作用，性能会大大的增加，而如果读取的内容超出了512字节的范围，那么预读的数据就没有发挥作用，磁盘的IO性能就会下降。”说完小明得意的说：“怎么样，我说的对吧？”\n\n牛二哥说：“你说的对，目前PostgreSQL的查询优化大量的考虑了随机IO和顺序IO所带来的性能差别，在这方面做了不少优化，但是现在的磁盘技术越来越发达了，以后随机IO和顺序IO是不是还差这么多，就值得商榷了。”\n\n“那到底还有那些代价基准单位呢？”小明继续问道。\n\n大明回答道：“基于磁盘IO的代价单位当然就是和Page有关的了，也就是说我们刚才说的顺序IO和随机IO都属于IO方面的基准代价。让后让牛二哥给你介绍一下CPU方面的代价基准单位，我先去吃个鸡。”\n\n牛二哥说：“CPU方面的基准单位有哪些呢？比如说我们通过IO把磁盘页面读到了缓存，但我们要处理的是元组啊，所以还需要把元组从页面里解出来，还要处理元组，这部分主要消耗的是CPU，所以会有一个元组处理的代价基准单位，另外，我们在投影、约束条件里有大量的表达式，这些表达式求解也主要消耗CPU资源，所以还有一个表达式代价的基准单位。”\n\n牛二哥弹了弹烟灰，继续说道：“现在PostgreSQL数据库增加了很多并行路径，因此它也产生了通信代价，这个也需要计算的。”\n\n小明听了之后，说：“那我们就能得到一个这样的公式。”说着在纸上写了一个公式：\n```\n\t\t总代价 = CPU代价 + IO代价 + 通信代价\n```\n\n然后小明继续说：“可是我通过EXPLAIN还查看过PostgreSQL的执行计划，我从执行计划中还看到有启动代价和总代价，这是怎么回事呢？”\n\n牛二哥听了之后，想了想，在纸上写了一个公式：\n\n```\n\t\t总代价 = 启动代价 + 执行代价\n```\n\n然后牛二哥说：“这是从另一个角度来计算代价，启动代价是指从语句开始执行到查询引擎返回第一条元组的代价（另一种说法是准备好去获得第一条元组的代价），总代价是SQL语句从开始执行到结束的所有代价。”\n\t\n“可是。。。为什么要区分启动代价和执行代价呢？”\n\n“这个嘛。。。。”牛二哥思考了一下，觉得一句两句不容易说清楚，于是写了个例子：\n\n```\n\tSELECT * FROM TEST_A WHERE a > 1 ORDER BY a LIMIT 1;\n```\n\n“我们假设这个在TEST_A(a)上有一个B树索引，晓得不，那这个语句可能会形成什么样的执行计划呢？”\n\n小明想了想，觉得空想可能有点困难，于是在纸上画了一起，最终他画了两个执行路径：\n\n```\n\t执行路径1：LIMIT 1\n       \t\t\t\t-> SORT(a)\n                       -> SeqScan WHERE A > 1;\n\t执行路径2：LIMIT 1\n\t\t\t\t\t-> IndexScan WHERE A > 1; \n\t\t\t\t\t（小明注：B树索引有序，不用再排序了）\n```\n\n小明说：“我觉得这两个都可以，不过我觉得第二个更好，因为它节省了排序的时间。”\n\n牛二哥问：“你知道的，PostgreSQL数据库采用动态规划的方法来实现路径的搜索，它是一种自底向上的方法，也就是说会先建立筛选扫描路径，然后用筛选后的扫描路径再去形成连接路径，那么在我们筛选扫描路径的时候，是不知道它的上层有没有LIMIT的，这时候如果单独看SeqScan + SORT和IndexScan你觉得哪个好呢？”\n\n“嗯，我知道陷阱在哪里，大明和我说过，A > 1的选择率高的话会选择顺序扫描，而A > 1的选择率低的情况下，会选择索引扫描，这是因为索引扫描会产生随机IO，也就是说在选择率高的情况下，有可能SeqScan + SORT会优于IndexScan，虽然SeqScan + SORT会有排序，但是IndexScan的随机IO实在是太可观了。”\n\n牛二哥点了点头，说：“对的，假设选择率比较高，这时候选择了SeqScan + SORT，是因为它不知道再上层是LIMIT 1，如果上面是LIMIT 1，就会导致索引扫描不用全部扫完，只要扫一丢丢就可以了，这时候随机IO就很小了，但是SeqScan + SORT就还必须全部执行完才能获取到LIMIT 1，也就是说SeqScan + SORT、或者说SORT要获取第一条元组的启动代价是比较高的，如果上面有LIMIT 1这样的子句，那么启动代价高的路径可能就没有优势了，这就是启动代价的作用。”\n\n小明恍然大悟，说：“SORT要全部做完才能获取第一条元组，它的启动代价大，但是总代价小，而索引扫描呢，因为本身有序，它的启动代价是小的，但是由于有随机IO，所以它的总代价是大的，如果我们只按照总代价进行筛选，就没办法获得最优的代价了。”\n\n“什么什么？启动代价。。。你们进展很快嘛。”这时大明跑过来，说：“让我们想一下晚上吃点什么吧？”\n\n小明：“吃点好的，很有必要。我这脑细胞已经快用没了。”\n","source":"_posts/postgresql-optimizer-outline-8.md","raw":"---\ntitle: PostgreSQL优化器白话(8) - 算计不到就受穷\ndate: 2020-10-03 08:55:42\ntags: 代价 启动代价 IO代价 CPU代价\n---\n\n“俗话说啊，吃不穷，穿不穷，算计不到就受穷。”大明一边啃着大腰子，一边说：“所以该吃就得吃，吃是吃不穷的。”\n\t\n小明说：“可是算来算去，物理路径的代价还是有选不准的时候啊。”\n\n牛二哥说：“小明你已经走火入魔了，我们正在美美的吃饭，你看大明啃得竹签子都冒火星子，你非要扯到优化器，太扫兴了，好了，我吃饱了，我来和你聊聊。”说着牛二哥抽了张纸巾擦了擦嘴，纸巾被嘴角的油浸成透明状，飘悠悠的被牛二哥弹进了垃圾筐，然后牛二哥抚摸着自己沟满壕平的肚子，慢条斯理的说：“最优路径选的不准是谁的原因，那就是代价模型不行啊，代价模型不行赖谁，那就是程序员没建好啊，所以要怪就要怪到程序员自己头上。”\n<!-- more -->\n\n小明问道：“可是我看PostgreSQL数据库的代价计算已经很复杂了啊？”\n\n“可是数据库的周边环境更复杂啊。你想想，在实际应用中，数据库用户的配置硬件环境千差万别，CPU的频率、主存的大小和磁盘介质的性质都会影响执行计划在实际执行时的效率。”牛二哥说完，喝了一口红酒。\n\n大明接过来继续说道；“虽然在代价估算的过程中，我们无法获得‘绝对真实’的代价，但是‘绝对真实’的代价也是不必要的，因为我们只是想从多个路径（Path）中找到一个代价最小的路径，只要这些路径的代价是可以‘相互比较’的就可以了，因此可以设定一个‘相对’的代价的单位1，同一个查询中所有的物理路径都基于这个“相对”的单位1来计算的代价，这样计算出来的代价就是可以比较的，也就能用来对路径进行挑选了。”\n\n然后大明给牛二哥递了根中华烟，说：“饭后一根烟，赛过活神仙，来，抽一根。”牛二哥接过烟，大明把火递了过来，牛二哥点上了烟，把打火机扔到茶几上，然后深吸了一口，喷云吐雾的说：“PostgreSQL数据库采用顺序读写一个页面的IO代价作为单位1，而把随机IO定位了顺序IO的4倍”\n\n小明说：“我知道，我知道，这个我查过相关的书，首先，目前的存储介质很大部分仍然是机械硬盘，机械硬盘的磁头在获得数据库的时候需要付出寻道时间，如果要读写的是一串在磁盘上连续的数据，就可以节省寻道时间，提高IO性能，而如果随机读写磁盘上任意扇区的数据，那么会有大量的时间浪费在寻道上。其次，大部分磁盘本身带有缓存，这就形成了主存->磁盘缓存->磁盘的三级结构，在将磁盘的内容加载到内存的时候，考虑到磁盘的IO性能，磁盘会进行数据的预读，把预读到的数据保存在磁盘的缓存中，也就是说如果用户只打算从磁盘读取100个字节的数据，那么磁盘可能会连续的读取磁盘中的512字节（不同的磁盘预读的数量可能不同）并将其保存到磁盘缓存，如果下一次是顺序读取100个字节之后的内容，那么预读的512字节的数据就会发挥作用，性能会大大的增加，而如果读取的内容超出了512字节的范围，那么预读的数据就没有发挥作用，磁盘的IO性能就会下降。”说完小明得意的说：“怎么样，我说的对吧？”\n\n牛二哥说：“你说的对，目前PostgreSQL的查询优化大量的考虑了随机IO和顺序IO所带来的性能差别，在这方面做了不少优化，但是现在的磁盘技术越来越发达了，以后随机IO和顺序IO是不是还差这么多，就值得商榷了。”\n\n“那到底还有那些代价基准单位呢？”小明继续问道。\n\n大明回答道：“基于磁盘IO的代价单位当然就是和Page有关的了，也就是说我们刚才说的顺序IO和随机IO都属于IO方面的基准代价。让后让牛二哥给你介绍一下CPU方面的代价基准单位，我先去吃个鸡。”\n\n牛二哥说：“CPU方面的基准单位有哪些呢？比如说我们通过IO把磁盘页面读到了缓存，但我们要处理的是元组啊，所以还需要把元组从页面里解出来，还要处理元组，这部分主要消耗的是CPU，所以会有一个元组处理的代价基准单位，另外，我们在投影、约束条件里有大量的表达式，这些表达式求解也主要消耗CPU资源，所以还有一个表达式代价的基准单位。”\n\n牛二哥弹了弹烟灰，继续说道：“现在PostgreSQL数据库增加了很多并行路径，因此它也产生了通信代价，这个也需要计算的。”\n\n小明听了之后，说：“那我们就能得到一个这样的公式。”说着在纸上写了一个公式：\n```\n\t\t总代价 = CPU代价 + IO代价 + 通信代价\n```\n\n然后小明继续说：“可是我通过EXPLAIN还查看过PostgreSQL的执行计划，我从执行计划中还看到有启动代价和总代价，这是怎么回事呢？”\n\n牛二哥听了之后，想了想，在纸上写了一个公式：\n\n```\n\t\t总代价 = 启动代价 + 执行代价\n```\n\n然后牛二哥说：“这是从另一个角度来计算代价，启动代价是指从语句开始执行到查询引擎返回第一条元组的代价（另一种说法是准备好去获得第一条元组的代价），总代价是SQL语句从开始执行到结束的所有代价。”\n\t\n“可是。。。为什么要区分启动代价和执行代价呢？”\n\n“这个嘛。。。。”牛二哥思考了一下，觉得一句两句不容易说清楚，于是写了个例子：\n\n```\n\tSELECT * FROM TEST_A WHERE a > 1 ORDER BY a LIMIT 1;\n```\n\n“我们假设这个在TEST_A(a)上有一个B树索引，晓得不，那这个语句可能会形成什么样的执行计划呢？”\n\n小明想了想，觉得空想可能有点困难，于是在纸上画了一起，最终他画了两个执行路径：\n\n```\n\t执行路径1：LIMIT 1\n       \t\t\t\t-> SORT(a)\n                       -> SeqScan WHERE A > 1;\n\t执行路径2：LIMIT 1\n\t\t\t\t\t-> IndexScan WHERE A > 1; \n\t\t\t\t\t（小明注：B树索引有序，不用再排序了）\n```\n\n小明说：“我觉得这两个都可以，不过我觉得第二个更好，因为它节省了排序的时间。”\n\n牛二哥问：“你知道的，PostgreSQL数据库采用动态规划的方法来实现路径的搜索，它是一种自底向上的方法，也就是说会先建立筛选扫描路径，然后用筛选后的扫描路径再去形成连接路径，那么在我们筛选扫描路径的时候，是不知道它的上层有没有LIMIT的，这时候如果单独看SeqScan + SORT和IndexScan你觉得哪个好呢？”\n\n“嗯，我知道陷阱在哪里，大明和我说过，A > 1的选择率高的话会选择顺序扫描，而A > 1的选择率低的情况下，会选择索引扫描，这是因为索引扫描会产生随机IO，也就是说在选择率高的情况下，有可能SeqScan + SORT会优于IndexScan，虽然SeqScan + SORT会有排序，但是IndexScan的随机IO实在是太可观了。”\n\n牛二哥点了点头，说：“对的，假设选择率比较高，这时候选择了SeqScan + SORT，是因为它不知道再上层是LIMIT 1，如果上面是LIMIT 1，就会导致索引扫描不用全部扫完，只要扫一丢丢就可以了，这时候随机IO就很小了，但是SeqScan + SORT就还必须全部执行完才能获取到LIMIT 1，也就是说SeqScan + SORT、或者说SORT要获取第一条元组的启动代价是比较高的，如果上面有LIMIT 1这样的子句，那么启动代价高的路径可能就没有优势了，这就是启动代价的作用。”\n\n小明恍然大悟，说：“SORT要全部做完才能获取第一条元组，它的启动代价大，但是总代价小，而索引扫描呢，因为本身有序，它的启动代价是小的，但是由于有随机IO，所以它的总代价是大的，如果我们只按照总代价进行筛选，就没办法获得最优的代价了。”\n\n“什么什么？启动代价。。。你们进展很快嘛。”这时大明跑过来，说：“让我们想一下晚上吃点什么吧？”\n\n小明：“吃点好的，很有必要。我这脑细胞已经快用没了。”\n","slug":"postgresql-optimizer-outline-8","published":1,"updated":"2020-10-03T01:01:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfszbzyk0001ro9kakdf920l","content":"<p>“俗话说啊，吃不穷，穿不穷，算计不到就受穷。”大明一边啃着大腰子，一边说：“所以该吃就得吃，吃是吃不穷的。”</p>\n<p>小明说：“可是算来算去，物理路径的代价还是有选不准的时候啊。”</p>\n<p>牛二哥说：“小明你已经走火入魔了，我们正在美美的吃饭，你看大明啃得竹签子都冒火星子，你非要扯到优化器，太扫兴了，好了，我吃饱了，我来和你聊聊。”说着牛二哥抽了张纸巾擦了擦嘴，纸巾被嘴角的油浸成透明状，飘悠悠的被牛二哥弹进了垃圾筐，然后牛二哥抚摸着自己沟满壕平的肚子，慢条斯理的说：“最优路径选的不准是谁的原因，那就是代价模型不行啊，代价模型不行赖谁，那就是程序员没建好啊，所以要怪就要怪到程序员自己头上。”</p>\n<a id=\"more\"></a>\n\n<p>小明问道：“可是我看PostgreSQL数据库的代价计算已经很复杂了啊？”</p>\n<p>“可是数据库的周边环境更复杂啊。你想想，在实际应用中，数据库用户的配置硬件环境千差万别，CPU的频率、主存的大小和磁盘介质的性质都会影响执行计划在实际执行时的效率。”牛二哥说完，喝了一口红酒。</p>\n<p>大明接过来继续说道；“虽然在代价估算的过程中，我们无法获得‘绝对真实’的代价，但是‘绝对真实’的代价也是不必要的，因为我们只是想从多个路径（Path）中找到一个代价最小的路径，只要这些路径的代价是可以‘相互比较’的就可以了，因此可以设定一个‘相对’的代价的单位1，同一个查询中所有的物理路径都基于这个“相对”的单位1来计算的代价，这样计算出来的代价就是可以比较的，也就能用来对路径进行挑选了。”</p>\n<p>然后大明给牛二哥递了根中华烟，说：“饭后一根烟，赛过活神仙，来，抽一根。”牛二哥接过烟，大明把火递了过来，牛二哥点上了烟，把打火机扔到茶几上，然后深吸了一口，喷云吐雾的说：“PostgreSQL数据库采用顺序读写一个页面的IO代价作为单位1，而把随机IO定位了顺序IO的4倍”</p>\n<p>小明说：“我知道，我知道，这个我查过相关的书，首先，目前的存储介质很大部分仍然是机械硬盘，机械硬盘的磁头在获得数据库的时候需要付出寻道时间，如果要读写的是一串在磁盘上连续的数据，就可以节省寻道时间，提高IO性能，而如果随机读写磁盘上任意扇区的数据，那么会有大量的时间浪费在寻道上。其次，大部分磁盘本身带有缓存，这就形成了主存-&gt;磁盘缓存-&gt;磁盘的三级结构，在将磁盘的内容加载到内存的时候，考虑到磁盘的IO性能，磁盘会进行数据的预读，把预读到的数据保存在磁盘的缓存中，也就是说如果用户只打算从磁盘读取100个字节的数据，那么磁盘可能会连续的读取磁盘中的512字节（不同的磁盘预读的数量可能不同）并将其保存到磁盘缓存，如果下一次是顺序读取100个字节之后的内容，那么预读的512字节的数据就会发挥作用，性能会大大的增加，而如果读取的内容超出了512字节的范围，那么预读的数据就没有发挥作用，磁盘的IO性能就会下降。”说完小明得意的说：“怎么样，我说的对吧？”</p>\n<p>牛二哥说：“你说的对，目前PostgreSQL的查询优化大量的考虑了随机IO和顺序IO所带来的性能差别，在这方面做了不少优化，但是现在的磁盘技术越来越发达了，以后随机IO和顺序IO是不是还差这么多，就值得商榷了。”</p>\n<p>“那到底还有那些代价基准单位呢？”小明继续问道。</p>\n<p>大明回答道：“基于磁盘IO的代价单位当然就是和Page有关的了，也就是说我们刚才说的顺序IO和随机IO都属于IO方面的基准代价。让后让牛二哥给你介绍一下CPU方面的代价基准单位，我先去吃个鸡。”</p>\n<p>牛二哥说：“CPU方面的基准单位有哪些呢？比如说我们通过IO把磁盘页面读到了缓存，但我们要处理的是元组啊，所以还需要把元组从页面里解出来，还要处理元组，这部分主要消耗的是CPU，所以会有一个元组处理的代价基准单位，另外，我们在投影、约束条件里有大量的表达式，这些表达式求解也主要消耗CPU资源，所以还有一个表达式代价的基准单位。”</p>\n<p>牛二哥弹了弹烟灰，继续说道：“现在PostgreSQL数据库增加了很多并行路径，因此它也产生了通信代价，这个也需要计算的。”</p>\n<p>小明听了之后，说：“那我们就能得到一个这样的公式。”说着在纸上写了一个公式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">总代价 &#x3D; CPU代价 + IO代价 + 通信代价</span><br></pre></td></tr></table></figure>\n\n<p>然后小明继续说：“可是我通过EXPLAIN还查看过PostgreSQL的执行计划，我从执行计划中还看到有启动代价和总代价，这是怎么回事呢？”</p>\n<p>牛二哥听了之后，想了想，在纸上写了一个公式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">总代价 &#x3D; 启动代价 + 执行代价</span><br></pre></td></tr></table></figure>\n\n<p>然后牛二哥说：“这是从另一个角度来计算代价，启动代价是指从语句开始执行到查询引擎返回第一条元组的代价（另一种说法是准备好去获得第一条元组的代价），总代价是SQL语句从开始执行到结束的所有代价。”</p>\n<p>“可是。。。为什么要区分启动代价和执行代价呢？”</p>\n<p>“这个嘛。。。。”牛二哥思考了一下，觉得一句两句不容易说清楚，于是写了个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM TEST_A WHERE a &gt; 1 ORDER BY a LIMIT 1;</span><br></pre></td></tr></table></figure>\n\n<p>“我们假设这个在TEST_A(a)上有一个B树索引，晓得不，那这个语句可能会形成什么样的执行计划呢？”</p>\n<p>小明想了想，觉得空想可能有点困难，于是在纸上画了一起，最终他画了两个执行路径：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行路径1：LIMIT 1</span><br><span class=\"line\">                      -&gt; SORT(a)</span><br><span class=\"line\">                      -&gt; SeqScan WHERE A &gt; 1;</span><br><span class=\"line\">执行路径2：LIMIT 1</span><br><span class=\"line\">                -&gt; IndexScan WHERE A &gt; 1; </span><br><span class=\"line\">                （小明注：B树索引有序，不用再排序了）</span><br></pre></td></tr></table></figure>\n\n<p>小明说：“我觉得这两个都可以，不过我觉得第二个更好，因为它节省了排序的时间。”</p>\n<p>牛二哥问：“你知道的，PostgreSQL数据库采用动态规划的方法来实现路径的搜索，它是一种自底向上的方法，也就是说会先建立筛选扫描路径，然后用筛选后的扫描路径再去形成连接路径，那么在我们筛选扫描路径的时候，是不知道它的上层有没有LIMIT的，这时候如果单独看SeqScan + SORT和IndexScan你觉得哪个好呢？”</p>\n<p>“嗯，我知道陷阱在哪里，大明和我说过，A &gt; 1的选择率高的话会选择顺序扫描，而A &gt; 1的选择率低的情况下，会选择索引扫描，这是因为索引扫描会产生随机IO，也就是说在选择率高的情况下，有可能SeqScan + SORT会优于IndexScan，虽然SeqScan + SORT会有排序，但是IndexScan的随机IO实在是太可观了。”</p>\n<p>牛二哥点了点头，说：“对的，假设选择率比较高，这时候选择了SeqScan + SORT，是因为它不知道再上层是LIMIT 1，如果上面是LIMIT 1，就会导致索引扫描不用全部扫完，只要扫一丢丢就可以了，这时候随机IO就很小了，但是SeqScan + SORT就还必须全部执行完才能获取到LIMIT 1，也就是说SeqScan + SORT、或者说SORT要获取第一条元组的启动代价是比较高的，如果上面有LIMIT 1这样的子句，那么启动代价高的路径可能就没有优势了，这就是启动代价的作用。”</p>\n<p>小明恍然大悟，说：“SORT要全部做完才能获取第一条元组，它的启动代价大，但是总代价小，而索引扫描呢，因为本身有序，它的启动代价是小的，但是由于有随机IO，所以它的总代价是大的，如果我们只按照总代价进行筛选，就没办法获得最优的代价了。”</p>\n<p>“什么什么？启动代价。。。你们进展很快嘛。”这时大明跑过来，说：“让我们想一下晚上吃点什么吧？”</p>\n<p>小明：“吃点好的，很有必要。我这脑细胞已经快用没了。”</p>\n","site":{"data":{}},"excerpt":"<p>“俗话说啊，吃不穷，穿不穷，算计不到就受穷。”大明一边啃着大腰子，一边说：“所以该吃就得吃，吃是吃不穷的。”</p>\n<p>小明说：“可是算来算去，物理路径的代价还是有选不准的时候啊。”</p>\n<p>牛二哥说：“小明你已经走火入魔了，我们正在美美的吃饭，你看大明啃得竹签子都冒火星子，你非要扯到优化器，太扫兴了，好了，我吃饱了，我来和你聊聊。”说着牛二哥抽了张纸巾擦了擦嘴，纸巾被嘴角的油浸成透明状，飘悠悠的被牛二哥弹进了垃圾筐，然后牛二哥抚摸着自己沟满壕平的肚子，慢条斯理的说：“最优路径选的不准是谁的原因，那就是代价模型不行啊，代价模型不行赖谁，那就是程序员没建好啊，所以要怪就要怪到程序员自己头上。”</p>","more":"<p>小明问道：“可是我看PostgreSQL数据库的代价计算已经很复杂了啊？”</p>\n<p>“可是数据库的周边环境更复杂啊。你想想，在实际应用中，数据库用户的配置硬件环境千差万别，CPU的频率、主存的大小和磁盘介质的性质都会影响执行计划在实际执行时的效率。”牛二哥说完，喝了一口红酒。</p>\n<p>大明接过来继续说道；“虽然在代价估算的过程中，我们无法获得‘绝对真实’的代价，但是‘绝对真实’的代价也是不必要的，因为我们只是想从多个路径（Path）中找到一个代价最小的路径，只要这些路径的代价是可以‘相互比较’的就可以了，因此可以设定一个‘相对’的代价的单位1，同一个查询中所有的物理路径都基于这个“相对”的单位1来计算的代价，这样计算出来的代价就是可以比较的，也就能用来对路径进行挑选了。”</p>\n<p>然后大明给牛二哥递了根中华烟，说：“饭后一根烟，赛过活神仙，来，抽一根。”牛二哥接过烟，大明把火递了过来，牛二哥点上了烟，把打火机扔到茶几上，然后深吸了一口，喷云吐雾的说：“PostgreSQL数据库采用顺序读写一个页面的IO代价作为单位1，而把随机IO定位了顺序IO的4倍”</p>\n<p>小明说：“我知道，我知道，这个我查过相关的书，首先，目前的存储介质很大部分仍然是机械硬盘，机械硬盘的磁头在获得数据库的时候需要付出寻道时间，如果要读写的是一串在磁盘上连续的数据，就可以节省寻道时间，提高IO性能，而如果随机读写磁盘上任意扇区的数据，那么会有大量的时间浪费在寻道上。其次，大部分磁盘本身带有缓存，这就形成了主存-&gt;磁盘缓存-&gt;磁盘的三级结构，在将磁盘的内容加载到内存的时候，考虑到磁盘的IO性能，磁盘会进行数据的预读，把预读到的数据保存在磁盘的缓存中，也就是说如果用户只打算从磁盘读取100个字节的数据，那么磁盘可能会连续的读取磁盘中的512字节（不同的磁盘预读的数量可能不同）并将其保存到磁盘缓存，如果下一次是顺序读取100个字节之后的内容，那么预读的512字节的数据就会发挥作用，性能会大大的增加，而如果读取的内容超出了512字节的范围，那么预读的数据就没有发挥作用，磁盘的IO性能就会下降。”说完小明得意的说：“怎么样，我说的对吧？”</p>\n<p>牛二哥说：“你说的对，目前PostgreSQL的查询优化大量的考虑了随机IO和顺序IO所带来的性能差别，在这方面做了不少优化，但是现在的磁盘技术越来越发达了，以后随机IO和顺序IO是不是还差这么多，就值得商榷了。”</p>\n<p>“那到底还有那些代价基准单位呢？”小明继续问道。</p>\n<p>大明回答道：“基于磁盘IO的代价单位当然就是和Page有关的了，也就是说我们刚才说的顺序IO和随机IO都属于IO方面的基准代价。让后让牛二哥给你介绍一下CPU方面的代价基准单位，我先去吃个鸡。”</p>\n<p>牛二哥说：“CPU方面的基准单位有哪些呢？比如说我们通过IO把磁盘页面读到了缓存，但我们要处理的是元组啊，所以还需要把元组从页面里解出来，还要处理元组，这部分主要消耗的是CPU，所以会有一个元组处理的代价基准单位，另外，我们在投影、约束条件里有大量的表达式，这些表达式求解也主要消耗CPU资源，所以还有一个表达式代价的基准单位。”</p>\n<p>牛二哥弹了弹烟灰，继续说道：“现在PostgreSQL数据库增加了很多并行路径，因此它也产生了通信代价，这个也需要计算的。”</p>\n<p>小明听了之后，说：“那我们就能得到一个这样的公式。”说着在纸上写了一个公式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">总代价 &#x3D; CPU代价 + IO代价 + 通信代价</span><br></pre></td></tr></table></figure>\n\n<p>然后小明继续说：“可是我通过EXPLAIN还查看过PostgreSQL的执行计划，我从执行计划中还看到有启动代价和总代价，这是怎么回事呢？”</p>\n<p>牛二哥听了之后，想了想，在纸上写了一个公式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">总代价 &#x3D; 启动代价 + 执行代价</span><br></pre></td></tr></table></figure>\n\n<p>然后牛二哥说：“这是从另一个角度来计算代价，启动代价是指从语句开始执行到查询引擎返回第一条元组的代价（另一种说法是准备好去获得第一条元组的代价），总代价是SQL语句从开始执行到结束的所有代价。”</p>\n<p>“可是。。。为什么要区分启动代价和执行代价呢？”</p>\n<p>“这个嘛。。。。”牛二哥思考了一下，觉得一句两句不容易说清楚，于是写了个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM TEST_A WHERE a &gt; 1 ORDER BY a LIMIT 1;</span><br></pre></td></tr></table></figure>\n\n<p>“我们假设这个在TEST_A(a)上有一个B树索引，晓得不，那这个语句可能会形成什么样的执行计划呢？”</p>\n<p>小明想了想，觉得空想可能有点困难，于是在纸上画了一起，最终他画了两个执行路径：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行路径1：LIMIT 1</span><br><span class=\"line\">                      -&gt; SORT(a)</span><br><span class=\"line\">                      -&gt; SeqScan WHERE A &gt; 1;</span><br><span class=\"line\">执行路径2：LIMIT 1</span><br><span class=\"line\">                -&gt; IndexScan WHERE A &gt; 1; </span><br><span class=\"line\">                （小明注：B树索引有序，不用再排序了）</span><br></pre></td></tr></table></figure>\n\n<p>小明说：“我觉得这两个都可以，不过我觉得第二个更好，因为它节省了排序的时间。”</p>\n<p>牛二哥问：“你知道的，PostgreSQL数据库采用动态规划的方法来实现路径的搜索，它是一种自底向上的方法，也就是说会先建立筛选扫描路径，然后用筛选后的扫描路径再去形成连接路径，那么在我们筛选扫描路径的时候，是不知道它的上层有没有LIMIT的，这时候如果单独看SeqScan + SORT和IndexScan你觉得哪个好呢？”</p>\n<p>“嗯，我知道陷阱在哪里，大明和我说过，A &gt; 1的选择率高的话会选择顺序扫描，而A &gt; 1的选择率低的情况下，会选择索引扫描，这是因为索引扫描会产生随机IO，也就是说在选择率高的情况下，有可能SeqScan + SORT会优于IndexScan，虽然SeqScan + SORT会有排序，但是IndexScan的随机IO实在是太可观了。”</p>\n<p>牛二哥点了点头，说：“对的，假设选择率比较高，这时候选择了SeqScan + SORT，是因为它不知道再上层是LIMIT 1，如果上面是LIMIT 1，就会导致索引扫描不用全部扫完，只要扫一丢丢就可以了，这时候随机IO就很小了，但是SeqScan + SORT就还必须全部执行完才能获取到LIMIT 1，也就是说SeqScan + SORT、或者说SORT要获取第一条元组的启动代价是比较高的，如果上面有LIMIT 1这样的子句，那么启动代价高的路径可能就没有优势了，这就是启动代价的作用。”</p>\n<p>小明恍然大悟，说：“SORT要全部做完才能获取第一条元组，它的启动代价大，但是总代价小，而索引扫描呢，因为本身有序，它的启动代价是小的，但是由于有随机IO，所以它的总代价是大的，如果我们只按照总代价进行筛选，就没办法获得最优的代价了。”</p>\n<p>“什么什么？启动代价。。。你们进展很快嘛。”这时大明跑过来，说：“让我们想一下晚上吃点什么吧？”</p>\n<p>小明：“吃点好的，很有必要。我这脑细胞已经快用没了。”</p>"},{"title":"PostgreSQL优化器白话(9) - 找饭店","date":"2020-10-03T01:01:40.000Z","_content":"\n\n小明、大明和牛二哥在大坑点评里搜索附近好的饭店，搜来搜去总是感觉不太靠谱，不是卫生有问题，就是味道不够正宗，大明感叹道：“看，这就是蓝海，我们可以创业搞一个AI点评，只能推荐最优的饭店啊，我准确的找到了吃货们的痛点，这里面隐含着很大的商机啊！”\n\n牛二哥瞥了它一眼说：“AI推荐当然好啊，可是要推荐的准才行啊，可是一个人一个口味，你这个需求太‘智能’了，我估计不好弄。”\n\n小明突然想到自己最近在学校的算法课上老师讲过一些求最优解问题的方法，然后说：“我知道，我知道，我最近在算法课上学过一些最优解问题的解决方法，应该可以用得上。”\n\n<!-- more -->\n\n牛二哥叹口气道：“可是这些方法用到优化器里都不一定够用，何况用到一个更加智能的项目上呢？”\n\n“嗯？优化器里也用到了最优解问题的方法了吗？我们学过动态规划、贪心算法。。。”小明如数家珍的说起来。\n\n大明说：“用到了啊， 虽然物理路径看上去也不多，但实际上枚举起来，它的搜索空间也不小。例如在扫描路径中，我们就可以有顺序扫描、索引扫描和位图扫描，假如一个表上有多个索引，那么就可能产生多个不同的索引扫描，那么哪个索引扫描路径好呢？而索引扫描和顺序扫描、位图扫描相比，哪个好呢？”\n\n大明看着小明迷离的眼神，停顿了一下，给他足够的思考空间之后继续说道：“数据库路径的搜索方法通常有3种类型：自底向上方法、自顶向下方法、随机方法，而PostgreSQL采用了其中的两种方法呢。”\n\n“采用了哪两种方法呢？”牛二哥明知故问道。\n\n“采用了自底向上的方法和随机方法，其中自底向上的方法是采用的动态规划方法，而随机方法采用的是遗传算法。”\n\n“那有谁使用了自顶向下的方法呢？”牛二哥继续“捧哏”道。\n\n“嗯。。。这个嘛，Pivotal公司的开源优化器ORCA用的就是自顶向下的方法。可以让牛二先给你说说怎么样用动态规划方法搜索最优物理路径。”\n\n牛二哥拿出纸来，在纸上画了几个圈，然后说：“这代表4个表，自底向上嘛，所以是从底下向上堆积，这是最底层，我们叫它第一层”。\n\n![](./postgresql-optimizer-outline-9/1.png) \n\n“动态规划方法首先考虑两个表的连接，其中优先考虑有连接关系的表进行连接，两个表的连接可以建立一个新的表，我们把这些新表叫做第二层。”牛二哥通过连线，产生了一些新的“表”。\n\n![](./postgresql-optimizer-outline-9/2.png) \n\n“第二层的表和第一层的表再连接，可以生成基于3个表连接的新的‘表’，这样就又向前推进了一层，我们产生了第三层”\n\n![](./postgresql-optimizer-outline-9/3.png) \n \n“然后再用第三层的表和第一层的表进行连接，最终生成整个问题的最优路径。”\n\n![](./postgresql-optimizer-outline-9/4.png) \n \n“可是，这不就是穷举吗？”小明问道。\n\n牛二哥解释说：“动态规划有两个特点，一个是要重复的利用子问题的解，这样能减少计算量，降低复杂度，另外一点就是通过子问题的最优解能够构造出最终的最优解，也就是说需要具有最优子结构的性质，所以动态规划的复杂度和穷举是不一样的。”\n\n大明继续解释说：“还有，虽然你看图里的连线比较多，但在实际情况里，并不是所有的圈圈之间都能产生连线，连接关系也有个合法性的问题嘛，所以复杂度是可以控制住的。”\n\n小明感觉好像明白了一点，然后赶紧追问：“那遗传算法呢？”\n\n大明说：“虽然动态规划的复杂度是可以控制的，但是如果表比较多，它的搜索空间还是很大，所以如果在表比较多的时候，可以尝试使遗传算法，这个算法获得的不一定是全局最优解，它获得的可能是局部最优解。”\n\n“那遗传算法是怎么实现物理路径搜索的呢？”小明问。\n\n牛二哥去大明的书柜里找到了一本算法的书，恰好里面有遗传算法的介绍，于是朗读了起来：“遗传算法的实现步骤如下：1）种群初始化：对基因进行编码，并通过对基因进行随机的排列组合，生成多个染色体，这些染色体构成一个新的种群，另外，在生成染色体的过程中同时计算染色体的适应度；2）选择染色体：通过随机选择（实际上通过基于概率的随机数生成算法，这样能倾向于选择出优秀的染色体），选择出用于交叉和变异的染色体；3）交叉操作：染色体进行交叉，产生新的染色体并加入到种群；4）变异操作：对染色体进行变异操作，产生新的染色体并加入到种群；5）适应度计算：对不良的染色体进行淘汰。”\n\n大明笑着说：“尽信书不如无书，我来说一下遗传算法是如何解决货郎问题的。我们可以将城市作为基因，走遍各个城市的路径作为染色体，路径的总长度作为适应度，适应度函数负责筛选掉比较长的路径，保留较短的路径，算法的步骤如下：1）对各个城市进行编号，将各个城市根据编号进行排列组合，生成多条新的路径（染色体），然后根据各城市间的距离计算整体路径长度（适应度），多条新路径构成一个种群；2）选择两个路径进行交叉（需要注意交叉生成新染色体中不能重复出现同一个城市），对交叉操作产生的新路径计算路径长度；3）随机选择染色体进行变异（通常方法是交换城市在路径中的位置），对变异操作后的新路径计算路径长度；4）对种群中所有路径进行基于路径长度有小到大排序，淘汰掉排名靠后的路径。”大明一口气说完了整个流程，长出了一口气，然后继续说：“怎么样，是不是so easy?”\n\n小明想了想牛二哥和大明说的流程，然后说，“我来猜想一下PostgreSQL是如何实现遗传算法的，PostgreSQL应该是模拟了解决货郎问题的方法，它将表作为基因、最终生成的执行计划作为染色体、执行计划的总代价作为适应度，适应度函数则是基于路径的代价进行筛选，对不对？”\n\n牛二哥赞叹道：“说得非常好，不过需 PostgreSQL数据库的基因算法实现方式和通常的遗传算法略有不同在于其没有变异的过程，只通过交叉产生新的染色体，不过这都不是重点了。”\n\n大明说：“哎哎哎，我们不是在搜索饭店吗，怎么搜索起来最优路径了？不要再说优化器了，再晚点饭都没得吃了。”\n于是三个人又热火朝天的搜起饭店来了。\n\n\n","source":"_posts/postgresql-optimizer-outline-9.md","raw":"---\ntitle: PostgreSQL优化器白话(9) - 找饭店\ndate: 2020-10-03 09:01:40\ntags: 动态规划 自底向上 自顶向下\n---\n\n\n小明、大明和牛二哥在大坑点评里搜索附近好的饭店，搜来搜去总是感觉不太靠谱，不是卫生有问题，就是味道不够正宗，大明感叹道：“看，这就是蓝海，我们可以创业搞一个AI点评，只能推荐最优的饭店啊，我准确的找到了吃货们的痛点，这里面隐含着很大的商机啊！”\n\n牛二哥瞥了它一眼说：“AI推荐当然好啊，可是要推荐的准才行啊，可是一个人一个口味，你这个需求太‘智能’了，我估计不好弄。”\n\n小明突然想到自己最近在学校的算法课上老师讲过一些求最优解问题的方法，然后说：“我知道，我知道，我最近在算法课上学过一些最优解问题的解决方法，应该可以用得上。”\n\n<!-- more -->\n\n牛二哥叹口气道：“可是这些方法用到优化器里都不一定够用，何况用到一个更加智能的项目上呢？”\n\n“嗯？优化器里也用到了最优解问题的方法了吗？我们学过动态规划、贪心算法。。。”小明如数家珍的说起来。\n\n大明说：“用到了啊， 虽然物理路径看上去也不多，但实际上枚举起来，它的搜索空间也不小。例如在扫描路径中，我们就可以有顺序扫描、索引扫描和位图扫描，假如一个表上有多个索引，那么就可能产生多个不同的索引扫描，那么哪个索引扫描路径好呢？而索引扫描和顺序扫描、位图扫描相比，哪个好呢？”\n\n大明看着小明迷离的眼神，停顿了一下，给他足够的思考空间之后继续说道：“数据库路径的搜索方法通常有3种类型：自底向上方法、自顶向下方法、随机方法，而PostgreSQL采用了其中的两种方法呢。”\n\n“采用了哪两种方法呢？”牛二哥明知故问道。\n\n“采用了自底向上的方法和随机方法，其中自底向上的方法是采用的动态规划方法，而随机方法采用的是遗传算法。”\n\n“那有谁使用了自顶向下的方法呢？”牛二哥继续“捧哏”道。\n\n“嗯。。。这个嘛，Pivotal公司的开源优化器ORCA用的就是自顶向下的方法。可以让牛二先给你说说怎么样用动态规划方法搜索最优物理路径。”\n\n牛二哥拿出纸来，在纸上画了几个圈，然后说：“这代表4个表，自底向上嘛，所以是从底下向上堆积，这是最底层，我们叫它第一层”。\n\n![](./postgresql-optimizer-outline-9/1.png) \n\n“动态规划方法首先考虑两个表的连接，其中优先考虑有连接关系的表进行连接，两个表的连接可以建立一个新的表，我们把这些新表叫做第二层。”牛二哥通过连线，产生了一些新的“表”。\n\n![](./postgresql-optimizer-outline-9/2.png) \n\n“第二层的表和第一层的表再连接，可以生成基于3个表连接的新的‘表’，这样就又向前推进了一层，我们产生了第三层”\n\n![](./postgresql-optimizer-outline-9/3.png) \n \n“然后再用第三层的表和第一层的表进行连接，最终生成整个问题的最优路径。”\n\n![](./postgresql-optimizer-outline-9/4.png) \n \n“可是，这不就是穷举吗？”小明问道。\n\n牛二哥解释说：“动态规划有两个特点，一个是要重复的利用子问题的解，这样能减少计算量，降低复杂度，另外一点就是通过子问题的最优解能够构造出最终的最优解，也就是说需要具有最优子结构的性质，所以动态规划的复杂度和穷举是不一样的。”\n\n大明继续解释说：“还有，虽然你看图里的连线比较多，但在实际情况里，并不是所有的圈圈之间都能产生连线，连接关系也有个合法性的问题嘛，所以复杂度是可以控制住的。”\n\n小明感觉好像明白了一点，然后赶紧追问：“那遗传算法呢？”\n\n大明说：“虽然动态规划的复杂度是可以控制的，但是如果表比较多，它的搜索空间还是很大，所以如果在表比较多的时候，可以尝试使遗传算法，这个算法获得的不一定是全局最优解，它获得的可能是局部最优解。”\n\n“那遗传算法是怎么实现物理路径搜索的呢？”小明问。\n\n牛二哥去大明的书柜里找到了一本算法的书，恰好里面有遗传算法的介绍，于是朗读了起来：“遗传算法的实现步骤如下：1）种群初始化：对基因进行编码，并通过对基因进行随机的排列组合，生成多个染色体，这些染色体构成一个新的种群，另外，在生成染色体的过程中同时计算染色体的适应度；2）选择染色体：通过随机选择（实际上通过基于概率的随机数生成算法，这样能倾向于选择出优秀的染色体），选择出用于交叉和变异的染色体；3）交叉操作：染色体进行交叉，产生新的染色体并加入到种群；4）变异操作：对染色体进行变异操作，产生新的染色体并加入到种群；5）适应度计算：对不良的染色体进行淘汰。”\n\n大明笑着说：“尽信书不如无书，我来说一下遗传算法是如何解决货郎问题的。我们可以将城市作为基因，走遍各个城市的路径作为染色体，路径的总长度作为适应度，适应度函数负责筛选掉比较长的路径，保留较短的路径，算法的步骤如下：1）对各个城市进行编号，将各个城市根据编号进行排列组合，生成多条新的路径（染色体），然后根据各城市间的距离计算整体路径长度（适应度），多条新路径构成一个种群；2）选择两个路径进行交叉（需要注意交叉生成新染色体中不能重复出现同一个城市），对交叉操作产生的新路径计算路径长度；3）随机选择染色体进行变异（通常方法是交换城市在路径中的位置），对变异操作后的新路径计算路径长度；4）对种群中所有路径进行基于路径长度有小到大排序，淘汰掉排名靠后的路径。”大明一口气说完了整个流程，长出了一口气，然后继续说：“怎么样，是不是so easy?”\n\n小明想了想牛二哥和大明说的流程，然后说，“我来猜想一下PostgreSQL是如何实现遗传算法的，PostgreSQL应该是模拟了解决货郎问题的方法，它将表作为基因、最终生成的执行计划作为染色体、执行计划的总代价作为适应度，适应度函数则是基于路径的代价进行筛选，对不对？”\n\n牛二哥赞叹道：“说得非常好，不过需 PostgreSQL数据库的基因算法实现方式和通常的遗传算法略有不同在于其没有变异的过程，只通过交叉产生新的染色体，不过这都不是重点了。”\n\n大明说：“哎哎哎，我们不是在搜索饭店吗，怎么搜索起来最优路径了？不要再说优化器了，再晚点饭都没得吃了。”\n于是三个人又热火朝天的搜起饭店来了。\n\n\n","slug":"postgresql-optimizer-outline-9","published":1,"updated":"2020-10-03T01:13:29.000Z","_id":"ckfszbzyo0003ro9k3ejk08ql","comments":1,"layout":"post","photos":[],"link":"","content":"<p>小明、大明和牛二哥在大坑点评里搜索附近好的饭店，搜来搜去总是感觉不太靠谱，不是卫生有问题，就是味道不够正宗，大明感叹道：“看，这就是蓝海，我们可以创业搞一个AI点评，只能推荐最优的饭店啊，我准确的找到了吃货们的痛点，这里面隐含着很大的商机啊！”</p>\n<p>牛二哥瞥了它一眼说：“AI推荐当然好啊，可是要推荐的准才行啊，可是一个人一个口味，你这个需求太‘智能’了，我估计不好弄。”</p>\n<p>小明突然想到自己最近在学校的算法课上老师讲过一些求最优解问题的方法，然后说：“我知道，我知道，我最近在算法课上学过一些最优解问题的解决方法，应该可以用得上。”</p>\n<a id=\"more\"></a>\n\n<p>牛二哥叹口气道：“可是这些方法用到优化器里都不一定够用，何况用到一个更加智能的项目上呢？”</p>\n<p>“嗯？优化器里也用到了最优解问题的方法了吗？我们学过动态规划、贪心算法。。。”小明如数家珍的说起来。</p>\n<p>大明说：“用到了啊， 虽然物理路径看上去也不多，但实际上枚举起来，它的搜索空间也不小。例如在扫描路径中，我们就可以有顺序扫描、索引扫描和位图扫描，假如一个表上有多个索引，那么就可能产生多个不同的索引扫描，那么哪个索引扫描路径好呢？而索引扫描和顺序扫描、位图扫描相比，哪个好呢？”</p>\n<p>大明看着小明迷离的眼神，停顿了一下，给他足够的思考空间之后继续说道：“数据库路径的搜索方法通常有3种类型：自底向上方法、自顶向下方法、随机方法，而PostgreSQL采用了其中的两种方法呢。”</p>\n<p>“采用了哪两种方法呢？”牛二哥明知故问道。</p>\n<p>“采用了自底向上的方法和随机方法，其中自底向上的方法是采用的动态规划方法，而随机方法采用的是遗传算法。”</p>\n<p>“那有谁使用了自顶向下的方法呢？”牛二哥继续“捧哏”道。</p>\n<p>“嗯。。。这个嘛，Pivotal公司的开源优化器ORCA用的就是自顶向下的方法。可以让牛二先给你说说怎么样用动态规划方法搜索最优物理路径。”</p>\n<p>牛二哥拿出纸来，在纸上画了几个圈，然后说：“这代表4个表，自底向上嘛，所以是从底下向上堆积，这是最底层，我们叫它第一层”。</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-9/1.png\"> </p>\n<p>“动态规划方法首先考虑两个表的连接，其中优先考虑有连接关系的表进行连接，两个表的连接可以建立一个新的表，我们把这些新表叫做第二层。”牛二哥通过连线，产生了一些新的“表”。</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-9/2.png\"> </p>\n<p>“第二层的表和第一层的表再连接，可以生成基于3个表连接的新的‘表’，这样就又向前推进了一层，我们产生了第三层”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-9/3.png\"> </p>\n<p>“然后再用第三层的表和第一层的表进行连接，最终生成整个问题的最优路径。”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-9/4.png\"> </p>\n<p>“可是，这不就是穷举吗？”小明问道。</p>\n<p>牛二哥解释说：“动态规划有两个特点，一个是要重复的利用子问题的解，这样能减少计算量，降低复杂度，另外一点就是通过子问题的最优解能够构造出最终的最优解，也就是说需要具有最优子结构的性质，所以动态规划的复杂度和穷举是不一样的。”</p>\n<p>大明继续解释说：“还有，虽然你看图里的连线比较多，但在实际情况里，并不是所有的圈圈之间都能产生连线，连接关系也有个合法性的问题嘛，所以复杂度是可以控制住的。”</p>\n<p>小明感觉好像明白了一点，然后赶紧追问：“那遗传算法呢？”</p>\n<p>大明说：“虽然动态规划的复杂度是可以控制的，但是如果表比较多，它的搜索空间还是很大，所以如果在表比较多的时候，可以尝试使遗传算法，这个算法获得的不一定是全局最优解，它获得的可能是局部最优解。”</p>\n<p>“那遗传算法是怎么实现物理路径搜索的呢？”小明问。</p>\n<p>牛二哥去大明的书柜里找到了一本算法的书，恰好里面有遗传算法的介绍，于是朗读了起来：“遗传算法的实现步骤如下：1）种群初始化：对基因进行编码，并通过对基因进行随机的排列组合，生成多个染色体，这些染色体构成一个新的种群，另外，在生成染色体的过程中同时计算染色体的适应度；2）选择染色体：通过随机选择（实际上通过基于概率的随机数生成算法，这样能倾向于选择出优秀的染色体），选择出用于交叉和变异的染色体；3）交叉操作：染色体进行交叉，产生新的染色体并加入到种群；4）变异操作：对染色体进行变异操作，产生新的染色体并加入到种群；5）适应度计算：对不良的染色体进行淘汰。”</p>\n<p>大明笑着说：“尽信书不如无书，我来说一下遗传算法是如何解决货郎问题的。我们可以将城市作为基因，走遍各个城市的路径作为染色体，路径的总长度作为适应度，适应度函数负责筛选掉比较长的路径，保留较短的路径，算法的步骤如下：1）对各个城市进行编号，将各个城市根据编号进行排列组合，生成多条新的路径（染色体），然后根据各城市间的距离计算整体路径长度（适应度），多条新路径构成一个种群；2）选择两个路径进行交叉（需要注意交叉生成新染色体中不能重复出现同一个城市），对交叉操作产生的新路径计算路径长度；3）随机选择染色体进行变异（通常方法是交换城市在路径中的位置），对变异操作后的新路径计算路径长度；4）对种群中所有路径进行基于路径长度有小到大排序，淘汰掉排名靠后的路径。”大明一口气说完了整个流程，长出了一口气，然后继续说：“怎么样，是不是so easy?”</p>\n<p>小明想了想牛二哥和大明说的流程，然后说，“我来猜想一下PostgreSQL是如何实现遗传算法的，PostgreSQL应该是模拟了解决货郎问题的方法，它将表作为基因、最终生成的执行计划作为染色体、执行计划的总代价作为适应度，适应度函数则是基于路径的代价进行筛选，对不对？”</p>\n<p>牛二哥赞叹道：“说得非常好，不过需 PostgreSQL数据库的基因算法实现方式和通常的遗传算法略有不同在于其没有变异的过程，只通过交叉产生新的染色体，不过这都不是重点了。”</p>\n<p>大明说：“哎哎哎，我们不是在搜索饭店吗，怎么搜索起来最优路径了？不要再说优化器了，再晚点饭都没得吃了。”<br>于是三个人又热火朝天的搜起饭店来了。</p>\n","site":{"data":{}},"excerpt":"<p>小明、大明和牛二哥在大坑点评里搜索附近好的饭店，搜来搜去总是感觉不太靠谱，不是卫生有问题，就是味道不够正宗，大明感叹道：“看，这就是蓝海，我们可以创业搞一个AI点评，只能推荐最优的饭店啊，我准确的找到了吃货们的痛点，这里面隐含着很大的商机啊！”</p>\n<p>牛二哥瞥了它一眼说：“AI推荐当然好啊，可是要推荐的准才行啊，可是一个人一个口味，你这个需求太‘智能’了，我估计不好弄。”</p>\n<p>小明突然想到自己最近在学校的算法课上老师讲过一些求最优解问题的方法，然后说：“我知道，我知道，我最近在算法课上学过一些最优解问题的解决方法，应该可以用得上。”</p>","more":"<p>牛二哥叹口气道：“可是这些方法用到优化器里都不一定够用，何况用到一个更加智能的项目上呢？”</p>\n<p>“嗯？优化器里也用到了最优解问题的方法了吗？我们学过动态规划、贪心算法。。。”小明如数家珍的说起来。</p>\n<p>大明说：“用到了啊， 虽然物理路径看上去也不多，但实际上枚举起来，它的搜索空间也不小。例如在扫描路径中，我们就可以有顺序扫描、索引扫描和位图扫描，假如一个表上有多个索引，那么就可能产生多个不同的索引扫描，那么哪个索引扫描路径好呢？而索引扫描和顺序扫描、位图扫描相比，哪个好呢？”</p>\n<p>大明看着小明迷离的眼神，停顿了一下，给他足够的思考空间之后继续说道：“数据库路径的搜索方法通常有3种类型：自底向上方法、自顶向下方法、随机方法，而PostgreSQL采用了其中的两种方法呢。”</p>\n<p>“采用了哪两种方法呢？”牛二哥明知故问道。</p>\n<p>“采用了自底向上的方法和随机方法，其中自底向上的方法是采用的动态规划方法，而随机方法采用的是遗传算法。”</p>\n<p>“那有谁使用了自顶向下的方法呢？”牛二哥继续“捧哏”道。</p>\n<p>“嗯。。。这个嘛，Pivotal公司的开源优化器ORCA用的就是自顶向下的方法。可以让牛二先给你说说怎么样用动态规划方法搜索最优物理路径。”</p>\n<p>牛二哥拿出纸来，在纸上画了几个圈，然后说：“这代表4个表，自底向上嘛，所以是从底下向上堆积，这是最底层，我们叫它第一层”。</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-9/1.png\"> </p>\n<p>“动态规划方法首先考虑两个表的连接，其中优先考虑有连接关系的表进行连接，两个表的连接可以建立一个新的表，我们把这些新表叫做第二层。”牛二哥通过连线，产生了一些新的“表”。</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-9/2.png\"> </p>\n<p>“第二层的表和第一层的表再连接，可以生成基于3个表连接的新的‘表’，这样就又向前推进了一层，我们产生了第三层”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-9/3.png\"> </p>\n<p>“然后再用第三层的表和第一层的表进行连接，最终生成整个问题的最优路径。”</p>\n<p><img src=\"/2020/10/03/postgresql-optimizer-outline-9/4.png\"> </p>\n<p>“可是，这不就是穷举吗？”小明问道。</p>\n<p>牛二哥解释说：“动态规划有两个特点，一个是要重复的利用子问题的解，这样能减少计算量，降低复杂度，另外一点就是通过子问题的最优解能够构造出最终的最优解，也就是说需要具有最优子结构的性质，所以动态规划的复杂度和穷举是不一样的。”</p>\n<p>大明继续解释说：“还有，虽然你看图里的连线比较多，但在实际情况里，并不是所有的圈圈之间都能产生连线，连接关系也有个合法性的问题嘛，所以复杂度是可以控制住的。”</p>\n<p>小明感觉好像明白了一点，然后赶紧追问：“那遗传算法呢？”</p>\n<p>大明说：“虽然动态规划的复杂度是可以控制的，但是如果表比较多，它的搜索空间还是很大，所以如果在表比较多的时候，可以尝试使遗传算法，这个算法获得的不一定是全局最优解，它获得的可能是局部最优解。”</p>\n<p>“那遗传算法是怎么实现物理路径搜索的呢？”小明问。</p>\n<p>牛二哥去大明的书柜里找到了一本算法的书，恰好里面有遗传算法的介绍，于是朗读了起来：“遗传算法的实现步骤如下：1）种群初始化：对基因进行编码，并通过对基因进行随机的排列组合，生成多个染色体，这些染色体构成一个新的种群，另外，在生成染色体的过程中同时计算染色体的适应度；2）选择染色体：通过随机选择（实际上通过基于概率的随机数生成算法，这样能倾向于选择出优秀的染色体），选择出用于交叉和变异的染色体；3）交叉操作：染色体进行交叉，产生新的染色体并加入到种群；4）变异操作：对染色体进行变异操作，产生新的染色体并加入到种群；5）适应度计算：对不良的染色体进行淘汰。”</p>\n<p>大明笑着说：“尽信书不如无书，我来说一下遗传算法是如何解决货郎问题的。我们可以将城市作为基因，走遍各个城市的路径作为染色体，路径的总长度作为适应度，适应度函数负责筛选掉比较长的路径，保留较短的路径，算法的步骤如下：1）对各个城市进行编号，将各个城市根据编号进行排列组合，生成多条新的路径（染色体），然后根据各城市间的距离计算整体路径长度（适应度），多条新路径构成一个种群；2）选择两个路径进行交叉（需要注意交叉生成新染色体中不能重复出现同一个城市），对交叉操作产生的新路径计算路径长度；3）随机选择染色体进行变异（通常方法是交换城市在路径中的位置），对变异操作后的新路径计算路径长度；4）对种群中所有路径进行基于路径长度有小到大排序，淘汰掉排名靠后的路径。”大明一口气说完了整个流程，长出了一口气，然后继续说：“怎么样，是不是so easy?”</p>\n<p>小明想了想牛二哥和大明说的流程，然后说，“我来猜想一下PostgreSQL是如何实现遗传算法的，PostgreSQL应该是模拟了解决货郎问题的方法，它将表作为基因、最终生成的执行计划作为染色体、执行计划的总代价作为适应度，适应度函数则是基于路径的代价进行筛选，对不对？”</p>\n<p>牛二哥赞叹道：“说得非常好，不过需 PostgreSQL数据库的基因算法实现方式和通常的遗传算法略有不同在于其没有变异的过程，只通过交叉产生新的染色体，不过这都不是重点了。”</p>\n<p>大明说：“哎哎哎，我们不是在搜索饭店吗，怎么搜索起来最优路径了？不要再说优化器了，再晚点饭都没得吃了。”<br>于是三个人又热火朝天的搜起饭店来了。</p>"},{"title":"PostgreSQL优化器白话(10) - 我再补充两句","date":"2020-10-03T01:13:44.000Z","_content":"\n\n**全文目录**\n\n1. {% post_link postgresql-optimizer-outline-1 《PostgreSQL优化器白话》- 为什么优化 %}\n2. {% post_link postgresql-optimizer-outline-2 《PostgreSQL优化器白话》- SQL进化史 %}\n3. {% post_link postgresql-optimizer-outline-3 《PostgreSQL优化器白话》- 提升！提升！ %}\n4. {% post_link postgresql-optimizer-outline-4 《PostgreSQL优化器白话》- 下推！下推！ %}\n5. {% post_link postgresql-optimizer-outline-5 《PostgreSQL优化器白话》- 严格要求自己 %}\n6. {% post_link postgresql-optimizer-outline-6 《PostgreSQL优化器白话》- 统计局旁的泉水 %}\n7. {% post_link postgresql-optimizer-outline-7 《PostgreSQL优化器白话》- 你走你的阳关道 %}\n8. {% post_link postgresql-optimizer-outline-8 《PostgreSQL优化器白话》- 算计不到就受穷 %}\n9. {% post_link postgresql-optimizer-outline-9 《PostgreSQL优化器白话》- 找饭店 %}\n\n《PostgreSQL优化器白话》暂时剧终了，我们基本上涵盖了大部分查询优化的概念，但是由于篇幅比较小，没有把细节说得特别到位，其中有大部分内容是摘抄自《PostgreSQL技术内幕：查询优化深度探索》一书的概念解释的部分，然后以小明、大明和牛二哥进行对话的方式展现出来，对于书中介绍的代码分析的部分以及比较深入的实现细节，由于不太容易通过对话的方式展示，所以在《PostgreSQL优化器白话》中没有涉及到。\n\n我已经尽我所能将这种对话的形式写的具有故事性一些，但是限于作者的语言能力，有些情节的切换上会显得比较生硬，在情节的处理上有时也相对比较单薄了，不过请放心，我即使再努力也写不出来世界名著，所以请不要鄙视我，因为我生气起来连我自己都害怕。","source":"_posts/postgresql-optimizer-outline-10.md","raw":"---\ntitle: PostgreSQL优化器白话(10) - 我再补充两句\ndate: 2020-10-03 09:13:44\ntags:\n---\n\n\n**全文目录**\n\n1. {% post_link postgresql-optimizer-outline-1 《PostgreSQL优化器白话》- 为什么优化 %}\n2. {% post_link postgresql-optimizer-outline-2 《PostgreSQL优化器白话》- SQL进化史 %}\n3. {% post_link postgresql-optimizer-outline-3 《PostgreSQL优化器白话》- 提升！提升！ %}\n4. {% post_link postgresql-optimizer-outline-4 《PostgreSQL优化器白话》- 下推！下推！ %}\n5. {% post_link postgresql-optimizer-outline-5 《PostgreSQL优化器白话》- 严格要求自己 %}\n6. {% post_link postgresql-optimizer-outline-6 《PostgreSQL优化器白话》- 统计局旁的泉水 %}\n7. {% post_link postgresql-optimizer-outline-7 《PostgreSQL优化器白话》- 你走你的阳关道 %}\n8. {% post_link postgresql-optimizer-outline-8 《PostgreSQL优化器白话》- 算计不到就受穷 %}\n9. {% post_link postgresql-optimizer-outline-9 《PostgreSQL优化器白话》- 找饭店 %}\n\n《PostgreSQL优化器白话》暂时剧终了，我们基本上涵盖了大部分查询优化的概念，但是由于篇幅比较小，没有把细节说得特别到位，其中有大部分内容是摘抄自《PostgreSQL技术内幕：查询优化深度探索》一书的概念解释的部分，然后以小明、大明和牛二哥进行对话的方式展现出来，对于书中介绍的代码分析的部分以及比较深入的实现细节，由于不太容易通过对话的方式展示，所以在《PostgreSQL优化器白话》中没有涉及到。\n\n我已经尽我所能将这种对话的形式写的具有故事性一些，但是限于作者的语言能力，有些情节的切换上会显得比较生硬，在情节的处理上有时也相对比较单薄了，不过请放心，我即使再努力也写不出来世界名著，所以请不要鄙视我，因为我生气起来连我自己都害怕。","slug":"postgresql-optimizer-outline-10","published":1,"updated":"2020-10-03T01:29:32.000Z","_id":"ckfszn0xc0000rz9khcerd7qi","comments":1,"layout":"post","photos":[],"link":"","content":"<p><strong>全文目录</strong></p>\n<ol>\n<li><a href=\"/2020/08/02/postgresql-optimizer-outline-1/\" title=\"《PostgreSQL优化器白话》- 为什么优化\">《PostgreSQL优化器白话》- 为什么优化</a></li>\n<li><a href=\"/2020/08/02/postgresql-optimizer-outline-2/\" title=\"《PostgreSQL优化器白话》- SQL进化史\">《PostgreSQL优化器白话》- SQL进化史</a></li>\n<li><a href=\"/2020/08/02/postgresql-optimizer-outline-3/\" title=\"《PostgreSQL优化器白话》- 提升！提升！\">《PostgreSQL优化器白话》- 提升！提升！</a></li>\n<li><a href=\"/2020/08/05/postgresql-optimizer-outline-4/\" title=\"《PostgreSQL优化器白话》- 下推！下推！\">《PostgreSQL优化器白话》- 下推！下推！</a></li>\n<li><a href=\"/2020/08/14/postgresql-optimizer-outline-5/\" title=\"《PostgreSQL优化器白话》- 严格要求自己\">《PostgreSQL优化器白话》- 严格要求自己</a></li>\n<li><a href=\"/2020/10/03/postgresql-optimizer-outline-6/\" title=\"《PostgreSQL优化器白话》- 统计局旁的泉水\">《PostgreSQL优化器白话》- 统计局旁的泉水</a></li>\n<li><a href=\"/2020/10/03/postgresql-optimizer-outline-7/\" title=\"《PostgreSQL优化器白话》- 你走你的阳关道\">《PostgreSQL优化器白话》- 你走你的阳关道</a></li>\n<li><a href=\"/2020/10/03/postgresql-optimizer-outline-8/\" title=\"《PostgreSQL优化器白话》- 算计不到就受穷\">《PostgreSQL优化器白话》- 算计不到就受穷</a></li>\n<li><a href=\"/2020/10/03/postgresql-optimizer-outline-9/\" title=\"《PostgreSQL优化器白话》- 找饭店\">《PostgreSQL优化器白话》- 找饭店</a>\n\n</li>\n</ol>\n<p>《PostgreSQL优化器白话》暂时剧终了，我们基本上涵盖了大部分查询优化的概念，但是由于篇幅比较小，没有把细节说得特别到位，其中有大部分内容是摘抄自《PostgreSQL技术内幕：查询优化深度探索》一书的概念解释的部分，然后以小明、大明和牛二哥进行对话的方式展现出来，对于书中介绍的代码分析的部分以及比较深入的实现细节，由于不太容易通过对话的方式展示，所以在《PostgreSQL优化器白话》中没有涉及到。</p>\n<p>我已经尽我所能将这种对话的形式写的具有故事性一些，但是限于作者的语言能力，有些情节的切换上会显得比较生硬，在情节的处理上有时也相对比较单薄了，不过请放心，我即使再努力也写不出来世界名著，所以请不要鄙视我，因为我生气起来连我自己都害怕。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>全文目录</strong></p>\n<ol>\n<li><a href=\"/2020/08/02/postgresql-optimizer-outline-1/\" title=\"《PostgreSQL优化器白话》- 为什么优化\">《PostgreSQL优化器白话》- 为什么优化</a></li>\n<li><a href=\"/2020/08/02/postgresql-optimizer-outline-2/\" title=\"《PostgreSQL优化器白话》- SQL进化史\">《PostgreSQL优化器白话》- SQL进化史</a></li>\n<li><a href=\"/2020/08/02/postgresql-optimizer-outline-3/\" title=\"《PostgreSQL优化器白话》- 提升！提升！\">《PostgreSQL优化器白话》- 提升！提升！</a></li>\n<li><a href=\"/2020/08/05/postgresql-optimizer-outline-4/\" title=\"《PostgreSQL优化器白话》- 下推！下推！\">《PostgreSQL优化器白话》- 下推！下推！</a></li>\n<li><a href=\"/2020/08/14/postgresql-optimizer-outline-5/\" title=\"《PostgreSQL优化器白话》- 严格要求自己\">《PostgreSQL优化器白话》- 严格要求自己</a></li>\n<li><a href=\"/2020/10/03/postgresql-optimizer-outline-6/\" title=\"《PostgreSQL优化器白话》- 统计局旁的泉水\">《PostgreSQL优化器白话》- 统计局旁的泉水</a></li>\n<li><a href=\"/2020/10/03/postgresql-optimizer-outline-7/\" title=\"《PostgreSQL优化器白话》- 你走你的阳关道\">《PostgreSQL优化器白话》- 你走你的阳关道</a></li>\n<li><a href=\"/2020/10/03/postgresql-optimizer-outline-8/\" title=\"《PostgreSQL优化器白话》- 算计不到就受穷\">《PostgreSQL优化器白话》- 算计不到就受穷</a></li>\n<li><a href=\"/2020/10/03/postgresql-optimizer-outline-9/\" title=\"《PostgreSQL优化器白话》- 找饭店\">《PostgreSQL优化器白话》- 找饭店</a>\n\n</li>\n</ol>\n<p>《PostgreSQL优化器白话》暂时剧终了，我们基本上涵盖了大部分查询优化的概念，但是由于篇幅比较小，没有把细节说得特别到位，其中有大部分内容是摘抄自《PostgreSQL技术内幕：查询优化深度探索》一书的概念解释的部分，然后以小明、大明和牛二哥进行对话的方式展现出来，对于书中介绍的代码分析的部分以及比较深入的实现细节，由于不太容易通过对话的方式展示，所以在《PostgreSQL优化器白话》中没有涉及到。</p>\n<p>我已经尽我所能将这种对话的形式写的具有故事性一些，但是限于作者的语言能力，有些情节的切换上会显得比较生硬，在情节的处理上有时也相对比较单薄了，不过请放心，我即使再努力也写不出来世界名著，所以请不要鄙视我，因为我生气起来连我自己都害怕。</p>\n"},{"title":"PostgreSQL中的锁 - 自旋锁","date":"2021-02-06T08:18:10.000Z","_content":"\n经过上次的{% post_link postgresql-optimizer-outline-10 《《PostgreSQL优化器白话》 %}中大明和牛二哥对PostgreSQL优化器的概要的讲解，小明感到自己已经深深的爱上了数据库内核，小明在GitChat网站上购买了《PostgreSQL优化器入门》的文字网课，还跑到实体书店买了本《PostgreSQL技术内幕：查询优化深度探索》，每天对照着网课和书上的内容仔细研读PostgreSQL的优化器的实现，准备在毕业之后去从事数据库内核开发的工作。\n\n不过，最近在学校的数据库原理课程学到了并发控制的部分，这部分对小明来说有点难度，因为小明没有对数据库的原理进行过实践，无法理解锁的重要性，于是小明又来到自己的哥哥大明家里向大明请教PostgreSQL是如何实现并发控制的。\n<!-- more -->\n\n大明说：“并发控制的部分比较繁杂，我们今天主要关注PostgreSQL锁的实现，不过我们先从最底层的部分开始，先来看一看PostgreSQL是如何实现一个自旋锁的，你知道自旋锁吗？”\n\n小明感觉这个概念好像在哪里听过，但又没什么印象，于是小声的说：“不知道。”\n\n大明哈哈一笑，嘲讽道：“这么轻易就说不知道？自信一点！大胆一点！再问你一遍，知道不知道自旋锁？！”\n\n小明感觉受到了很大的鼓舞，于是大声的说：“老子不知道！”\n\n“嗯，很自信嘛。。。来，让朕给你讲讲。PostgreSQL的锁的概念有很多种，比如常见的表锁、行锁、页锁、轻量锁、自旋锁等等，这里面最底层的是实现是自旋锁，它和硬件直接接触，并且屏蔽各种不同硬件和操作系统的细节，通常利用硬件提供的原子操作指令来实现。”\n\n“那为什么要使用这种锁呢？”\n\n“自旋锁是一种互斥锁，它通常是用来保护临界区，这种保护的方式是一种‘不是你死就是我活’的方式，比如说我通过锁获取到这个临界区的访问权限，那么其他人就必须等待，那它怎么等待呢？”\n\n“我知道！”小明抢答道：“如果干等着的话，CPU就不能被充分的利用，所以我知道系统里有一个sleep函数能很好的解决这个问题，如果我们不能获取到锁，那么我们可以睡一会，再来获取锁，我听说sleep函数可以释放CPU资源，这样其他进程或者线程就能充分的利用CPU了，这样CPU即被充分的利用，我也能不停的对锁发出请求，岂不是两全其美。”小明伸了伸衣袖，对大明说：“拿笔来！让我展示一下coding的能力。”\n\n大明给他找了纸和笔，调侃道“看上去很高调嘛。。。”\n\n“我也想低调，但是实力不允许啊！”小明一边说，一边在纸上写出了自己的蓝图：\n\n```\n\twhile(!spinlock_aquire(&lock))\n\t\tsleep(100);\n```\n\n大明接过笔在小明写的代码上画了一个大大的对勾，对小明的行为表示肯定，然后又画了一个X，解释道：“虽然看上去合理，但是这里存在一个问题，有时我们要保护的临界区只有区区几个指令，锁的持有者实际上占有锁的时间是极短的，换句话说锁的请求者实际上不用等太长时间就能获得锁，这时候就需要考虑这个睡眠是不是合适了。”\n\n小明说：“有什么不合适的？不睡眠难道一直占着CPU资源不放，浪费CPU资源？这简直是占着茅坑XXX嘛。”\n\n“对，就是占着茅坑XXX，你说的睡眠模式实际上进行了CPU上下文的切换，但这种切换需要非常多的时钟周期，如果我们要保护的临界区很短，这种切换的代价就显得有点大了，所以释放CPU资源还不如占着好。”\n\n小明想了想，说：“哦，那这种锁有点像一个小朋友遇到了想要的玩具，家长不给买的时候的行为。。。”\n\n大明笑着说：“是的，你小时候就是这样，而且，你在地上打滚的时候从来不休息，一直处于滚动的状态，所以你很小的时候就理解了自旋锁的本质，就是忙等。”\n \n\n\n\n**自旋锁的伪码**\n\n小明继续说：“这样的话，自旋锁的实现就比较容易了，也就是不sleep嘛，我来把它写出来。”说着开始在纸上开始写自旋锁实现的伪码，因为已经了解了自旋锁的基本原理，所以写代码的过程是极为顺利的，小明一边写一边暗暗佩服自己：都是九年义务教育，怎么我就这么优秀呢，像我这样优秀的人，本该灿烂过一生啊。\n\n```\n//让我们假设lock参数是一个线程或进程共享变量\nint spinlock_acquire(int *lock)\n{\n    while(*lock != 0)\n        continue;\n    *lock = 1;\n    return *lock;\n}\n\nint spinlock_release(int *lock)\n{\n    *lock = 0;\n}\n```\n\n大明看着小明洋洋自得的写的这段代码，鄙视到：“你觉得这样就能实现一个自旋锁吗？谬矣。”说着拿笔在小明写的自旋锁上画了一个大大的X，然后一边打开电脑，一边继续说：“让我们看看你错在哪里。”说着啪啪啪的在编译器里敲出了和小明同样逻辑的代码，编译之后，通过代码调试工具查看了spinlock_acquire函数的汇编代码：\n\n```\nspinlock1`spinlock_acquire:\n    0x100000f10 <+0>:  pushq  %rbp\n    0x100000f11 <+1>:  movq   %rsp, %rbp\n    0x100000f14 <+4>:  movq   %rdi, -0x8(%rbp)\n    0x100000f18 <+8>:  movq   -0x8(%rbp), %rax\n    0x100000f1c <+12>: cmpl   $0x0, (%rax)\n    0x100000f1f <+15>: je     0x100000f2a \n    0x100000f25 <+21>: jmp    0x100000f18\n    0x100000f2a <+26>: movq   -0x8(%rbp), %rax\n    0x100000f2e <+30>: movl   $0x1, (%rax)\n    0x100000f34 <+36>: movq   -0x8(%rbp), %rax\n    0x100000f38 <+40>: movl   (%rax), %eax\n    0x100000f3a <+42>: popq   %rbp\n    0x100000f3b <+43>: retq\n    0x100000f3c <+44>: nopl   (%rax)\n```\n\n大明指着屏幕上的汇编代码说：“这段代码是无法作为锁的实现的，因为上面的操作缺乏原子性，比如对lock对应的值是否为0（*lock != 0）的判断就不是一个原子操作，它是通过movq   -0x8(%rbp), %rax和cmpl   $0x0, (%rax)两个指令来实现。假如有两个线程来获取同一个锁，那么会发生什么情况呢？”说着大明在纸上画了一个示意图：\n \n“你看，这时候问题就出现了，线程A和线程B同时觉得当前的lock中的值是0，也就是说他们两个都能获得锁资源，也就出现了两个线程同时获得锁的情况，你觉得这还合理吗？”\n\n小明羞愧的低下了头，怪不得自己二十多年到头来，还在人海里浮沉，原来是因为不懂汇编语言啊。\n\n看着小明羞愧的表情，大明解释道：“C语言的一条语句可能对应几条汇编指令，在执行期间无法保证它的原子性，所以在高级语言的层面需要借助一些算法或者底层的指令来实现临界区的同步功能，如果想通过高级语言的算法来实现临界区的同步功能，也不是补可以，但是需要使用一些比较精妙的算法（比如Peterson算法），这些方法都有很大的局限性，现在已经很少使用这些方法了，今天我们需要关注的是目前的计算机提供的一些硬件指令，通过这些指令，我们可以借助这些指令来实现临界区的同步功能。”\n\n**TAS VS CAS**\n\n\n小明怯怯的问道：“是不是我们学操作系统课程的时候说的那些原子指令？”\n\n“对的，现在大部分硬件都支持两种类型的原子操作指令，比如TAS和CAS指令，下面我们给出他们的伪码。”说着，大明拿了一张新的白纸，边写边说道：“TEST-AND-SET 简称为TAS，它的流程是向内存变量写入1，然后返回内存变量的原值，伪码是这样的。”\n\n```\nint TAS(int *lock)\n{\n    int temp = *lock;\n    *lock = 1;\n    return *lock;\n}\n```\n\n“COMPARE-AND-SWAP简称CAS，它的流程是比较锁中的值和期望值，如果锁中的值和期望值相同，则设置为新值，返回true,否则不设置新值，返回false，它的伪码是这样的。”大明继续写道。\n\n```\nint CAS(int *lock, int expect, int new)\n{\n    if(*lock == expect)\n    {\n        *lock = new;\n        return true;\n    }\n    return false;\n}\n```\n\n大明提示道：“注意，上面的伪码是借用高级语言的形式来描述这两种类型的指令的含义，实际上它是一个完整的原子操作，在X86架构的CPU中，分别提供了XCHG指令和CMPXCHG指令来实现TAS和CAS操作，PostgreSQL在X86架构下采用的是基于XCHG指令的TAS来实现的自旋锁。”\n\n小明兴奋的说：“我已经迫不及待的想看看PostgreSQL是怎么使用TAS指令来实现自旋锁的了。”\n\n大明看着小明手舞足蹈的神态，做了一个calm down的手势，然后说：“稍安勿躁，不要急，再过一会精神病院的救护车就到了。在这之前我们先来谈一下TTAS。”\n\n“TTAS？感觉像是TEST AND TEST-AND-SET？”\n\n“是的，TAS虽然已经足够我们使用，但是也带来一个问题，大部分CPU实现TAS的方法是锁住总线，一旦锁住总线就等于一个CPU占用了整个总线，而频繁的锁住总线会降低CPU的使用效率，所以在进入TAS之前，我们可以先做一个粗略的检测，这个检测不在原子操作之中，但是它可以让我们快速的知道目前锁的状态，如果第一个TEST检测到锁已经被占用了，那么我们就再等一会，就不用进行TAS了，这样就避免了锁住总线，如果第一个TEST发现锁没有被占用，那么就值得去做TAS。”\n\n小明说：“但在第一个TEST和TEST-AND-SET之间，锁的状态可能会被其他CPU上的进程修改掉吧？”\n\n“是的，所以这个TEST只是我们提高性能的一个手段。比如在PostgreSQL数据库中，它就是采用的TTAS的方法。”说着，大明打开了PostgreSQL源代码，找到了TAS实现的部分：\n\n```\nstatic __inline__ int\ntas(volatile slock_t *lock)\n{\n   register slock_t _res = 1;\n\n   __asm__ __volatile__(\n      \"  cmpb   $0,%1  \\n\"\n      \"  jne       1f    \\n\"\n      \"  lock         \\n\"\n      \"  xchgb  %0,%1  \\n\"\n      \"1: \\n\"\n:     \"+q\"(_res), \"+m\"(*lock)\n:\n:     \"memory\", \"cc\");\n   return (int) _res;\n}\n```\n\n大明一边用鼠标在编译器里划住了tas函数，一边说：“从这段汇编代码可以看出，CMP指令和下面的XCHG不能组成一个原子操作，比如一个线程B已经持有了锁，线程A做了CMP指令也发现了有其他线程已经占有了锁资源，于是他就会JNE跳过XCHG指令，但是很可能在CMP指令之后，线程B就立即释放了锁资源。”大明在纸上画了一个示意图：\n\n \n“XCHG指令会尝试交换两个操作数，如果想要获得一个锁，也就是说我们打算在‘锁对应的值是0的情况下把锁的值设置为1’，同时我们还可以用0和1来代表TEST-AND-SET是否成功，那么对上面的汇编代码翻译成高级语言就变成下面这样。”大明开始在纸上写出了对应于PostgreSQL的tas函数的伪码：\n\n```\nstatic __inline__ int\ntas(volatile slock_t lock)\n{\n   register slock_res = 1;\n\n   if(*lock != 1)  //CMP指令\n   {\n      //下面3行是原子操作，对应XCHG\n       int temp = *lock; \nlock = 1;  //同*lock = res;\nres = temp;\n    }\n   return (int) _res;\n}\n```\n\n小明听得云里雾里的，只好说：“感觉听着有点吃力，”\n\n大明笑着说，没关系的：“你可以把这些概念记住，有时间回想一下，好好消化消化。”\n\n小明痛苦的说：“可是你说的这些都是便秘的知识，容易消化不良啊。”\n\n大明说：“不要担心嘛，自旋锁的事才刚刚开始，有了TAS我们才能继续实现PostgreSQL的自旋锁，让我们来看看自旋锁的实现吧。”\n\n**PostgreSQL的自旋锁**\n\n大明继续说道：“在有些CPU架构下，PostgreSQL没有直接使用TTAS，而是先实现了TAS，然后借用TAS_SPIN函数(或者说宏)来实现的自旋锁。”\n\n```\n\t#define TAS_SPIN(lock)  (*(lock) ? 1 : TAS(lock))\n```\n\n“有了TAS_SPIN我们是不是就很容易实现一个自旋锁了呢？”大明问道。\n\n小明想了想说：“让我来写一下，看看这次能不能实现一个可用的自旋锁。”说着小明在纸上写了起来：\n\n```\nvoid spinlock_acquire(int *lock)\n{\n\twhile(TAS_SPIN(lock));\n}\n```\n\n写完之后，小明又推演了几遍，感觉没什么错误了，于是帅气的摇了摇头，说道：“怎么样，是不是很佩服我这样美貌与智慧并重的人？”\n\n“嗯，这个自旋锁是可用的，不过美貌和智慧你都没做到，你做到了病重，精神病院的救护车还没到，我们还有时间继续说自旋锁。”大明调侃道，“我们还能继续优化它。比如适当的偷懒，这种自旋目的是不放弃CPU，但也没必要不停的旋，我们可以用空指令来适当的让CPU歇一会，而不必过度旋转，旋转太频繁了浪费电，我们使用nop指令来进行偷懒”，说着大明在PostgreSQL的源代码中指出了spin_delay函数。\n\n```\n\nstatic __inline__ void\nspin_delay(void)\n{\n   __asm__ __volatile__(\n      \" rep; nop       \\n\");\n}\n```\n\n大明继续说道：“另外，我们也应该处理一些特殊的情况，比如尝试了很多次TAS之后仍然无法获得锁资源，那么就进入sleep，也就是交出CPU资源，需要注意的是睡眠的时间是随机的，但不能超出上下界。”\n\n```\n//第一次sleep的时间，sleep的时间逐步递增，第一次是1000微秒\nif (status->cur_delay == 0) /* first time to delay? */\n   status->cur_delay = MIN_DELAY_USEC;\n\npg_usleep(status->cur_delay);\n```\n\n“当然，如果旋转了很长时间，仍然没有办法获得锁资源，就进入自杀模式，因为我们假设自旋锁保护的临界区都很短，如果很长时间还获取不到锁资源，那么就可能出问题了。”\n\n```\nif (++(status->delays) > NUM_DELAYS)\n   s_lock_stuck(status->file, status->line, status->func);\n```\n\n“这基本上就是PostgreSQL自旋锁的实现了，不过还需要注意我们只谈了X86架构下的实现方法，在不同的CPU架构下，TAS的实现是不同的，比如在MIPS架构下提供的是ll和sc指令，我们要借助这两个指令来实现TAS。”\n\n“明白了，看来我需要学的东西还有很多。”小明沮丧的说。\n\n“不要这么悲观嘛，你不了解这些知识主要是因为你还没有参加工作，还是学生，还在学习的阶段，等你参加工作了，时间长了，也就习惯了。”大明笑着说，“反正债多了不愁，在我们结束之前，再来补充一下自旋锁释放的知识。”\n\n“锁的释放，直接把值设置成0就可以了嘛。”\n\n“bingo！是的，我也是这么认为的，但是还有一个注意事项。”\n\n“什么注意事项，难道这还有什么幺蛾子吗？”小明惊奇道。\n\n“有一个很大的幺蛾子，就是目前很多CPU为了提高执行效率，实现了乱序执行功能，关于乱序执行的具体内容我们就不展开了，以免你不好消化。不过需要记住的是，如果把释放锁写成只是简单设置lock的值，由于乱序执行的作用，有些临界区中的指令可能会在lock释放后才执行，这就相当于两个进（线）程共同进入了临界区，那肯定会出问题，所以我们可以采用内存屏障的方式来保证锁释放的有序性，你看，PostgreSQL的有些锁释放时用的是这种方式。”说着，大明在源代码中标出了一行锁释放的代码：\n\n```\ndo { __memory_barrier(); *(lock) = 0; } while (0)\n```\n   \n“好吧，我记下了，念了这么多年的书，我觉得还是幼儿园适合我。”小明苦着脸说。\n“没事，中午我们去吃点好的，弥补一下你受伤的心灵，我准备一下，咱们马上就出发。”","source":"_posts/postgresql-lock-spinlock-implement.md","raw":"---\ntitle: PostgreSQL中的锁 - 自旋锁\ndate: 2021-02-06 16:18:10\ntags: lock spinlock transaction postgresql\n---\n\n经过上次的{% post_link postgresql-optimizer-outline-10 《《PostgreSQL优化器白话》 %}中大明和牛二哥对PostgreSQL优化器的概要的讲解，小明感到自己已经深深的爱上了数据库内核，小明在GitChat网站上购买了《PostgreSQL优化器入门》的文字网课，还跑到实体书店买了本《PostgreSQL技术内幕：查询优化深度探索》，每天对照着网课和书上的内容仔细研读PostgreSQL的优化器的实现，准备在毕业之后去从事数据库内核开发的工作。\n\n不过，最近在学校的数据库原理课程学到了并发控制的部分，这部分对小明来说有点难度，因为小明没有对数据库的原理进行过实践，无法理解锁的重要性，于是小明又来到自己的哥哥大明家里向大明请教PostgreSQL是如何实现并发控制的。\n<!-- more -->\n\n大明说：“并发控制的部分比较繁杂，我们今天主要关注PostgreSQL锁的实现，不过我们先从最底层的部分开始，先来看一看PostgreSQL是如何实现一个自旋锁的，你知道自旋锁吗？”\n\n小明感觉这个概念好像在哪里听过，但又没什么印象，于是小声的说：“不知道。”\n\n大明哈哈一笑，嘲讽道：“这么轻易就说不知道？自信一点！大胆一点！再问你一遍，知道不知道自旋锁？！”\n\n小明感觉受到了很大的鼓舞，于是大声的说：“老子不知道！”\n\n“嗯，很自信嘛。。。来，让朕给你讲讲。PostgreSQL的锁的概念有很多种，比如常见的表锁、行锁、页锁、轻量锁、自旋锁等等，这里面最底层的是实现是自旋锁，它和硬件直接接触，并且屏蔽各种不同硬件和操作系统的细节，通常利用硬件提供的原子操作指令来实现。”\n\n“那为什么要使用这种锁呢？”\n\n“自旋锁是一种互斥锁，它通常是用来保护临界区，这种保护的方式是一种‘不是你死就是我活’的方式，比如说我通过锁获取到这个临界区的访问权限，那么其他人就必须等待，那它怎么等待呢？”\n\n“我知道！”小明抢答道：“如果干等着的话，CPU就不能被充分的利用，所以我知道系统里有一个sleep函数能很好的解决这个问题，如果我们不能获取到锁，那么我们可以睡一会，再来获取锁，我听说sleep函数可以释放CPU资源，这样其他进程或者线程就能充分的利用CPU了，这样CPU即被充分的利用，我也能不停的对锁发出请求，岂不是两全其美。”小明伸了伸衣袖，对大明说：“拿笔来！让我展示一下coding的能力。”\n\n大明给他找了纸和笔，调侃道“看上去很高调嘛。。。”\n\n“我也想低调，但是实力不允许啊！”小明一边说，一边在纸上写出了自己的蓝图：\n\n```\n\twhile(!spinlock_aquire(&lock))\n\t\tsleep(100);\n```\n\n大明接过笔在小明写的代码上画了一个大大的对勾，对小明的行为表示肯定，然后又画了一个X，解释道：“虽然看上去合理，但是这里存在一个问题，有时我们要保护的临界区只有区区几个指令，锁的持有者实际上占有锁的时间是极短的，换句话说锁的请求者实际上不用等太长时间就能获得锁，这时候就需要考虑这个睡眠是不是合适了。”\n\n小明说：“有什么不合适的？不睡眠难道一直占着CPU资源不放，浪费CPU资源？这简直是占着茅坑XXX嘛。”\n\n“对，就是占着茅坑XXX，你说的睡眠模式实际上进行了CPU上下文的切换，但这种切换需要非常多的时钟周期，如果我们要保护的临界区很短，这种切换的代价就显得有点大了，所以释放CPU资源还不如占着好。”\n\n小明想了想，说：“哦，那这种锁有点像一个小朋友遇到了想要的玩具，家长不给买的时候的行为。。。”\n\n大明笑着说：“是的，你小时候就是这样，而且，你在地上打滚的时候从来不休息，一直处于滚动的状态，所以你很小的时候就理解了自旋锁的本质，就是忙等。”\n \n\n\n\n**自旋锁的伪码**\n\n小明继续说：“这样的话，自旋锁的实现就比较容易了，也就是不sleep嘛，我来把它写出来。”说着开始在纸上开始写自旋锁实现的伪码，因为已经了解了自旋锁的基本原理，所以写代码的过程是极为顺利的，小明一边写一边暗暗佩服自己：都是九年义务教育，怎么我就这么优秀呢，像我这样优秀的人，本该灿烂过一生啊。\n\n```\n//让我们假设lock参数是一个线程或进程共享变量\nint spinlock_acquire(int *lock)\n{\n    while(*lock != 0)\n        continue;\n    *lock = 1;\n    return *lock;\n}\n\nint spinlock_release(int *lock)\n{\n    *lock = 0;\n}\n```\n\n大明看着小明洋洋自得的写的这段代码，鄙视到：“你觉得这样就能实现一个自旋锁吗？谬矣。”说着拿笔在小明写的自旋锁上画了一个大大的X，然后一边打开电脑，一边继续说：“让我们看看你错在哪里。”说着啪啪啪的在编译器里敲出了和小明同样逻辑的代码，编译之后，通过代码调试工具查看了spinlock_acquire函数的汇编代码：\n\n```\nspinlock1`spinlock_acquire:\n    0x100000f10 <+0>:  pushq  %rbp\n    0x100000f11 <+1>:  movq   %rsp, %rbp\n    0x100000f14 <+4>:  movq   %rdi, -0x8(%rbp)\n    0x100000f18 <+8>:  movq   -0x8(%rbp), %rax\n    0x100000f1c <+12>: cmpl   $0x0, (%rax)\n    0x100000f1f <+15>: je     0x100000f2a \n    0x100000f25 <+21>: jmp    0x100000f18\n    0x100000f2a <+26>: movq   -0x8(%rbp), %rax\n    0x100000f2e <+30>: movl   $0x1, (%rax)\n    0x100000f34 <+36>: movq   -0x8(%rbp), %rax\n    0x100000f38 <+40>: movl   (%rax), %eax\n    0x100000f3a <+42>: popq   %rbp\n    0x100000f3b <+43>: retq\n    0x100000f3c <+44>: nopl   (%rax)\n```\n\n大明指着屏幕上的汇编代码说：“这段代码是无法作为锁的实现的，因为上面的操作缺乏原子性，比如对lock对应的值是否为0（*lock != 0）的判断就不是一个原子操作，它是通过movq   -0x8(%rbp), %rax和cmpl   $0x0, (%rax)两个指令来实现。假如有两个线程来获取同一个锁，那么会发生什么情况呢？”说着大明在纸上画了一个示意图：\n \n“你看，这时候问题就出现了，线程A和线程B同时觉得当前的lock中的值是0，也就是说他们两个都能获得锁资源，也就出现了两个线程同时获得锁的情况，你觉得这还合理吗？”\n\n小明羞愧的低下了头，怪不得自己二十多年到头来，还在人海里浮沉，原来是因为不懂汇编语言啊。\n\n看着小明羞愧的表情，大明解释道：“C语言的一条语句可能对应几条汇编指令，在执行期间无法保证它的原子性，所以在高级语言的层面需要借助一些算法或者底层的指令来实现临界区的同步功能，如果想通过高级语言的算法来实现临界区的同步功能，也不是补可以，但是需要使用一些比较精妙的算法（比如Peterson算法），这些方法都有很大的局限性，现在已经很少使用这些方法了，今天我们需要关注的是目前的计算机提供的一些硬件指令，通过这些指令，我们可以借助这些指令来实现临界区的同步功能。”\n\n**TAS VS CAS**\n\n\n小明怯怯的问道：“是不是我们学操作系统课程的时候说的那些原子指令？”\n\n“对的，现在大部分硬件都支持两种类型的原子操作指令，比如TAS和CAS指令，下面我们给出他们的伪码。”说着，大明拿了一张新的白纸，边写边说道：“TEST-AND-SET 简称为TAS，它的流程是向内存变量写入1，然后返回内存变量的原值，伪码是这样的。”\n\n```\nint TAS(int *lock)\n{\n    int temp = *lock;\n    *lock = 1;\n    return *lock;\n}\n```\n\n“COMPARE-AND-SWAP简称CAS，它的流程是比较锁中的值和期望值，如果锁中的值和期望值相同，则设置为新值，返回true,否则不设置新值，返回false，它的伪码是这样的。”大明继续写道。\n\n```\nint CAS(int *lock, int expect, int new)\n{\n    if(*lock == expect)\n    {\n        *lock = new;\n        return true;\n    }\n    return false;\n}\n```\n\n大明提示道：“注意，上面的伪码是借用高级语言的形式来描述这两种类型的指令的含义，实际上它是一个完整的原子操作，在X86架构的CPU中，分别提供了XCHG指令和CMPXCHG指令来实现TAS和CAS操作，PostgreSQL在X86架构下采用的是基于XCHG指令的TAS来实现的自旋锁。”\n\n小明兴奋的说：“我已经迫不及待的想看看PostgreSQL是怎么使用TAS指令来实现自旋锁的了。”\n\n大明看着小明手舞足蹈的神态，做了一个calm down的手势，然后说：“稍安勿躁，不要急，再过一会精神病院的救护车就到了。在这之前我们先来谈一下TTAS。”\n\n“TTAS？感觉像是TEST AND TEST-AND-SET？”\n\n“是的，TAS虽然已经足够我们使用，但是也带来一个问题，大部分CPU实现TAS的方法是锁住总线，一旦锁住总线就等于一个CPU占用了整个总线，而频繁的锁住总线会降低CPU的使用效率，所以在进入TAS之前，我们可以先做一个粗略的检测，这个检测不在原子操作之中，但是它可以让我们快速的知道目前锁的状态，如果第一个TEST检测到锁已经被占用了，那么我们就再等一会，就不用进行TAS了，这样就避免了锁住总线，如果第一个TEST发现锁没有被占用，那么就值得去做TAS。”\n\n小明说：“但在第一个TEST和TEST-AND-SET之间，锁的状态可能会被其他CPU上的进程修改掉吧？”\n\n“是的，所以这个TEST只是我们提高性能的一个手段。比如在PostgreSQL数据库中，它就是采用的TTAS的方法。”说着，大明打开了PostgreSQL源代码，找到了TAS实现的部分：\n\n```\nstatic __inline__ int\ntas(volatile slock_t *lock)\n{\n   register slock_t _res = 1;\n\n   __asm__ __volatile__(\n      \"  cmpb   $0,%1  \\n\"\n      \"  jne       1f    \\n\"\n      \"  lock         \\n\"\n      \"  xchgb  %0,%1  \\n\"\n      \"1: \\n\"\n:     \"+q\"(_res), \"+m\"(*lock)\n:\n:     \"memory\", \"cc\");\n   return (int) _res;\n}\n```\n\n大明一边用鼠标在编译器里划住了tas函数，一边说：“从这段汇编代码可以看出，CMP指令和下面的XCHG不能组成一个原子操作，比如一个线程B已经持有了锁，线程A做了CMP指令也发现了有其他线程已经占有了锁资源，于是他就会JNE跳过XCHG指令，但是很可能在CMP指令之后，线程B就立即释放了锁资源。”大明在纸上画了一个示意图：\n\n \n“XCHG指令会尝试交换两个操作数，如果想要获得一个锁，也就是说我们打算在‘锁对应的值是0的情况下把锁的值设置为1’，同时我们还可以用0和1来代表TEST-AND-SET是否成功，那么对上面的汇编代码翻译成高级语言就变成下面这样。”大明开始在纸上写出了对应于PostgreSQL的tas函数的伪码：\n\n```\nstatic __inline__ int\ntas(volatile slock_t lock)\n{\n   register slock_res = 1;\n\n   if(*lock != 1)  //CMP指令\n   {\n      //下面3行是原子操作，对应XCHG\n       int temp = *lock; \nlock = 1;  //同*lock = res;\nres = temp;\n    }\n   return (int) _res;\n}\n```\n\n小明听得云里雾里的，只好说：“感觉听着有点吃力，”\n\n大明笑着说，没关系的：“你可以把这些概念记住，有时间回想一下，好好消化消化。”\n\n小明痛苦的说：“可是你说的这些都是便秘的知识，容易消化不良啊。”\n\n大明说：“不要担心嘛，自旋锁的事才刚刚开始，有了TAS我们才能继续实现PostgreSQL的自旋锁，让我们来看看自旋锁的实现吧。”\n\n**PostgreSQL的自旋锁**\n\n大明继续说道：“在有些CPU架构下，PostgreSQL没有直接使用TTAS，而是先实现了TAS，然后借用TAS_SPIN函数(或者说宏)来实现的自旋锁。”\n\n```\n\t#define TAS_SPIN(lock)  (*(lock) ? 1 : TAS(lock))\n```\n\n“有了TAS_SPIN我们是不是就很容易实现一个自旋锁了呢？”大明问道。\n\n小明想了想说：“让我来写一下，看看这次能不能实现一个可用的自旋锁。”说着小明在纸上写了起来：\n\n```\nvoid spinlock_acquire(int *lock)\n{\n\twhile(TAS_SPIN(lock));\n}\n```\n\n写完之后，小明又推演了几遍，感觉没什么错误了，于是帅气的摇了摇头，说道：“怎么样，是不是很佩服我这样美貌与智慧并重的人？”\n\n“嗯，这个自旋锁是可用的，不过美貌和智慧你都没做到，你做到了病重，精神病院的救护车还没到，我们还有时间继续说自旋锁。”大明调侃道，“我们还能继续优化它。比如适当的偷懒，这种自旋目的是不放弃CPU，但也没必要不停的旋，我们可以用空指令来适当的让CPU歇一会，而不必过度旋转，旋转太频繁了浪费电，我们使用nop指令来进行偷懒”，说着大明在PostgreSQL的源代码中指出了spin_delay函数。\n\n```\n\nstatic __inline__ void\nspin_delay(void)\n{\n   __asm__ __volatile__(\n      \" rep; nop       \\n\");\n}\n```\n\n大明继续说道：“另外，我们也应该处理一些特殊的情况，比如尝试了很多次TAS之后仍然无法获得锁资源，那么就进入sleep，也就是交出CPU资源，需要注意的是睡眠的时间是随机的，但不能超出上下界。”\n\n```\n//第一次sleep的时间，sleep的时间逐步递增，第一次是1000微秒\nif (status->cur_delay == 0) /* first time to delay? */\n   status->cur_delay = MIN_DELAY_USEC;\n\npg_usleep(status->cur_delay);\n```\n\n“当然，如果旋转了很长时间，仍然没有办法获得锁资源，就进入自杀模式，因为我们假设自旋锁保护的临界区都很短，如果很长时间还获取不到锁资源，那么就可能出问题了。”\n\n```\nif (++(status->delays) > NUM_DELAYS)\n   s_lock_stuck(status->file, status->line, status->func);\n```\n\n“这基本上就是PostgreSQL自旋锁的实现了，不过还需要注意我们只谈了X86架构下的实现方法，在不同的CPU架构下，TAS的实现是不同的，比如在MIPS架构下提供的是ll和sc指令，我们要借助这两个指令来实现TAS。”\n\n“明白了，看来我需要学的东西还有很多。”小明沮丧的说。\n\n“不要这么悲观嘛，你不了解这些知识主要是因为你还没有参加工作，还是学生，还在学习的阶段，等你参加工作了，时间长了，也就习惯了。”大明笑着说，“反正债多了不愁，在我们结束之前，再来补充一下自旋锁释放的知识。”\n\n“锁的释放，直接把值设置成0就可以了嘛。”\n\n“bingo！是的，我也是这么认为的，但是还有一个注意事项。”\n\n“什么注意事项，难道这还有什么幺蛾子吗？”小明惊奇道。\n\n“有一个很大的幺蛾子，就是目前很多CPU为了提高执行效率，实现了乱序执行功能，关于乱序执行的具体内容我们就不展开了，以免你不好消化。不过需要记住的是，如果把释放锁写成只是简单设置lock的值，由于乱序执行的作用，有些临界区中的指令可能会在lock释放后才执行，这就相当于两个进（线）程共同进入了临界区，那肯定会出问题，所以我们可以采用内存屏障的方式来保证锁释放的有序性，你看，PostgreSQL的有些锁释放时用的是这种方式。”说着，大明在源代码中标出了一行锁释放的代码：\n\n```\ndo { __memory_barrier(); *(lock) = 0; } while (0)\n```\n   \n“好吧，我记下了，念了这么多年的书，我觉得还是幼儿园适合我。”小明苦着脸说。\n“没事，中午我们去吃点好的，弥补一下你受伤的心灵，我准备一下，咱们马上就出发。”","slug":"postgresql-lock-spinlock-implement","published":1,"updated":"2021-02-06T08:25:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckktgdw790000nj9k0mucc72m","content":"<p>经过上次的<a href=\"/2020/10/03/postgresql-optimizer-outline-10/\" title=\"《《PostgreSQL优化器白话》\">《《PostgreSQL优化器白话》</a>中大明和牛二哥对PostgreSQL优化器的概要的讲解，小明感到自己已经深深的爱上了数据库内核，小明在GitChat网站上购买了《PostgreSQL优化器入门》的文字网课，还跑到实体书店买了本《PostgreSQL技术内幕：查询优化深度探索》，每天对照着网课和书上的内容仔细研读PostgreSQL的优化器的实现，准备在毕业之后去从事数据库内核开发的工作。</p>\n<p>不过，最近在学校的数据库原理课程学到了并发控制的部分，这部分对小明来说有点难度，因为小明没有对数据库的原理进行过实践，无法理解锁的重要性，于是小明又来到自己的哥哥大明家里向大明请教PostgreSQL是如何实现并发控制的。</p>\n<a id=\"more\"></a>\n\n<p>大明说：“并发控制的部分比较繁杂，我们今天主要关注PostgreSQL锁的实现，不过我们先从最底层的部分开始，先来看一看PostgreSQL是如何实现一个自旋锁的，你知道自旋锁吗？”</p>\n<p>小明感觉这个概念好像在哪里听过，但又没什么印象，于是小声的说：“不知道。”</p>\n<p>大明哈哈一笑，嘲讽道：“这么轻易就说不知道？自信一点！大胆一点！再问你一遍，知道不知道自旋锁？！”</p>\n<p>小明感觉受到了很大的鼓舞，于是大声的说：“老子不知道！”</p>\n<p>“嗯，很自信嘛。。。来，让朕给你讲讲。PostgreSQL的锁的概念有很多种，比如常见的表锁、行锁、页锁、轻量锁、自旋锁等等，这里面最底层的是实现是自旋锁，它和硬件直接接触，并且屏蔽各种不同硬件和操作系统的细节，通常利用硬件提供的原子操作指令来实现。”</p>\n<p>“那为什么要使用这种锁呢？”</p>\n<p>“自旋锁是一种互斥锁，它通常是用来保护临界区，这种保护的方式是一种‘不是你死就是我活’的方式，比如说我通过锁获取到这个临界区的访问权限，那么其他人就必须等待，那它怎么等待呢？”</p>\n<p>“我知道！”小明抢答道：“如果干等着的话，CPU就不能被充分的利用，所以我知道系统里有一个sleep函数能很好的解决这个问题，如果我们不能获取到锁，那么我们可以睡一会，再来获取锁，我听说sleep函数可以释放CPU资源，这样其他进程或者线程就能充分的利用CPU了，这样CPU即被充分的利用，我也能不停的对锁发出请求，岂不是两全其美。”小明伸了伸衣袖，对大明说：“拿笔来！让我展示一下coding的能力。”</p>\n<p>大明给他找了纸和笔，调侃道“看上去很高调嘛。。。”</p>\n<p>“我也想低调，但是实力不允许啊！”小明一边说，一边在纸上写出了自己的蓝图：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(!spinlock_aquire(&amp;lock))</span><br><span class=\"line\">    sleep(100);</span><br></pre></td></tr></table></figure>\n\n<p>大明接过笔在小明写的代码上画了一个大大的对勾，对小明的行为表示肯定，然后又画了一个X，解释道：“虽然看上去合理，但是这里存在一个问题，有时我们要保护的临界区只有区区几个指令，锁的持有者实际上占有锁的时间是极短的，换句话说锁的请求者实际上不用等太长时间就能获得锁，这时候就需要考虑这个睡眠是不是合适了。”</p>\n<p>小明说：“有什么不合适的？不睡眠难道一直占着CPU资源不放，浪费CPU资源？这简直是占着茅坑XXX嘛。”</p>\n<p>“对，就是占着茅坑XXX，你说的睡眠模式实际上进行了CPU上下文的切换，但这种切换需要非常多的时钟周期，如果我们要保护的临界区很短，这种切换的代价就显得有点大了，所以释放CPU资源还不如占着好。”</p>\n<p>小明想了想，说：“哦，那这种锁有点像一个小朋友遇到了想要的玩具，家长不给买的时候的行为。。。”</p>\n<p>大明笑着说：“是的，你小时候就是这样，而且，你在地上打滚的时候从来不休息，一直处于滚动的状态，所以你很小的时候就理解了自旋锁的本质，就是忙等。”</p>\n<p><strong>自旋锁的伪码</strong></p>\n<p>小明继续说：“这样的话，自旋锁的实现就比较容易了，也就是不sleep嘛，我来把它写出来。”说着开始在纸上开始写自旋锁实现的伪码，因为已经了解了自旋锁的基本原理，所以写代码的过程是极为顺利的，小明一边写一边暗暗佩服自己：都是九年义务教育，怎么我就这么优秀呢，像我这样优秀的人，本该灿烂过一生啊。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;让我们假设lock参数是一个线程或进程共享变量</span><br><span class=\"line\">int spinlock_acquire(int *lock)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    while(*lock !&#x3D; 0)</span><br><span class=\"line\">        continue;</span><br><span class=\"line\">    *lock &#x3D; 1;</span><br><span class=\"line\">    return *lock;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int spinlock_release(int *lock)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    *lock &#x3D; 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大明看着小明洋洋自得的写的这段代码，鄙视到：“你觉得这样就能实现一个自旋锁吗？谬矣。”说着拿笔在小明写的自旋锁上画了一个大大的X，然后一边打开电脑，一边继续说：“让我们看看你错在哪里。”说着啪啪啪的在编译器里敲出了和小明同样逻辑的代码，编译之后，通过代码调试工具查看了spinlock_acquire函数的汇编代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spinlock1&#96;spinlock_acquire:</span><br><span class=\"line\">    0x100000f10 &lt;+0&gt;:  pushq  %rbp</span><br><span class=\"line\">    0x100000f11 &lt;+1&gt;:  movq   %rsp, %rbp</span><br><span class=\"line\">    0x100000f14 &lt;+4&gt;:  movq   %rdi, -0x8(%rbp)</span><br><span class=\"line\">    0x100000f18 &lt;+8&gt;:  movq   -0x8(%rbp), %rax</span><br><span class=\"line\">    0x100000f1c &lt;+12&gt;: cmpl   $0x0, (%rax)</span><br><span class=\"line\">    0x100000f1f &lt;+15&gt;: je     0x100000f2a </span><br><span class=\"line\">    0x100000f25 &lt;+21&gt;: jmp    0x100000f18</span><br><span class=\"line\">    0x100000f2a &lt;+26&gt;: movq   -0x8(%rbp), %rax</span><br><span class=\"line\">    0x100000f2e &lt;+30&gt;: movl   $0x1, (%rax)</span><br><span class=\"line\">    0x100000f34 &lt;+36&gt;: movq   -0x8(%rbp), %rax</span><br><span class=\"line\">    0x100000f38 &lt;+40&gt;: movl   (%rax), %eax</span><br><span class=\"line\">    0x100000f3a &lt;+42&gt;: popq   %rbp</span><br><span class=\"line\">    0x100000f3b &lt;+43&gt;: retq</span><br><span class=\"line\">    0x100000f3c &lt;+44&gt;: nopl   (%rax)</span><br></pre></td></tr></table></figure>\n\n<p>大明指着屏幕上的汇编代码说：“这段代码是无法作为锁的实现的，因为上面的操作缺乏原子性，比如对lock对应的值是否为0（*lock != 0）的判断就不是一个原子操作，它是通过movq   -0x8(%rbp), %rax和cmpl   $0x0, (%rax)两个指令来实现。假如有两个线程来获取同一个锁，那么会发生什么情况呢？”说着大明在纸上画了一个示意图：</p>\n<p>“你看，这时候问题就出现了，线程A和线程B同时觉得当前的lock中的值是0，也就是说他们两个都能获得锁资源，也就出现了两个线程同时获得锁的情况，你觉得这还合理吗？”</p>\n<p>小明羞愧的低下了头，怪不得自己二十多年到头来，还在人海里浮沉，原来是因为不懂汇编语言啊。</p>\n<p>看着小明羞愧的表情，大明解释道：“C语言的一条语句可能对应几条汇编指令，在执行期间无法保证它的原子性，所以在高级语言的层面需要借助一些算法或者底层的指令来实现临界区的同步功能，如果想通过高级语言的算法来实现临界区的同步功能，也不是补可以，但是需要使用一些比较精妙的算法（比如Peterson算法），这些方法都有很大的局限性，现在已经很少使用这些方法了，今天我们需要关注的是目前的计算机提供的一些硬件指令，通过这些指令，我们可以借助这些指令来实现临界区的同步功能。”</p>\n<p><strong>TAS VS CAS</strong></p>\n<p>小明怯怯的问道：“是不是我们学操作系统课程的时候说的那些原子指令？”</p>\n<p>“对的，现在大部分硬件都支持两种类型的原子操作指令，比如TAS和CAS指令，下面我们给出他们的伪码。”说着，大明拿了一张新的白纸，边写边说道：“TEST-AND-SET 简称为TAS，它的流程是向内存变量写入1，然后返回内存变量的原值，伪码是这样的。”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int TAS(int *lock)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int temp &#x3D; *lock;</span><br><span class=\"line\">    *lock &#x3D; 1;</span><br><span class=\"line\">    return *lock;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>“COMPARE-AND-SWAP简称CAS，它的流程是比较锁中的值和期望值，如果锁中的值和期望值相同，则设置为新值，返回true,否则不设置新值，返回false，它的伪码是这样的。”大明继续写道。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int CAS(int *lock, int expect, int new)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(*lock &#x3D;&#x3D; expect)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        *lock &#x3D; new;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大明提示道：“注意，上面的伪码是借用高级语言的形式来描述这两种类型的指令的含义，实际上它是一个完整的原子操作，在X86架构的CPU中，分别提供了XCHG指令和CMPXCHG指令来实现TAS和CAS操作，PostgreSQL在X86架构下采用的是基于XCHG指令的TAS来实现的自旋锁。”</p>\n<p>小明兴奋的说：“我已经迫不及待的想看看PostgreSQL是怎么使用TAS指令来实现自旋锁的了。”</p>\n<p>大明看着小明手舞足蹈的神态，做了一个calm down的手势，然后说：“稍安勿躁，不要急，再过一会精神病院的救护车就到了。在这之前我们先来谈一下TTAS。”</p>\n<p>“TTAS？感觉像是TEST AND TEST-AND-SET？”</p>\n<p>“是的，TAS虽然已经足够我们使用，但是也带来一个问题，大部分CPU实现TAS的方法是锁住总线，一旦锁住总线就等于一个CPU占用了整个总线，而频繁的锁住总线会降低CPU的使用效率，所以在进入TAS之前，我们可以先做一个粗略的检测，这个检测不在原子操作之中，但是它可以让我们快速的知道目前锁的状态，如果第一个TEST检测到锁已经被占用了，那么我们就再等一会，就不用进行TAS了，这样就避免了锁住总线，如果第一个TEST发现锁没有被占用，那么就值得去做TAS。”</p>\n<p>小明说：“但在第一个TEST和TEST-AND-SET之间，锁的状态可能会被其他CPU上的进程修改掉吧？”</p>\n<p>“是的，所以这个TEST只是我们提高性能的一个手段。比如在PostgreSQL数据库中，它就是采用的TTAS的方法。”说着，大明打开了PostgreSQL源代码，找到了TAS实现的部分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static __inline__ int</span><br><span class=\"line\">tas(volatile slock_t *lock)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   register slock_t _res &#x3D; 1;</span><br><span class=\"line\"></span><br><span class=\"line\">   __asm__ __volatile__(</span><br><span class=\"line\">      &quot;  cmpb   $0,%1  \\n&quot;</span><br><span class=\"line\">      &quot;  jne       1f    \\n&quot;</span><br><span class=\"line\">      &quot;  lock         \\n&quot;</span><br><span class=\"line\">      &quot;  xchgb  %0,%1  \\n&quot;</span><br><span class=\"line\">      &quot;1: \\n&quot;</span><br><span class=\"line\">:     &quot;+q&quot;(_res), &quot;+m&quot;(*lock)</span><br><span class=\"line\">:</span><br><span class=\"line\">:     &quot;memory&quot;, &quot;cc&quot;);</span><br><span class=\"line\">   return (int) _res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大明一边用鼠标在编译器里划住了tas函数，一边说：“从这段汇编代码可以看出，CMP指令和下面的XCHG不能组成一个原子操作，比如一个线程B已经持有了锁，线程A做了CMP指令也发现了有其他线程已经占有了锁资源，于是他就会JNE跳过XCHG指令，但是很可能在CMP指令之后，线程B就立即释放了锁资源。”大明在纸上画了一个示意图：</p>\n<p>“XCHG指令会尝试交换两个操作数，如果想要获得一个锁，也就是说我们打算在‘锁对应的值是0的情况下把锁的值设置为1’，同时我们还可以用0和1来代表TEST-AND-SET是否成功，那么对上面的汇编代码翻译成高级语言就变成下面这样。”大明开始在纸上写出了对应于PostgreSQL的tas函数的伪码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static __inline__ int</span><br><span class=\"line\">tas(volatile slock_t lock)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   register slock_res &#x3D; 1;</span><br><span class=\"line\"></span><br><span class=\"line\">   if(*lock !&#x3D; 1)  &#x2F;&#x2F;CMP指令</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      &#x2F;&#x2F;下面3行是原子操作，对应XCHG</span><br><span class=\"line\">       int temp &#x3D; *lock; </span><br><span class=\"line\">lock &#x3D; 1;  &#x2F;&#x2F;同*lock &#x3D; res;</span><br><span class=\"line\">res &#x3D; temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   return (int) _res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>小明听得云里雾里的，只好说：“感觉听着有点吃力，”</p>\n<p>大明笑着说，没关系的：“你可以把这些概念记住，有时间回想一下，好好消化消化。”</p>\n<p>小明痛苦的说：“可是你说的这些都是便秘的知识，容易消化不良啊。”</p>\n<p>大明说：“不要担心嘛，自旋锁的事才刚刚开始，有了TAS我们才能继续实现PostgreSQL的自旋锁，让我们来看看自旋锁的实现吧。”</p>\n<p><strong>PostgreSQL的自旋锁</strong></p>\n<p>大明继续说道：“在有些CPU架构下，PostgreSQL没有直接使用TTAS，而是先实现了TAS，然后借用TAS_SPIN函数(或者说宏)来实现的自旋锁。”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define TAS_SPIN(lock)  (*(lock) ? 1 : TAS(lock))</span><br></pre></td></tr></table></figure>\n\n<p>“有了TAS_SPIN我们是不是就很容易实现一个自旋锁了呢？”大明问道。</p>\n<p>小明想了想说：“让我来写一下，看看这次能不能实现一个可用的自旋锁。”说着小明在纸上写了起来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void spinlock_acquire(int *lock)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    while(TAS_SPIN(lock));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>写完之后，小明又推演了几遍，感觉没什么错误了，于是帅气的摇了摇头，说道：“怎么样，是不是很佩服我这样美貌与智慧并重的人？”</p>\n<p>“嗯，这个自旋锁是可用的，不过美貌和智慧你都没做到，你做到了病重，精神病院的救护车还没到，我们还有时间继续说自旋锁。”大明调侃道，“我们还能继续优化它。比如适当的偷懒，这种自旋目的是不放弃CPU，但也没必要不停的旋，我们可以用空指令来适当的让CPU歇一会，而不必过度旋转，旋转太频繁了浪费电，我们使用nop指令来进行偷懒”，说着大明在PostgreSQL的源代码中指出了spin_delay函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">static __inline__ void</span><br><span class=\"line\">spin_delay(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   __asm__ __volatile__(</span><br><span class=\"line\">      &quot; rep; nop       \\n&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大明继续说道：“另外，我们也应该处理一些特殊的情况，比如尝试了很多次TAS之后仍然无法获得锁资源，那么就进入sleep，也就是交出CPU资源，需要注意的是睡眠的时间是随机的，但不能超出上下界。”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;第一次sleep的时间，sleep的时间逐步递增，第一次是1000微秒</span><br><span class=\"line\">if (status-&gt;cur_delay &#x3D;&#x3D; 0) &#x2F;* first time to delay? *&#x2F;</span><br><span class=\"line\">   status-&gt;cur_delay &#x3D; MIN_DELAY_USEC;</span><br><span class=\"line\"></span><br><span class=\"line\">pg_usleep(status-&gt;cur_delay);</span><br></pre></td></tr></table></figure>\n\n<p>“当然，如果旋转了很长时间，仍然没有办法获得锁资源，就进入自杀模式，因为我们假设自旋锁保护的临界区都很短，如果很长时间还获取不到锁资源，那么就可能出问题了。”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (++(status-&gt;delays) &gt; NUM_DELAYS)</span><br><span class=\"line\">   s_lock_stuck(status-&gt;file, status-&gt;line, status-&gt;func);</span><br></pre></td></tr></table></figure>\n\n<p>“这基本上就是PostgreSQL自旋锁的实现了，不过还需要注意我们只谈了X86架构下的实现方法，在不同的CPU架构下，TAS的实现是不同的，比如在MIPS架构下提供的是ll和sc指令，我们要借助这两个指令来实现TAS。”</p>\n<p>“明白了，看来我需要学的东西还有很多。”小明沮丧的说。</p>\n<p>“不要这么悲观嘛，你不了解这些知识主要是因为你还没有参加工作，还是学生，还在学习的阶段，等你参加工作了，时间长了，也就习惯了。”大明笑着说，“反正债多了不愁，在我们结束之前，再来补充一下自旋锁释放的知识。”</p>\n<p>“锁的释放，直接把值设置成0就可以了嘛。”</p>\n<p>“bingo！是的，我也是这么认为的，但是还有一个注意事项。”</p>\n<p>“什么注意事项，难道这还有什么幺蛾子吗？”小明惊奇道。</p>\n<p>“有一个很大的幺蛾子，就是目前很多CPU为了提高执行效率，实现了乱序执行功能，关于乱序执行的具体内容我们就不展开了，以免你不好消化。不过需要记住的是，如果把释放锁写成只是简单设置lock的值，由于乱序执行的作用，有些临界区中的指令可能会在lock释放后才执行，这就相当于两个进（线）程共同进入了临界区，那肯定会出问题，所以我们可以采用内存屏障的方式来保证锁释放的有序性，你看，PostgreSQL的有些锁释放时用的是这种方式。”说着，大明在源代码中标出了一行锁释放的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do &#123; __memory_barrier(); *(lock) &#x3D; 0; &#125; while (0)</span><br></pre></td></tr></table></figure>\n\n<p>“好吧，我记下了，念了这么多年的书，我觉得还是幼儿园适合我。”小明苦着脸说。<br>“没事，中午我们去吃点好的，弥补一下你受伤的心灵，我准备一下，咱们马上就出发。”</p>\n","site":{"data":{}},"excerpt":"<p>经过上次的<a href=\"/2020/10/03/postgresql-optimizer-outline-10/\" title=\"《《PostgreSQL优化器白话》\">《《PostgreSQL优化器白话》</a>中大明和牛二哥对PostgreSQL优化器的概要的讲解，小明感到自己已经深深的爱上了数据库内核，小明在GitChat网站上购买了《PostgreSQL优化器入门》的文字网课，还跑到实体书店买了本《PostgreSQL技术内幕：查询优化深度探索》，每天对照着网课和书上的内容仔细研读PostgreSQL的优化器的实现，准备在毕业之后去从事数据库内核开发的工作。</p>\n<p>不过，最近在学校的数据库原理课程学到了并发控制的部分，这部分对小明来说有点难度，因为小明没有对数据库的原理进行过实践，无法理解锁的重要性，于是小明又来到自己的哥哥大明家里向大明请教PostgreSQL是如何实现并发控制的。</p>","more":"<p>大明说：“并发控制的部分比较繁杂，我们今天主要关注PostgreSQL锁的实现，不过我们先从最底层的部分开始，先来看一看PostgreSQL是如何实现一个自旋锁的，你知道自旋锁吗？”</p>\n<p>小明感觉这个概念好像在哪里听过，但又没什么印象，于是小声的说：“不知道。”</p>\n<p>大明哈哈一笑，嘲讽道：“这么轻易就说不知道？自信一点！大胆一点！再问你一遍，知道不知道自旋锁？！”</p>\n<p>小明感觉受到了很大的鼓舞，于是大声的说：“老子不知道！”</p>\n<p>“嗯，很自信嘛。。。来，让朕给你讲讲。PostgreSQL的锁的概念有很多种，比如常见的表锁、行锁、页锁、轻量锁、自旋锁等等，这里面最底层的是实现是自旋锁，它和硬件直接接触，并且屏蔽各种不同硬件和操作系统的细节，通常利用硬件提供的原子操作指令来实现。”</p>\n<p>“那为什么要使用这种锁呢？”</p>\n<p>“自旋锁是一种互斥锁，它通常是用来保护临界区，这种保护的方式是一种‘不是你死就是我活’的方式，比如说我通过锁获取到这个临界区的访问权限，那么其他人就必须等待，那它怎么等待呢？”</p>\n<p>“我知道！”小明抢答道：“如果干等着的话，CPU就不能被充分的利用，所以我知道系统里有一个sleep函数能很好的解决这个问题，如果我们不能获取到锁，那么我们可以睡一会，再来获取锁，我听说sleep函数可以释放CPU资源，这样其他进程或者线程就能充分的利用CPU了，这样CPU即被充分的利用，我也能不停的对锁发出请求，岂不是两全其美。”小明伸了伸衣袖，对大明说：“拿笔来！让我展示一下coding的能力。”</p>\n<p>大明给他找了纸和笔，调侃道“看上去很高调嘛。。。”</p>\n<p>“我也想低调，但是实力不允许啊！”小明一边说，一边在纸上写出了自己的蓝图：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(!spinlock_aquire(&amp;lock))</span><br><span class=\"line\">    sleep(100);</span><br></pre></td></tr></table></figure>\n\n<p>大明接过笔在小明写的代码上画了一个大大的对勾，对小明的行为表示肯定，然后又画了一个X，解释道：“虽然看上去合理，但是这里存在一个问题，有时我们要保护的临界区只有区区几个指令，锁的持有者实际上占有锁的时间是极短的，换句话说锁的请求者实际上不用等太长时间就能获得锁，这时候就需要考虑这个睡眠是不是合适了。”</p>\n<p>小明说：“有什么不合适的？不睡眠难道一直占着CPU资源不放，浪费CPU资源？这简直是占着茅坑XXX嘛。”</p>\n<p>“对，就是占着茅坑XXX，你说的睡眠模式实际上进行了CPU上下文的切换，但这种切换需要非常多的时钟周期，如果我们要保护的临界区很短，这种切换的代价就显得有点大了，所以释放CPU资源还不如占着好。”</p>\n<p>小明想了想，说：“哦，那这种锁有点像一个小朋友遇到了想要的玩具，家长不给买的时候的行为。。。”</p>\n<p>大明笑着说：“是的，你小时候就是这样，而且，你在地上打滚的时候从来不休息，一直处于滚动的状态，所以你很小的时候就理解了自旋锁的本质，就是忙等。”</p>\n<p><strong>自旋锁的伪码</strong></p>\n<p>小明继续说：“这样的话，自旋锁的实现就比较容易了，也就是不sleep嘛，我来把它写出来。”说着开始在纸上开始写自旋锁实现的伪码，因为已经了解了自旋锁的基本原理，所以写代码的过程是极为顺利的，小明一边写一边暗暗佩服自己：都是九年义务教育，怎么我就这么优秀呢，像我这样优秀的人，本该灿烂过一生啊。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;让我们假设lock参数是一个线程或进程共享变量</span><br><span class=\"line\">int spinlock_acquire(int *lock)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    while(*lock !&#x3D; 0)</span><br><span class=\"line\">        continue;</span><br><span class=\"line\">    *lock &#x3D; 1;</span><br><span class=\"line\">    return *lock;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int spinlock_release(int *lock)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    *lock &#x3D; 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大明看着小明洋洋自得的写的这段代码，鄙视到：“你觉得这样就能实现一个自旋锁吗？谬矣。”说着拿笔在小明写的自旋锁上画了一个大大的X，然后一边打开电脑，一边继续说：“让我们看看你错在哪里。”说着啪啪啪的在编译器里敲出了和小明同样逻辑的代码，编译之后，通过代码调试工具查看了spinlock_acquire函数的汇编代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spinlock1&#96;spinlock_acquire:</span><br><span class=\"line\">    0x100000f10 &lt;+0&gt;:  pushq  %rbp</span><br><span class=\"line\">    0x100000f11 &lt;+1&gt;:  movq   %rsp, %rbp</span><br><span class=\"line\">    0x100000f14 &lt;+4&gt;:  movq   %rdi, -0x8(%rbp)</span><br><span class=\"line\">    0x100000f18 &lt;+8&gt;:  movq   -0x8(%rbp), %rax</span><br><span class=\"line\">    0x100000f1c &lt;+12&gt;: cmpl   $0x0, (%rax)</span><br><span class=\"line\">    0x100000f1f &lt;+15&gt;: je     0x100000f2a </span><br><span class=\"line\">    0x100000f25 &lt;+21&gt;: jmp    0x100000f18</span><br><span class=\"line\">    0x100000f2a &lt;+26&gt;: movq   -0x8(%rbp), %rax</span><br><span class=\"line\">    0x100000f2e &lt;+30&gt;: movl   $0x1, (%rax)</span><br><span class=\"line\">    0x100000f34 &lt;+36&gt;: movq   -0x8(%rbp), %rax</span><br><span class=\"line\">    0x100000f38 &lt;+40&gt;: movl   (%rax), %eax</span><br><span class=\"line\">    0x100000f3a &lt;+42&gt;: popq   %rbp</span><br><span class=\"line\">    0x100000f3b &lt;+43&gt;: retq</span><br><span class=\"line\">    0x100000f3c &lt;+44&gt;: nopl   (%rax)</span><br></pre></td></tr></table></figure>\n\n<p>大明指着屏幕上的汇编代码说：“这段代码是无法作为锁的实现的，因为上面的操作缺乏原子性，比如对lock对应的值是否为0（*lock != 0）的判断就不是一个原子操作，它是通过movq   -0x8(%rbp), %rax和cmpl   $0x0, (%rax)两个指令来实现。假如有两个线程来获取同一个锁，那么会发生什么情况呢？”说着大明在纸上画了一个示意图：</p>\n<p>“你看，这时候问题就出现了，线程A和线程B同时觉得当前的lock中的值是0，也就是说他们两个都能获得锁资源，也就出现了两个线程同时获得锁的情况，你觉得这还合理吗？”</p>\n<p>小明羞愧的低下了头，怪不得自己二十多年到头来，还在人海里浮沉，原来是因为不懂汇编语言啊。</p>\n<p>看着小明羞愧的表情，大明解释道：“C语言的一条语句可能对应几条汇编指令，在执行期间无法保证它的原子性，所以在高级语言的层面需要借助一些算法或者底层的指令来实现临界区的同步功能，如果想通过高级语言的算法来实现临界区的同步功能，也不是补可以，但是需要使用一些比较精妙的算法（比如Peterson算法），这些方法都有很大的局限性，现在已经很少使用这些方法了，今天我们需要关注的是目前的计算机提供的一些硬件指令，通过这些指令，我们可以借助这些指令来实现临界区的同步功能。”</p>\n<p><strong>TAS VS CAS</strong></p>\n<p>小明怯怯的问道：“是不是我们学操作系统课程的时候说的那些原子指令？”</p>\n<p>“对的，现在大部分硬件都支持两种类型的原子操作指令，比如TAS和CAS指令，下面我们给出他们的伪码。”说着，大明拿了一张新的白纸，边写边说道：“TEST-AND-SET 简称为TAS，它的流程是向内存变量写入1，然后返回内存变量的原值，伪码是这样的。”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int TAS(int *lock)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int temp &#x3D; *lock;</span><br><span class=\"line\">    *lock &#x3D; 1;</span><br><span class=\"line\">    return *lock;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>“COMPARE-AND-SWAP简称CAS，它的流程是比较锁中的值和期望值，如果锁中的值和期望值相同，则设置为新值，返回true,否则不设置新值，返回false，它的伪码是这样的。”大明继续写道。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int CAS(int *lock, int expect, int new)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(*lock &#x3D;&#x3D; expect)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        *lock &#x3D; new;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大明提示道：“注意，上面的伪码是借用高级语言的形式来描述这两种类型的指令的含义，实际上它是一个完整的原子操作，在X86架构的CPU中，分别提供了XCHG指令和CMPXCHG指令来实现TAS和CAS操作，PostgreSQL在X86架构下采用的是基于XCHG指令的TAS来实现的自旋锁。”</p>\n<p>小明兴奋的说：“我已经迫不及待的想看看PostgreSQL是怎么使用TAS指令来实现自旋锁的了。”</p>\n<p>大明看着小明手舞足蹈的神态，做了一个calm down的手势，然后说：“稍安勿躁，不要急，再过一会精神病院的救护车就到了。在这之前我们先来谈一下TTAS。”</p>\n<p>“TTAS？感觉像是TEST AND TEST-AND-SET？”</p>\n<p>“是的，TAS虽然已经足够我们使用，但是也带来一个问题，大部分CPU实现TAS的方法是锁住总线，一旦锁住总线就等于一个CPU占用了整个总线，而频繁的锁住总线会降低CPU的使用效率，所以在进入TAS之前，我们可以先做一个粗略的检测，这个检测不在原子操作之中，但是它可以让我们快速的知道目前锁的状态，如果第一个TEST检测到锁已经被占用了，那么我们就再等一会，就不用进行TAS了，这样就避免了锁住总线，如果第一个TEST发现锁没有被占用，那么就值得去做TAS。”</p>\n<p>小明说：“但在第一个TEST和TEST-AND-SET之间，锁的状态可能会被其他CPU上的进程修改掉吧？”</p>\n<p>“是的，所以这个TEST只是我们提高性能的一个手段。比如在PostgreSQL数据库中，它就是采用的TTAS的方法。”说着，大明打开了PostgreSQL源代码，找到了TAS实现的部分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static __inline__ int</span><br><span class=\"line\">tas(volatile slock_t *lock)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   register slock_t _res &#x3D; 1;</span><br><span class=\"line\"></span><br><span class=\"line\">   __asm__ __volatile__(</span><br><span class=\"line\">      &quot;  cmpb   $0,%1  \\n&quot;</span><br><span class=\"line\">      &quot;  jne       1f    \\n&quot;</span><br><span class=\"line\">      &quot;  lock         \\n&quot;</span><br><span class=\"line\">      &quot;  xchgb  %0,%1  \\n&quot;</span><br><span class=\"line\">      &quot;1: \\n&quot;</span><br><span class=\"line\">:     &quot;+q&quot;(_res), &quot;+m&quot;(*lock)</span><br><span class=\"line\">:</span><br><span class=\"line\">:     &quot;memory&quot;, &quot;cc&quot;);</span><br><span class=\"line\">   return (int) _res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大明一边用鼠标在编译器里划住了tas函数，一边说：“从这段汇编代码可以看出，CMP指令和下面的XCHG不能组成一个原子操作，比如一个线程B已经持有了锁，线程A做了CMP指令也发现了有其他线程已经占有了锁资源，于是他就会JNE跳过XCHG指令，但是很可能在CMP指令之后，线程B就立即释放了锁资源。”大明在纸上画了一个示意图：</p>\n<p>“XCHG指令会尝试交换两个操作数，如果想要获得一个锁，也就是说我们打算在‘锁对应的值是0的情况下把锁的值设置为1’，同时我们还可以用0和1来代表TEST-AND-SET是否成功，那么对上面的汇编代码翻译成高级语言就变成下面这样。”大明开始在纸上写出了对应于PostgreSQL的tas函数的伪码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static __inline__ int</span><br><span class=\"line\">tas(volatile slock_t lock)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   register slock_res &#x3D; 1;</span><br><span class=\"line\"></span><br><span class=\"line\">   if(*lock !&#x3D; 1)  &#x2F;&#x2F;CMP指令</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      &#x2F;&#x2F;下面3行是原子操作，对应XCHG</span><br><span class=\"line\">       int temp &#x3D; *lock; </span><br><span class=\"line\">lock &#x3D; 1;  &#x2F;&#x2F;同*lock &#x3D; res;</span><br><span class=\"line\">res &#x3D; temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   return (int) _res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>小明听得云里雾里的，只好说：“感觉听着有点吃力，”</p>\n<p>大明笑着说，没关系的：“你可以把这些概念记住，有时间回想一下，好好消化消化。”</p>\n<p>小明痛苦的说：“可是你说的这些都是便秘的知识，容易消化不良啊。”</p>\n<p>大明说：“不要担心嘛，自旋锁的事才刚刚开始，有了TAS我们才能继续实现PostgreSQL的自旋锁，让我们来看看自旋锁的实现吧。”</p>\n<p><strong>PostgreSQL的自旋锁</strong></p>\n<p>大明继续说道：“在有些CPU架构下，PostgreSQL没有直接使用TTAS，而是先实现了TAS，然后借用TAS_SPIN函数(或者说宏)来实现的自旋锁。”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define TAS_SPIN(lock)  (*(lock) ? 1 : TAS(lock))</span><br></pre></td></tr></table></figure>\n\n<p>“有了TAS_SPIN我们是不是就很容易实现一个自旋锁了呢？”大明问道。</p>\n<p>小明想了想说：“让我来写一下，看看这次能不能实现一个可用的自旋锁。”说着小明在纸上写了起来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void spinlock_acquire(int *lock)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    while(TAS_SPIN(lock));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>写完之后，小明又推演了几遍，感觉没什么错误了，于是帅气的摇了摇头，说道：“怎么样，是不是很佩服我这样美貌与智慧并重的人？”</p>\n<p>“嗯，这个自旋锁是可用的，不过美貌和智慧你都没做到，你做到了病重，精神病院的救护车还没到，我们还有时间继续说自旋锁。”大明调侃道，“我们还能继续优化它。比如适当的偷懒，这种自旋目的是不放弃CPU，但也没必要不停的旋，我们可以用空指令来适当的让CPU歇一会，而不必过度旋转，旋转太频繁了浪费电，我们使用nop指令来进行偷懒”，说着大明在PostgreSQL的源代码中指出了spin_delay函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">static __inline__ void</span><br><span class=\"line\">spin_delay(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   __asm__ __volatile__(</span><br><span class=\"line\">      &quot; rep; nop       \\n&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大明继续说道：“另外，我们也应该处理一些特殊的情况，比如尝试了很多次TAS之后仍然无法获得锁资源，那么就进入sleep，也就是交出CPU资源，需要注意的是睡眠的时间是随机的，但不能超出上下界。”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;第一次sleep的时间，sleep的时间逐步递增，第一次是1000微秒</span><br><span class=\"line\">if (status-&gt;cur_delay &#x3D;&#x3D; 0) &#x2F;* first time to delay? *&#x2F;</span><br><span class=\"line\">   status-&gt;cur_delay &#x3D; MIN_DELAY_USEC;</span><br><span class=\"line\"></span><br><span class=\"line\">pg_usleep(status-&gt;cur_delay);</span><br></pre></td></tr></table></figure>\n\n<p>“当然，如果旋转了很长时间，仍然没有办法获得锁资源，就进入自杀模式，因为我们假设自旋锁保护的临界区都很短，如果很长时间还获取不到锁资源，那么就可能出问题了。”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (++(status-&gt;delays) &gt; NUM_DELAYS)</span><br><span class=\"line\">   s_lock_stuck(status-&gt;file, status-&gt;line, status-&gt;func);</span><br></pre></td></tr></table></figure>\n\n<p>“这基本上就是PostgreSQL自旋锁的实现了，不过还需要注意我们只谈了X86架构下的实现方法，在不同的CPU架构下，TAS的实现是不同的，比如在MIPS架构下提供的是ll和sc指令，我们要借助这两个指令来实现TAS。”</p>\n<p>“明白了，看来我需要学的东西还有很多。”小明沮丧的说。</p>\n<p>“不要这么悲观嘛，你不了解这些知识主要是因为你还没有参加工作，还是学生，还在学习的阶段，等你参加工作了，时间长了，也就习惯了。”大明笑着说，“反正债多了不愁，在我们结束之前，再来补充一下自旋锁释放的知识。”</p>\n<p>“锁的释放，直接把值设置成0就可以了嘛。”</p>\n<p>“bingo！是的，我也是这么认为的，但是还有一个注意事项。”</p>\n<p>“什么注意事项，难道这还有什么幺蛾子吗？”小明惊奇道。</p>\n<p>“有一个很大的幺蛾子，就是目前很多CPU为了提高执行效率，实现了乱序执行功能，关于乱序执行的具体内容我们就不展开了，以免你不好消化。不过需要记住的是，如果把释放锁写成只是简单设置lock的值，由于乱序执行的作用，有些临界区中的指令可能会在lock释放后才执行，这就相当于两个进（线）程共同进入了临界区，那肯定会出问题，所以我们可以采用内存屏障的方式来保证锁释放的有序性，你看，PostgreSQL的有些锁释放时用的是这种方式。”说着，大明在源代码中标出了一行锁释放的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do &#123; __memory_barrier(); *(lock) &#x3D; 0; &#125; while (0)</span><br></pre></td></tr></table></figure>\n\n<p>“好吧，我记下了，念了这么多年的书，我觉得还是幼儿园适合我。”小明苦着脸说。<br>“没事，中午我们去吃点好的，弥补一下你受伤的心灵，我准备一下，咱们马上就出发。”</p>"},{"title":"PostgreSQL中的锁 - 轻量锁","date":"2021-07-20T00:18:10.000Z","_content":"\n\n大明与小明聊完了自旋锁，已是中午时分，大明突然想到最近有一本讲解事务处理的新书要上市，正好包含要讲给小明的自旋锁、轻量锁、常规锁等内容，于是对小明说：“最近上市了一本新书，叫**《PostgreSQL技术内幕：事务处理深度探索》**，是**《PostgreSQL技术内幕：查询优化深度探索》**的姊妹篇，恰好有你想要学习的内容，我们不妨去附近的书店看看。”\n\n经过一上午的讲解，小明已经精疲力尽，腹中隆隆作响，大明不由笑道：“咱们还是先饱餐战饭，然后再去书店吧。”\n\n小明揉揉肚子，确实已经是饥肠辘辘，便笑道：”免不了又让你破费。“\n\n<!--more-->\n\n大明从沙发上弹起身子，边穿外衣边道：”附近美食颇多，沙县料理、成都七星酒店都不错，我们还是边走边看吧。“\n\n大明家附近不远恰有一条商业街，周末时间的中午，商业街上熙熙攘攘，人流穿梭，附近的酒店竟然纷纷排起队来，还有一些酒店已经被婚礼包场，加长的婚车路过商业街，自是热闹非常。大明和小明先是来到沙县料理，发现已被婚礼包场，然后又到了成都七星酒店，结果店外排队等候的宾客自觉地排起了一条长龙，不免有些扫兴。\n\n大明提议道：”我知道此处角落有一家小吃，店家虽小，但味道不错，不如前去一试。“于是二人穿梭进商业街角落的一个小巷，七拐八拐，终于来到一家小店门前，店面虽小，但看上去整洁干净，装修古朴，大大的招牌上写着鎏金的的店名：老约翰炸酱面馆。不过店面在商业街外的角落中，店中的客人不多，仍有余位，二人便找了一个不错的位置坐下了。\n\n小明拿起菜单笑道：”没想到这小小的角落中竟卧虎藏龙，不如就吃他们这里的招牌套餐，炸酱意大利面吧，我要一个大碗的。”大明于是对服务员说：“要两个大碗的炸酱意大利面，给我拿两头蒜。”\n\n然后大明转头对小明说道：“今天真是触霉头，好点的饭店竟然都被婚礼给独占了。”小明便说：“没关系，自旋锁嘛，都是互斥的，他们占了，我们就进不去，不过我们就不等了，直接换一家吃，我看炸酱意大利面也不错。”\n\n大明说道：“说到这里，我们不妨再介绍一下PostgreSQL中的轻量锁，这是一种有共享精神的锁。”\n\n”轻量锁？让我想想，我好想听说过这种类型的锁，它和自旋锁不同，它一般用于保护PostgreSQL中对共享内存的操作吧，它是一种读写锁吧？“\n\n**读写锁**\n\n”是的。“大明边点头便说：”轻量锁把锁分成了读锁和写锁，读锁只读取访问资源，因此是可以共享的，也就是说可以有多个进程同时读共享资源，而写锁则是排它的，因为写锁的持有者要修改共享资源中的内容，它的锁相容矩阵是这样的。“说着，大明蘸了点茶水，在桌面上画出了轻量锁的相容矩阵。\n\n| 锁类型   | 读锁     |  写锁    |\n| ------- | -----:  | :----: |\n| 读锁     | O      |   X    |\n| 写锁     | X      |   X    |\n\n\"你看，这其中O就代表相容，X就代表互斥。\"大明边画边说。\n小明看着桌面上渐渐淡去的水痕，若有所思的说道：”这种锁的出现就是为了提高并发度，因为读和读是相容的。它和自旋锁是的不同在于，自旋锁是互斥锁，一旦锁定了临界区，其他访问者就只能等了。它是没有等级概念的，就只有互斥一种情况，而轻量锁把对共享资源的访问划分成了2个等级，一个等级是读，一个等级是写，这样锁的粒度就更细了。”\n\n大明点了点头说道：“说得好，但我们还是尽量不要把轻量锁和自旋锁混为一谈，它们的目的不同，实际上在早期的PostgreSQL中，轻量锁是借助自旋锁实现的。”\n\n小明惊奇道：“借助自旋锁实现的?”\n\n“嗯，我们在实现自旋锁的时候，借助CPU提供的原语实现了对一个共享变量的原子操作，所以我们就可以根据这个共享变量的状态来决定我们是不是可以进入临界区。”大明停顿了一下，然后继续说：“轻量锁的实现也无外乎如此，只不过它的状态多了，用一个变量不好保存，于是就用自旋锁来实现对这些变量的保护。”\n\n小明点点头说道：“嗯，在讲解自旋锁的时候你曾经说过，自旋锁一般只保护很小的临界区，所以可以忙等，也就是说用自旋锁来实现轻量锁的时候，保护共享状态的临界区也一定非常小，不然就没有办法用自旋锁来实现轻量锁了吧。”\n\n\n**事情发生了变化**\n\n大明皱了皱眉说道：“是的，也正因为如此，事情已经发生变化，我们以前可以说PostgreSQL用自旋锁来实现了轻量锁，但是现在不能这么说了。”\n\n“为什么？”\n\n“在之前的PostgreSQL版本中，轻量锁的锁结构中有几个变量用来记录当前锁的状态，比如，共享锁可以由多个访问者共享，我们就可以用一个变量来记录目前有多少个访问者共享这个锁，比如排它锁具有互斥性，我们就采用一个变量来标识当前谁获得了排它锁。最终根据这些状态就可以判断新的访问者是否可以获得锁，但这里有两个问题。”大明停顿了一下，继续说道：“一个问题是轻量锁的获取和释放特别频繁，另一个问题是这次自旋锁保护的临界区有点大了，把这两个问题综合到一起就是：这里用自旋锁保护临界区，降低了PostgreSQL的性能。”\n\n“我听你刚才说的，好像是有点浪费，比如排它锁的状态吧，我们只需要一个0和1的状态就可以了，用一个字节来标识都嫌多，而共享锁的计数我想也不会达到2^32次方，所以用一个4字节的int来表示，也完全是一种浪费，我看可以把这些状态用bit位来标识，完全就可以了。”小明略有所思的说道。\n\n大明赞赏的说：“完全正确。”\n\n这时候服务员把炸酱意大利面已经端上来了，两个人顾不上再接着说轻量锁，开始吃起来，小明一边吃一边想怎么合理的分配轻量锁状态的bit位，对于排它锁而言，只需要一个bit就够了，而共享锁的计数呢？需要分配多少个呢？\n\n大明快速的吃了几口面，然后用蘸着水在桌子上画了起来：“目前轻量锁状态的布局是这样的。”\n\n![](./postgresql-lock-lwlock-implement/lockstate.jpg) \n\n小明赞许的说：“嗯，用24个bit位做计数，应该是够多了。现在都喜欢用无锁编程，那么这么一个变量的保护也就没有必要再使用自旋锁来保护了，只要自己实现一个CAS的原语就够了。”\n\n“对，正是这样实现的，这样就解决了并发的问题。”\n\n**保护的也不大**\n\n小明想了想，继续说道：“那既然已经不用自旋锁实现轻量锁了，那自旋锁是不是就快要退休了呢？”\n\n大明啃了一口大蒜然后说道：“或许吧，但目前自旋锁还是有些用处的，现在说要退休还为时尚早。而轻量锁呢，也有它自己的问题，它之所以叫轻量锁，原因就是它也期望自己保护的临界区不太‘大’，虽然未必如自旋锁那样，只需要很少的CPU时钟周期，但如果轻量锁保护的临界区太复杂，仍然可能带来性能问题。我就曾经犯过一个错误，在轻量锁保护的临界区中加入了太多的新代码，最终导致数据库连接不上。。。”\n\n“可是，轻量锁中不是有读锁吗，那还不够吗？”\n\n“PostgreSQL中写共享内存状态的情况也不少，因此并不是把锁的状态分离成两个等级之后就能解决一切问题，写-写之间、写-读之间仍然是互斥的，所以使用轻量锁的时候仍然要谨记，轻量锁保护的区间不能太大。这就好像旅游区的公厕一样，虽然你独占了马桶，但是请快速解决问题，不然外边的等待队列太长，也会造成拥堵。”\n\n听大明说起了旅游区的马桶，小明顿时觉得口中的面难以下咽，于是问道：\"嗯？轻量锁还会排队，看来这和自旋锁不一样，自旋锁好像没有等待队列嗳？\"\n\n**等待队列**\n\n大明吃了一口面继续说道：“嗯，确实是这样，自旋锁是没有队列的，但是轻量锁有等待队列。比如，现在有进程已经以共享状态持有了一个轻量锁，那么想要持有互斥锁的进程肯定是只能进等待队列了。”\n\n“如果这时候又来一个进程想要持有共享锁呢？是讲究先来后到的进入等待队列，还是直接获得共享锁？”\n\n“嗯，好问题，这就是轻量锁和常规锁的不同。”\n\n“常规锁？”\n\n“就是表级锁啊，轻量锁在这种情况下，共享锁就可以直接获取了，但是常规锁可能就需要进等待队列喽！”\n\n![](./postgresql-lock-lwlock-implement/sxlock.jpg) \n\n\n**唤醒**\n\n这时店外进来一个高大的身影，胡茬唏嘘，格子衬衣，小明远远看去似曾相识，于是向大明问道：“那刚进来的人可是牛二哥？”大明转头一看，果然是牛二哥，于是起身招呼道：“老牛，你怎么也到这里才吃面了，过来我们同坐一桌吧。”牛二哥看是大明和小明，非常高兴，于是像小明问道：“小兄弟，上次我和大明给你讲的查询优化你还记得吧？”\n\n小明忙说：“记得记得，我现在已经获得了我们宿舍的‘优化器小能手’称号，我明天就去买个奖状挂起来。不过今天大明哥正给我讲轻量锁呢，牛二哥来吧，咱们3个都是申请读锁的，可以同坐一桌。”\n\n牛二哥笑着坐在小明旁边，对服务员说：“给我一碗刀削意大利面。”然后转过头说：“我刚才在商业街转了几个圈，一个空位都没找到，就想起来这里有个面馆，于是就过来了。”\n\n小明说：“嗯，看来还是轻量锁好，读锁可以相容，不像自旋锁，自己占着CPU原地打转。”小明一边说一边用手在桌上画了几个圈。\n\n牛二哥说：“嗯，不过我们这些读锁已经占领了这个桌子，如果有写锁想来独占，也需要等我们走了才行，我们和他们不相容啊。”\n小明想了想顿时领悟，如果此时有人以读锁申请轻量锁，而我们申请的也是读锁，自然是可以直接获得锁的，而如果我们申请的是写锁，那么就肯定只能等待了。但是如果现在有人以写锁持有轻量锁，那么无论是新来的读锁还是写锁，都需要进入等待队列，想到此处小明不禁发问道：“那如果持有锁的人释放了锁，我们应该以什么顺序唤醒等待队列里的锁呢？”\n\n牛二哥想了想，说：“嗯，那要看排在第一个的是什么锁，如果排在第一个的是写锁，那么就直接唤醒这个写锁，如果排在第一个的是读锁，那么就唤醒等待队列中所有的读锁，而忽略等待队列中的写锁，就像这样。。。”说着，牛二哥在桌上画了起来。\n\n![](./postgresql-lock-lwlock-implement/waitqueue.jpg) \n\n\n**小结**\n\n看着牛二哥在桌上的等待队列唤醒图，小明觉得应该对轻量锁有了一个基本的了解，但是突然萌发了一个想法：刚才大明说过常规锁，那又是怎样实现的呢？于是便问牛二哥：“那常规锁有没有等待队列？”牛二哥愣了一下，突然大笑道：“不急不急，最近有本新书《PostgreSQL技术内幕：事务处理深度探索》已经上市了，里面啥都有，我们吃完去书店看看吧。”\n大明和小明点头道：“正有此意，同去同去。”\n\n这时服务员把牛二哥的面已经端上来了，于是三个人又开始边吃边聊一些业内的八卦，老约翰炸酱面馆中又恢复了活泼的气氛。\n","source":"_posts/postgresql-lock-lwlock-implement.md","raw":"---\ntitle: PostgreSQL中的锁 - 轻量锁\ndate: 2021-07-20 08:18:10\ntags: lock lwlock transaction postgresql\n---\n\n\n大明与小明聊完了自旋锁，已是中午时分，大明突然想到最近有一本讲解事务处理的新书要上市，正好包含要讲给小明的自旋锁、轻量锁、常规锁等内容，于是对小明说：“最近上市了一本新书，叫**《PostgreSQL技术内幕：事务处理深度探索》**，是**《PostgreSQL技术内幕：查询优化深度探索》**的姊妹篇，恰好有你想要学习的内容，我们不妨去附近的书店看看。”\n\n经过一上午的讲解，小明已经精疲力尽，腹中隆隆作响，大明不由笑道：“咱们还是先饱餐战饭，然后再去书店吧。”\n\n小明揉揉肚子，确实已经是饥肠辘辘，便笑道：”免不了又让你破费。“\n\n<!--more-->\n\n大明从沙发上弹起身子，边穿外衣边道：”附近美食颇多，沙县料理、成都七星酒店都不错，我们还是边走边看吧。“\n\n大明家附近不远恰有一条商业街，周末时间的中午，商业街上熙熙攘攘，人流穿梭，附近的酒店竟然纷纷排起队来，还有一些酒店已经被婚礼包场，加长的婚车路过商业街，自是热闹非常。大明和小明先是来到沙县料理，发现已被婚礼包场，然后又到了成都七星酒店，结果店外排队等候的宾客自觉地排起了一条长龙，不免有些扫兴。\n\n大明提议道：”我知道此处角落有一家小吃，店家虽小，但味道不错，不如前去一试。“于是二人穿梭进商业街角落的一个小巷，七拐八拐，终于来到一家小店门前，店面虽小，但看上去整洁干净，装修古朴，大大的招牌上写着鎏金的的店名：老约翰炸酱面馆。不过店面在商业街外的角落中，店中的客人不多，仍有余位，二人便找了一个不错的位置坐下了。\n\n小明拿起菜单笑道：”没想到这小小的角落中竟卧虎藏龙，不如就吃他们这里的招牌套餐，炸酱意大利面吧，我要一个大碗的。”大明于是对服务员说：“要两个大碗的炸酱意大利面，给我拿两头蒜。”\n\n然后大明转头对小明说道：“今天真是触霉头，好点的饭店竟然都被婚礼给独占了。”小明便说：“没关系，自旋锁嘛，都是互斥的，他们占了，我们就进不去，不过我们就不等了，直接换一家吃，我看炸酱意大利面也不错。”\n\n大明说道：“说到这里，我们不妨再介绍一下PostgreSQL中的轻量锁，这是一种有共享精神的锁。”\n\n”轻量锁？让我想想，我好想听说过这种类型的锁，它和自旋锁不同，它一般用于保护PostgreSQL中对共享内存的操作吧，它是一种读写锁吧？“\n\n**读写锁**\n\n”是的。“大明边点头便说：”轻量锁把锁分成了读锁和写锁，读锁只读取访问资源，因此是可以共享的，也就是说可以有多个进程同时读共享资源，而写锁则是排它的，因为写锁的持有者要修改共享资源中的内容，它的锁相容矩阵是这样的。“说着，大明蘸了点茶水，在桌面上画出了轻量锁的相容矩阵。\n\n| 锁类型   | 读锁     |  写锁    |\n| ------- | -----:  | :----: |\n| 读锁     | O      |   X    |\n| 写锁     | X      |   X    |\n\n\"你看，这其中O就代表相容，X就代表互斥。\"大明边画边说。\n小明看着桌面上渐渐淡去的水痕，若有所思的说道：”这种锁的出现就是为了提高并发度，因为读和读是相容的。它和自旋锁是的不同在于，自旋锁是互斥锁，一旦锁定了临界区，其他访问者就只能等了。它是没有等级概念的，就只有互斥一种情况，而轻量锁把对共享资源的访问划分成了2个等级，一个等级是读，一个等级是写，这样锁的粒度就更细了。”\n\n大明点了点头说道：“说得好，但我们还是尽量不要把轻量锁和自旋锁混为一谈，它们的目的不同，实际上在早期的PostgreSQL中，轻量锁是借助自旋锁实现的。”\n\n小明惊奇道：“借助自旋锁实现的?”\n\n“嗯，我们在实现自旋锁的时候，借助CPU提供的原语实现了对一个共享变量的原子操作，所以我们就可以根据这个共享变量的状态来决定我们是不是可以进入临界区。”大明停顿了一下，然后继续说：“轻量锁的实现也无外乎如此，只不过它的状态多了，用一个变量不好保存，于是就用自旋锁来实现对这些变量的保护。”\n\n小明点点头说道：“嗯，在讲解自旋锁的时候你曾经说过，自旋锁一般只保护很小的临界区，所以可以忙等，也就是说用自旋锁来实现轻量锁的时候，保护共享状态的临界区也一定非常小，不然就没有办法用自旋锁来实现轻量锁了吧。”\n\n\n**事情发生了变化**\n\n大明皱了皱眉说道：“是的，也正因为如此，事情已经发生变化，我们以前可以说PostgreSQL用自旋锁来实现了轻量锁，但是现在不能这么说了。”\n\n“为什么？”\n\n“在之前的PostgreSQL版本中，轻量锁的锁结构中有几个变量用来记录当前锁的状态，比如，共享锁可以由多个访问者共享，我们就可以用一个变量来记录目前有多少个访问者共享这个锁，比如排它锁具有互斥性，我们就采用一个变量来标识当前谁获得了排它锁。最终根据这些状态就可以判断新的访问者是否可以获得锁，但这里有两个问题。”大明停顿了一下，继续说道：“一个问题是轻量锁的获取和释放特别频繁，另一个问题是这次自旋锁保护的临界区有点大了，把这两个问题综合到一起就是：这里用自旋锁保护临界区，降低了PostgreSQL的性能。”\n\n“我听你刚才说的，好像是有点浪费，比如排它锁的状态吧，我们只需要一个0和1的状态就可以了，用一个字节来标识都嫌多，而共享锁的计数我想也不会达到2^32次方，所以用一个4字节的int来表示，也完全是一种浪费，我看可以把这些状态用bit位来标识，完全就可以了。”小明略有所思的说道。\n\n大明赞赏的说：“完全正确。”\n\n这时候服务员把炸酱意大利面已经端上来了，两个人顾不上再接着说轻量锁，开始吃起来，小明一边吃一边想怎么合理的分配轻量锁状态的bit位，对于排它锁而言，只需要一个bit就够了，而共享锁的计数呢？需要分配多少个呢？\n\n大明快速的吃了几口面，然后用蘸着水在桌子上画了起来：“目前轻量锁状态的布局是这样的。”\n\n![](./postgresql-lock-lwlock-implement/lockstate.jpg) \n\n小明赞许的说：“嗯，用24个bit位做计数，应该是够多了。现在都喜欢用无锁编程，那么这么一个变量的保护也就没有必要再使用自旋锁来保护了，只要自己实现一个CAS的原语就够了。”\n\n“对，正是这样实现的，这样就解决了并发的问题。”\n\n**保护的也不大**\n\n小明想了想，继续说道：“那既然已经不用自旋锁实现轻量锁了，那自旋锁是不是就快要退休了呢？”\n\n大明啃了一口大蒜然后说道：“或许吧，但目前自旋锁还是有些用处的，现在说要退休还为时尚早。而轻量锁呢，也有它自己的问题，它之所以叫轻量锁，原因就是它也期望自己保护的临界区不太‘大’，虽然未必如自旋锁那样，只需要很少的CPU时钟周期，但如果轻量锁保护的临界区太复杂，仍然可能带来性能问题。我就曾经犯过一个错误，在轻量锁保护的临界区中加入了太多的新代码，最终导致数据库连接不上。。。”\n\n“可是，轻量锁中不是有读锁吗，那还不够吗？”\n\n“PostgreSQL中写共享内存状态的情况也不少，因此并不是把锁的状态分离成两个等级之后就能解决一切问题，写-写之间、写-读之间仍然是互斥的，所以使用轻量锁的时候仍然要谨记，轻量锁保护的区间不能太大。这就好像旅游区的公厕一样，虽然你独占了马桶，但是请快速解决问题，不然外边的等待队列太长，也会造成拥堵。”\n\n听大明说起了旅游区的马桶，小明顿时觉得口中的面难以下咽，于是问道：\"嗯？轻量锁还会排队，看来这和自旋锁不一样，自旋锁好像没有等待队列嗳？\"\n\n**等待队列**\n\n大明吃了一口面继续说道：“嗯，确实是这样，自旋锁是没有队列的，但是轻量锁有等待队列。比如，现在有进程已经以共享状态持有了一个轻量锁，那么想要持有互斥锁的进程肯定是只能进等待队列了。”\n\n“如果这时候又来一个进程想要持有共享锁呢？是讲究先来后到的进入等待队列，还是直接获得共享锁？”\n\n“嗯，好问题，这就是轻量锁和常规锁的不同。”\n\n“常规锁？”\n\n“就是表级锁啊，轻量锁在这种情况下，共享锁就可以直接获取了，但是常规锁可能就需要进等待队列喽！”\n\n![](./postgresql-lock-lwlock-implement/sxlock.jpg) \n\n\n**唤醒**\n\n这时店外进来一个高大的身影，胡茬唏嘘，格子衬衣，小明远远看去似曾相识，于是向大明问道：“那刚进来的人可是牛二哥？”大明转头一看，果然是牛二哥，于是起身招呼道：“老牛，你怎么也到这里才吃面了，过来我们同坐一桌吧。”牛二哥看是大明和小明，非常高兴，于是像小明问道：“小兄弟，上次我和大明给你讲的查询优化你还记得吧？”\n\n小明忙说：“记得记得，我现在已经获得了我们宿舍的‘优化器小能手’称号，我明天就去买个奖状挂起来。不过今天大明哥正给我讲轻量锁呢，牛二哥来吧，咱们3个都是申请读锁的，可以同坐一桌。”\n\n牛二哥笑着坐在小明旁边，对服务员说：“给我一碗刀削意大利面。”然后转过头说：“我刚才在商业街转了几个圈，一个空位都没找到，就想起来这里有个面馆，于是就过来了。”\n\n小明说：“嗯，看来还是轻量锁好，读锁可以相容，不像自旋锁，自己占着CPU原地打转。”小明一边说一边用手在桌上画了几个圈。\n\n牛二哥说：“嗯，不过我们这些读锁已经占领了这个桌子，如果有写锁想来独占，也需要等我们走了才行，我们和他们不相容啊。”\n小明想了想顿时领悟，如果此时有人以读锁申请轻量锁，而我们申请的也是读锁，自然是可以直接获得锁的，而如果我们申请的是写锁，那么就肯定只能等待了。但是如果现在有人以写锁持有轻量锁，那么无论是新来的读锁还是写锁，都需要进入等待队列，想到此处小明不禁发问道：“那如果持有锁的人释放了锁，我们应该以什么顺序唤醒等待队列里的锁呢？”\n\n牛二哥想了想，说：“嗯，那要看排在第一个的是什么锁，如果排在第一个的是写锁，那么就直接唤醒这个写锁，如果排在第一个的是读锁，那么就唤醒等待队列中所有的读锁，而忽略等待队列中的写锁，就像这样。。。”说着，牛二哥在桌上画了起来。\n\n![](./postgresql-lock-lwlock-implement/waitqueue.jpg) \n\n\n**小结**\n\n看着牛二哥在桌上的等待队列唤醒图，小明觉得应该对轻量锁有了一个基本的了解，但是突然萌发了一个想法：刚才大明说过常规锁，那又是怎样实现的呢？于是便问牛二哥：“那常规锁有没有等待队列？”牛二哥愣了一下，突然大笑道：“不急不急，最近有本新书《PostgreSQL技术内幕：事务处理深度探索》已经上市了，里面啥都有，我们吃完去书店看看吧。”\n大明和小明点头道：“正有此意，同去同去。”\n\n这时服务员把牛二哥的面已经端上来了，于是三个人又开始边吃边聊一些业内的八卦，老约翰炸酱面馆中又恢复了活泼的气氛。\n","slug":"postgresql-lock-lwlock-implement","published":1,"updated":"2021-07-19T23:44:11.000Z","_id":"ckrb9w1k70000g29khng9fbev","comments":1,"layout":"post","photos":[],"link":"","content":"<p>大明与小明聊完了自旋锁，已是中午时分，大明突然想到最近有一本讲解事务处理的新书要上市，正好包含要讲给小明的自旋锁、轻量锁、常规锁等内容，于是对小明说：“最近上市了一本新书，叫<strong>《PostgreSQL技术内幕：事务处理深度探索》</strong>，是<strong>《PostgreSQL技术内幕：查询优化深度探索》</strong>的姊妹篇，恰好有你想要学习的内容，我们不妨去附近的书店看看。”</p>\n<p>经过一上午的讲解，小明已经精疲力尽，腹中隆隆作响，大明不由笑道：“咱们还是先饱餐战饭，然后再去书店吧。”</p>\n<p>小明揉揉肚子，确实已经是饥肠辘辘，便笑道：”免不了又让你破费。“</p>\n<a id=\"more\"></a>\n\n<p>大明从沙发上弹起身子，边穿外衣边道：”附近美食颇多，沙县料理、成都七星酒店都不错，我们还是边走边看吧。“</p>\n<p>大明家附近不远恰有一条商业街，周末时间的中午，商业街上熙熙攘攘，人流穿梭，附近的酒店竟然纷纷排起队来，还有一些酒店已经被婚礼包场，加长的婚车路过商业街，自是热闹非常。大明和小明先是来到沙县料理，发现已被婚礼包场，然后又到了成都七星酒店，结果店外排队等候的宾客自觉地排起了一条长龙，不免有些扫兴。</p>\n<p>大明提议道：”我知道此处角落有一家小吃，店家虽小，但味道不错，不如前去一试。“于是二人穿梭进商业街角落的一个小巷，七拐八拐，终于来到一家小店门前，店面虽小，但看上去整洁干净，装修古朴，大大的招牌上写着鎏金的的店名：老约翰炸酱面馆。不过店面在商业街外的角落中，店中的客人不多，仍有余位，二人便找了一个不错的位置坐下了。</p>\n<p>小明拿起菜单笑道：”没想到这小小的角落中竟卧虎藏龙，不如就吃他们这里的招牌套餐，炸酱意大利面吧，我要一个大碗的。”大明于是对服务员说：“要两个大碗的炸酱意大利面，给我拿两头蒜。”</p>\n<p>然后大明转头对小明说道：“今天真是触霉头，好点的饭店竟然都被婚礼给独占了。”小明便说：“没关系，自旋锁嘛，都是互斥的，他们占了，我们就进不去，不过我们就不等了，直接换一家吃，我看炸酱意大利面也不错。”</p>\n<p>大明说道：“说到这里，我们不妨再介绍一下PostgreSQL中的轻量锁，这是一种有共享精神的锁。”</p>\n<p>”轻量锁？让我想想，我好想听说过这种类型的锁，它和自旋锁不同，它一般用于保护PostgreSQL中对共享内存的操作吧，它是一种读写锁吧？“</p>\n<p><strong>读写锁</strong></p>\n<p>”是的。“大明边点头便说：”轻量锁把锁分成了读锁和写锁，读锁只读取访问资源，因此是可以共享的，也就是说可以有多个进程同时读共享资源，而写锁则是排它的，因为写锁的持有者要修改共享资源中的内容，它的锁相容矩阵是这样的。“说着，大明蘸了点茶水，在桌面上画出了轻量锁的相容矩阵。</p>\n<table>\n<thead>\n<tr>\n<th>锁类型</th>\n<th align=\"right\">读锁</th>\n<th align=\"center\">写锁</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>读锁</td>\n<td align=\"right\">O</td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td>写锁</td>\n<td align=\"right\">X</td>\n<td align=\"center\">X</td>\n</tr>\n</tbody></table>\n<p>“你看，这其中O就代表相容，X就代表互斥。”大明边画边说。<br>小明看着桌面上渐渐淡去的水痕，若有所思的说道：”这种锁的出现就是为了提高并发度，因为读和读是相容的。它和自旋锁是的不同在于，自旋锁是互斥锁，一旦锁定了临界区，其他访问者就只能等了。它是没有等级概念的，就只有互斥一种情况，而轻量锁把对共享资源的访问划分成了2个等级，一个等级是读，一个等级是写，这样锁的粒度就更细了。”</p>\n<p>大明点了点头说道：“说得好，但我们还是尽量不要把轻量锁和自旋锁混为一谈，它们的目的不同，实际上在早期的PostgreSQL中，轻量锁是借助自旋锁实现的。”</p>\n<p>小明惊奇道：“借助自旋锁实现的?”</p>\n<p>“嗯，我们在实现自旋锁的时候，借助CPU提供的原语实现了对一个共享变量的原子操作，所以我们就可以根据这个共享变量的状态来决定我们是不是可以进入临界区。”大明停顿了一下，然后继续说：“轻量锁的实现也无外乎如此，只不过它的状态多了，用一个变量不好保存，于是就用自旋锁来实现对这些变量的保护。”</p>\n<p>小明点点头说道：“嗯，在讲解自旋锁的时候你曾经说过，自旋锁一般只保护很小的临界区，所以可以忙等，也就是说用自旋锁来实现轻量锁的时候，保护共享状态的临界区也一定非常小，不然就没有办法用自旋锁来实现轻量锁了吧。”</p>\n<p><strong>事情发生了变化</strong></p>\n<p>大明皱了皱眉说道：“是的，也正因为如此，事情已经发生变化，我们以前可以说PostgreSQL用自旋锁来实现了轻量锁，但是现在不能这么说了。”</p>\n<p>“为什么？”</p>\n<p>“在之前的PostgreSQL版本中，轻量锁的锁结构中有几个变量用来记录当前锁的状态，比如，共享锁可以由多个访问者共享，我们就可以用一个变量来记录目前有多少个访问者共享这个锁，比如排它锁具有互斥性，我们就采用一个变量来标识当前谁获得了排它锁。最终根据这些状态就可以判断新的访问者是否可以获得锁，但这里有两个问题。”大明停顿了一下，继续说道：“一个问题是轻量锁的获取和释放特别频繁，另一个问题是这次自旋锁保护的临界区有点大了，把这两个问题综合到一起就是：这里用自旋锁保护临界区，降低了PostgreSQL的性能。”</p>\n<p>“我听你刚才说的，好像是有点浪费，比如排它锁的状态吧，我们只需要一个0和1的状态就可以了，用一个字节来标识都嫌多，而共享锁的计数我想也不会达到2^32次方，所以用一个4字节的int来表示，也完全是一种浪费，我看可以把这些状态用bit位来标识，完全就可以了。”小明略有所思的说道。</p>\n<p>大明赞赏的说：“完全正确。”</p>\n<p>这时候服务员把炸酱意大利面已经端上来了，两个人顾不上再接着说轻量锁，开始吃起来，小明一边吃一边想怎么合理的分配轻量锁状态的bit位，对于排它锁而言，只需要一个bit就够了，而共享锁的计数呢？需要分配多少个呢？</p>\n<p>大明快速的吃了几口面，然后用蘸着水在桌子上画了起来：“目前轻量锁状态的布局是这样的。”</p>\n<p><img src=\"/2021/07/20/postgresql-lock-lwlock-implement/lockstate.jpg\"> </p>\n<p>小明赞许的说：“嗯，用24个bit位做计数，应该是够多了。现在都喜欢用无锁编程，那么这么一个变量的保护也就没有必要再使用自旋锁来保护了，只要自己实现一个CAS的原语就够了。”</p>\n<p>“对，正是这样实现的，这样就解决了并发的问题。”</p>\n<p><strong>保护的也不大</strong></p>\n<p>小明想了想，继续说道：“那既然已经不用自旋锁实现轻量锁了，那自旋锁是不是就快要退休了呢？”</p>\n<p>大明啃了一口大蒜然后说道：“或许吧，但目前自旋锁还是有些用处的，现在说要退休还为时尚早。而轻量锁呢，也有它自己的问题，它之所以叫轻量锁，原因就是它也期望自己保护的临界区不太‘大’，虽然未必如自旋锁那样，只需要很少的CPU时钟周期，但如果轻量锁保护的临界区太复杂，仍然可能带来性能问题。我就曾经犯过一个错误，在轻量锁保护的临界区中加入了太多的新代码，最终导致数据库连接不上。。。”</p>\n<p>“可是，轻量锁中不是有读锁吗，那还不够吗？”</p>\n<p>“PostgreSQL中写共享内存状态的情况也不少，因此并不是把锁的状态分离成两个等级之后就能解决一切问题，写-写之间、写-读之间仍然是互斥的，所以使用轻量锁的时候仍然要谨记，轻量锁保护的区间不能太大。这就好像旅游区的公厕一样，虽然你独占了马桶，但是请快速解决问题，不然外边的等待队列太长，也会造成拥堵。”</p>\n<p>听大明说起了旅游区的马桶，小明顿时觉得口中的面难以下咽，于是问道：”嗯？轻量锁还会排队，看来这和自旋锁不一样，自旋锁好像没有等待队列嗳？”</p>\n<p><strong>等待队列</strong></p>\n<p>大明吃了一口面继续说道：“嗯，确实是这样，自旋锁是没有队列的，但是轻量锁有等待队列。比如，现在有进程已经以共享状态持有了一个轻量锁，那么想要持有互斥锁的进程肯定是只能进等待队列了。”</p>\n<p>“如果这时候又来一个进程想要持有共享锁呢？是讲究先来后到的进入等待队列，还是直接获得共享锁？”</p>\n<p>“嗯，好问题，这就是轻量锁和常规锁的不同。”</p>\n<p>“常规锁？”</p>\n<p>“就是表级锁啊，轻量锁在这种情况下，共享锁就可以直接获取了，但是常规锁可能就需要进等待队列喽！”</p>\n<p><img src=\"/2021/07/20/postgresql-lock-lwlock-implement/sxlock.jpg\"> </p>\n<p><strong>唤醒</strong></p>\n<p>这时店外进来一个高大的身影，胡茬唏嘘，格子衬衣，小明远远看去似曾相识，于是向大明问道：“那刚进来的人可是牛二哥？”大明转头一看，果然是牛二哥，于是起身招呼道：“老牛，你怎么也到这里才吃面了，过来我们同坐一桌吧。”牛二哥看是大明和小明，非常高兴，于是像小明问道：“小兄弟，上次我和大明给你讲的查询优化你还记得吧？”</p>\n<p>小明忙说：“记得记得，我现在已经获得了我们宿舍的‘优化器小能手’称号，我明天就去买个奖状挂起来。不过今天大明哥正给我讲轻量锁呢，牛二哥来吧，咱们3个都是申请读锁的，可以同坐一桌。”</p>\n<p>牛二哥笑着坐在小明旁边，对服务员说：“给我一碗刀削意大利面。”然后转过头说：“我刚才在商业街转了几个圈，一个空位都没找到，就想起来这里有个面馆，于是就过来了。”</p>\n<p>小明说：“嗯，看来还是轻量锁好，读锁可以相容，不像自旋锁，自己占着CPU原地打转。”小明一边说一边用手在桌上画了几个圈。</p>\n<p>牛二哥说：“嗯，不过我们这些读锁已经占领了这个桌子，如果有写锁想来独占，也需要等我们走了才行，我们和他们不相容啊。”<br>小明想了想顿时领悟，如果此时有人以读锁申请轻量锁，而我们申请的也是读锁，自然是可以直接获得锁的，而如果我们申请的是写锁，那么就肯定只能等待了。但是如果现在有人以写锁持有轻量锁，那么无论是新来的读锁还是写锁，都需要进入等待队列，想到此处小明不禁发问道：“那如果持有锁的人释放了锁，我们应该以什么顺序唤醒等待队列里的锁呢？”</p>\n<p>牛二哥想了想，说：“嗯，那要看排在第一个的是什么锁，如果排在第一个的是写锁，那么就直接唤醒这个写锁，如果排在第一个的是读锁，那么就唤醒等待队列中所有的读锁，而忽略等待队列中的写锁，就像这样。。。”说着，牛二哥在桌上画了起来。</p>\n<p><img src=\"/2021/07/20/postgresql-lock-lwlock-implement/waitqueue.jpg\"> </p>\n<p><strong>小结</strong></p>\n<p>看着牛二哥在桌上的等待队列唤醒图，小明觉得应该对轻量锁有了一个基本的了解，但是突然萌发了一个想法：刚才大明说过常规锁，那又是怎样实现的呢？于是便问牛二哥：“那常规锁有没有等待队列？”牛二哥愣了一下，突然大笑道：“不急不急，最近有本新书《PostgreSQL技术内幕：事务处理深度探索》已经上市了，里面啥都有，我们吃完去书店看看吧。”<br>大明和小明点头道：“正有此意，同去同去。”</p>\n<p>这时服务员把牛二哥的面已经端上来了，于是三个人又开始边吃边聊一些业内的八卦，老约翰炸酱面馆中又恢复了活泼的气氛。</p>\n","site":{"data":{}},"excerpt":"<p>大明与小明聊完了自旋锁，已是中午时分，大明突然想到最近有一本讲解事务处理的新书要上市，正好包含要讲给小明的自旋锁、轻量锁、常规锁等内容，于是对小明说：“最近上市了一本新书，叫<strong>《PostgreSQL技术内幕：事务处理深度探索》</strong>，是<strong>《PostgreSQL技术内幕：查询优化深度探索》</strong>的姊妹篇，恰好有你想要学习的内容，我们不妨去附近的书店看看。”</p>\n<p>经过一上午的讲解，小明已经精疲力尽，腹中隆隆作响，大明不由笑道：“咱们还是先饱餐战饭，然后再去书店吧。”</p>\n<p>小明揉揉肚子，确实已经是饥肠辘辘，便笑道：”免不了又让你破费。“</p>","more":"<p>大明从沙发上弹起身子，边穿外衣边道：”附近美食颇多，沙县料理、成都七星酒店都不错，我们还是边走边看吧。“</p>\n<p>大明家附近不远恰有一条商业街，周末时间的中午，商业街上熙熙攘攘，人流穿梭，附近的酒店竟然纷纷排起队来，还有一些酒店已经被婚礼包场，加长的婚车路过商业街，自是热闹非常。大明和小明先是来到沙县料理，发现已被婚礼包场，然后又到了成都七星酒店，结果店外排队等候的宾客自觉地排起了一条长龙，不免有些扫兴。</p>\n<p>大明提议道：”我知道此处角落有一家小吃，店家虽小，但味道不错，不如前去一试。“于是二人穿梭进商业街角落的一个小巷，七拐八拐，终于来到一家小店门前，店面虽小，但看上去整洁干净，装修古朴，大大的招牌上写着鎏金的的店名：老约翰炸酱面馆。不过店面在商业街外的角落中，店中的客人不多，仍有余位，二人便找了一个不错的位置坐下了。</p>\n<p>小明拿起菜单笑道：”没想到这小小的角落中竟卧虎藏龙，不如就吃他们这里的招牌套餐，炸酱意大利面吧，我要一个大碗的。”大明于是对服务员说：“要两个大碗的炸酱意大利面，给我拿两头蒜。”</p>\n<p>然后大明转头对小明说道：“今天真是触霉头，好点的饭店竟然都被婚礼给独占了。”小明便说：“没关系，自旋锁嘛，都是互斥的，他们占了，我们就进不去，不过我们就不等了，直接换一家吃，我看炸酱意大利面也不错。”</p>\n<p>大明说道：“说到这里，我们不妨再介绍一下PostgreSQL中的轻量锁，这是一种有共享精神的锁。”</p>\n<p>”轻量锁？让我想想，我好想听说过这种类型的锁，它和自旋锁不同，它一般用于保护PostgreSQL中对共享内存的操作吧，它是一种读写锁吧？“</p>\n<p><strong>读写锁</strong></p>\n<p>”是的。“大明边点头便说：”轻量锁把锁分成了读锁和写锁，读锁只读取访问资源，因此是可以共享的，也就是说可以有多个进程同时读共享资源，而写锁则是排它的，因为写锁的持有者要修改共享资源中的内容，它的锁相容矩阵是这样的。“说着，大明蘸了点茶水，在桌面上画出了轻量锁的相容矩阵。</p>\n<table>\n<thead>\n<tr>\n<th>锁类型</th>\n<th align=\"right\">读锁</th>\n<th align=\"center\">写锁</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>读锁</td>\n<td align=\"right\">O</td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td>写锁</td>\n<td align=\"right\">X</td>\n<td align=\"center\">X</td>\n</tr>\n</tbody></table>\n<p>“你看，这其中O就代表相容，X就代表互斥。”大明边画边说。<br>小明看着桌面上渐渐淡去的水痕，若有所思的说道：”这种锁的出现就是为了提高并发度，因为读和读是相容的。它和自旋锁是的不同在于，自旋锁是互斥锁，一旦锁定了临界区，其他访问者就只能等了。它是没有等级概念的，就只有互斥一种情况，而轻量锁把对共享资源的访问划分成了2个等级，一个等级是读，一个等级是写，这样锁的粒度就更细了。”</p>\n<p>大明点了点头说道：“说得好，但我们还是尽量不要把轻量锁和自旋锁混为一谈，它们的目的不同，实际上在早期的PostgreSQL中，轻量锁是借助自旋锁实现的。”</p>\n<p>小明惊奇道：“借助自旋锁实现的?”</p>\n<p>“嗯，我们在实现自旋锁的时候，借助CPU提供的原语实现了对一个共享变量的原子操作，所以我们就可以根据这个共享变量的状态来决定我们是不是可以进入临界区。”大明停顿了一下，然后继续说：“轻量锁的实现也无外乎如此，只不过它的状态多了，用一个变量不好保存，于是就用自旋锁来实现对这些变量的保护。”</p>\n<p>小明点点头说道：“嗯，在讲解自旋锁的时候你曾经说过，自旋锁一般只保护很小的临界区，所以可以忙等，也就是说用自旋锁来实现轻量锁的时候，保护共享状态的临界区也一定非常小，不然就没有办法用自旋锁来实现轻量锁了吧。”</p>\n<p><strong>事情发生了变化</strong></p>\n<p>大明皱了皱眉说道：“是的，也正因为如此，事情已经发生变化，我们以前可以说PostgreSQL用自旋锁来实现了轻量锁，但是现在不能这么说了。”</p>\n<p>“为什么？”</p>\n<p>“在之前的PostgreSQL版本中，轻量锁的锁结构中有几个变量用来记录当前锁的状态，比如，共享锁可以由多个访问者共享，我们就可以用一个变量来记录目前有多少个访问者共享这个锁，比如排它锁具有互斥性，我们就采用一个变量来标识当前谁获得了排它锁。最终根据这些状态就可以判断新的访问者是否可以获得锁，但这里有两个问题。”大明停顿了一下，继续说道：“一个问题是轻量锁的获取和释放特别频繁，另一个问题是这次自旋锁保护的临界区有点大了，把这两个问题综合到一起就是：这里用自旋锁保护临界区，降低了PostgreSQL的性能。”</p>\n<p>“我听你刚才说的，好像是有点浪费，比如排它锁的状态吧，我们只需要一个0和1的状态就可以了，用一个字节来标识都嫌多，而共享锁的计数我想也不会达到2^32次方，所以用一个4字节的int来表示，也完全是一种浪费，我看可以把这些状态用bit位来标识，完全就可以了。”小明略有所思的说道。</p>\n<p>大明赞赏的说：“完全正确。”</p>\n<p>这时候服务员把炸酱意大利面已经端上来了，两个人顾不上再接着说轻量锁，开始吃起来，小明一边吃一边想怎么合理的分配轻量锁状态的bit位，对于排它锁而言，只需要一个bit就够了，而共享锁的计数呢？需要分配多少个呢？</p>\n<p>大明快速的吃了几口面，然后用蘸着水在桌子上画了起来：“目前轻量锁状态的布局是这样的。”</p>\n<p><img src=\"/2021/07/20/postgresql-lock-lwlock-implement/lockstate.jpg\"> </p>\n<p>小明赞许的说：“嗯，用24个bit位做计数，应该是够多了。现在都喜欢用无锁编程，那么这么一个变量的保护也就没有必要再使用自旋锁来保护了，只要自己实现一个CAS的原语就够了。”</p>\n<p>“对，正是这样实现的，这样就解决了并发的问题。”</p>\n<p><strong>保护的也不大</strong></p>\n<p>小明想了想，继续说道：“那既然已经不用自旋锁实现轻量锁了，那自旋锁是不是就快要退休了呢？”</p>\n<p>大明啃了一口大蒜然后说道：“或许吧，但目前自旋锁还是有些用处的，现在说要退休还为时尚早。而轻量锁呢，也有它自己的问题，它之所以叫轻量锁，原因就是它也期望自己保护的临界区不太‘大’，虽然未必如自旋锁那样，只需要很少的CPU时钟周期，但如果轻量锁保护的临界区太复杂，仍然可能带来性能问题。我就曾经犯过一个错误，在轻量锁保护的临界区中加入了太多的新代码，最终导致数据库连接不上。。。”</p>\n<p>“可是，轻量锁中不是有读锁吗，那还不够吗？”</p>\n<p>“PostgreSQL中写共享内存状态的情况也不少，因此并不是把锁的状态分离成两个等级之后就能解决一切问题，写-写之间、写-读之间仍然是互斥的，所以使用轻量锁的时候仍然要谨记，轻量锁保护的区间不能太大。这就好像旅游区的公厕一样，虽然你独占了马桶，但是请快速解决问题，不然外边的等待队列太长，也会造成拥堵。”</p>\n<p>听大明说起了旅游区的马桶，小明顿时觉得口中的面难以下咽，于是问道：”嗯？轻量锁还会排队，看来这和自旋锁不一样，自旋锁好像没有等待队列嗳？”</p>\n<p><strong>等待队列</strong></p>\n<p>大明吃了一口面继续说道：“嗯，确实是这样，自旋锁是没有队列的，但是轻量锁有等待队列。比如，现在有进程已经以共享状态持有了一个轻量锁，那么想要持有互斥锁的进程肯定是只能进等待队列了。”</p>\n<p>“如果这时候又来一个进程想要持有共享锁呢？是讲究先来后到的进入等待队列，还是直接获得共享锁？”</p>\n<p>“嗯，好问题，这就是轻量锁和常规锁的不同。”</p>\n<p>“常规锁？”</p>\n<p>“就是表级锁啊，轻量锁在这种情况下，共享锁就可以直接获取了，但是常规锁可能就需要进等待队列喽！”</p>\n<p><img src=\"/2021/07/20/postgresql-lock-lwlock-implement/sxlock.jpg\"> </p>\n<p><strong>唤醒</strong></p>\n<p>这时店外进来一个高大的身影，胡茬唏嘘，格子衬衣，小明远远看去似曾相识，于是向大明问道：“那刚进来的人可是牛二哥？”大明转头一看，果然是牛二哥，于是起身招呼道：“老牛，你怎么也到这里才吃面了，过来我们同坐一桌吧。”牛二哥看是大明和小明，非常高兴，于是像小明问道：“小兄弟，上次我和大明给你讲的查询优化你还记得吧？”</p>\n<p>小明忙说：“记得记得，我现在已经获得了我们宿舍的‘优化器小能手’称号，我明天就去买个奖状挂起来。不过今天大明哥正给我讲轻量锁呢，牛二哥来吧，咱们3个都是申请读锁的，可以同坐一桌。”</p>\n<p>牛二哥笑着坐在小明旁边，对服务员说：“给我一碗刀削意大利面。”然后转过头说：“我刚才在商业街转了几个圈，一个空位都没找到，就想起来这里有个面馆，于是就过来了。”</p>\n<p>小明说：“嗯，看来还是轻量锁好，读锁可以相容，不像自旋锁，自己占着CPU原地打转。”小明一边说一边用手在桌上画了几个圈。</p>\n<p>牛二哥说：“嗯，不过我们这些读锁已经占领了这个桌子，如果有写锁想来独占，也需要等我们走了才行，我们和他们不相容啊。”<br>小明想了想顿时领悟，如果此时有人以读锁申请轻量锁，而我们申请的也是读锁，自然是可以直接获得锁的，而如果我们申请的是写锁，那么就肯定只能等待了。但是如果现在有人以写锁持有轻量锁，那么无论是新来的读锁还是写锁，都需要进入等待队列，想到此处小明不禁发问道：“那如果持有锁的人释放了锁，我们应该以什么顺序唤醒等待队列里的锁呢？”</p>\n<p>牛二哥想了想，说：“嗯，那要看排在第一个的是什么锁，如果排在第一个的是写锁，那么就直接唤醒这个写锁，如果排在第一个的是读锁，那么就唤醒等待队列中所有的读锁，而忽略等待队列中的写锁，就像这样。。。”说着，牛二哥在桌上画了起来。</p>\n<p><img src=\"/2021/07/20/postgresql-lock-lwlock-implement/waitqueue.jpg\"> </p>\n<p><strong>小结</strong></p>\n<p>看着牛二哥在桌上的等待队列唤醒图，小明觉得应该对轻量锁有了一个基本的了解，但是突然萌发了一个想法：刚才大明说过常规锁，那又是怎样实现的呢？于是便问牛二哥：“那常规锁有没有等待队列？”牛二哥愣了一下，突然大笑道：“不急不急，最近有本新书《PostgreSQL技术内幕：事务处理深度探索》已经上市了，里面啥都有，我们吃完去书店看看吧。”<br>大明和小明点头道：“正有此意，同去同去。”</p>\n<p>这时服务员把牛二哥的面已经端上来了，于是三个人又开始边吃边聊一些业内的八卦，老约翰炸酱面馆中又恢复了活泼的气氛。</p>"},{"title":"【置顶】《PostgreSQL技术内幕：事务处理深度探索》上市了！","date":"2021-08-02T13:40:29.000Z","top":1,"_content":"\n\n\n[京东地址](https://item.jd.com/12898593.html)  \n[当当地址](http://product.dangdang.com/29277465.html)  \n[淘宝地址](https://detail.tmall.com/item.htm?spm=a1z10.3-b-s.w4011-22119638442.37.798d1b8b6TlJDS&id=651820819927&rn=215b8c029b06d654c30a5777273c979e&abbucket=1) \n\n![](./postgresql-transaction-internals-introduce/introduce.jpg) \n\n<!--more-->\n\n**为什么写这本书？**\n\n近年来，我一直从事与PostgreSQL相关的数据库内核开发工作，主攻方向是SQL引擎中的查询优化，对事务的了解仅停留在理论层面，虽然对事务的性质、隔离级别也能讲一番大道理，但终究华而不实，于探究事务的本质无益。所谓“纸上得来终觉浅，绝知此事要躬行”，在完成了《PostgreSQL技术内幕：查询优化深度探索》一书之后，我就开始了事务的探索之旅。\n\n探索的过程并非一帆风顺。事务的理论已经颇为复杂，在形成源代码之后更是有数十万行之多，对这些源代码做逐行分析的工作量非常大，一旦遇到不解的问题，还需查阅资料、翻阅讨论组中的邮件。入之愈深，其进愈难，则其见愈奇。以前根据事务理论想当然的一些理解会被具体实现中的精巧设计打破，而对这些设计细节的深刻理解能帮助我们快速地解决工作中遇到的问题，因此，我又产生了写第二本书的想法，希望对自己在探索过程中遇到的知识点做一个总结与分享。\n\n\n**为什么阅读这本书？**\n\n事务是关系数据库中最重要的内容之一，无论是对数据库内核进行开发，还是在数据库的基础上进行应用程序的开发，都需要对事务有深入的了解。本书细致地解读了PostgreSQL 数据库中与事务相关的大部分源码，对其中比较重要的理论给出了说明，相信已经足以让读者了解PostgreSQL中事务的全貌。\n\n\n\n**本书的组织结构**\n\n本书在章节的排布上可以分为两个部分：\n\n•基础篇（第1~4章）：主要介绍了事务的基本概念、并发控制的实现方法和故障恢复的实现方法；\n\n•进阶篇（第5~9章）：在事务理论的基础上，对物理复制、逻辑复制、SSI实现、新型Zheap引擎、2PC做了深入的解读。\n\n由于事务引擎和存储引擎关系密切，本书在附录中对存储引擎的一些知识点也做了相关介绍，方便读者加深理解。\n\n**纠错**\n\n在写作的过程中，我尝试尽量多地查阅相关资料，但限于作者的能力，书中难免出现一些错误，欢迎广大读者对本书提出批评和意见，这也有益于作者本身能力的提升。\n\n**致谢**\n\n孟庆钟博士和周兆琦博士通过视频会议的方式逐字逐句地审阅了书稿，多次批改书稿到深夜，提出了很多有益的意见，感谢二位辛苦的付出。\n\n本书是第二次和董英编辑合作，得到了董英编辑的大力支持，在此表示感谢。\n  \n李秀梅编辑是本书的责任编辑，在书稿写作过程中，秀梅编辑不厌其烦地解答了我很多问题，对我的拖稿行为也给予了极大的理解，感谢秀梅编辑。\n\n感谢我的父母、妻子，书稿的创作过程枯燥而冗长，占用了很多生活的时间，他们承担了所有的家务，为我提供了最好的写作环境。\n\n我的两个儿子也非常关心我的写作进度，经常询问我什么时候完成创作，并在我创作的过程中纠正了一些错别字，在此一并表示感谢。\n\n","source":"_posts/postgresql-transaction-internals-introduce.md","raw":"---\ntitle: 【置顶】《PostgreSQL技术内幕：事务处理深度探索》上市了！\ndate: 2021-08-02 21:40:29\ntop: 1\ntags: transaction 事务 新书 技术内幕 PostgreSQL\n---\n\n\n\n[京东地址](https://item.jd.com/12898593.html)  \n[当当地址](http://product.dangdang.com/29277465.html)  \n[淘宝地址](https://detail.tmall.com/item.htm?spm=a1z10.3-b-s.w4011-22119638442.37.798d1b8b6TlJDS&id=651820819927&rn=215b8c029b06d654c30a5777273c979e&abbucket=1) \n\n![](./postgresql-transaction-internals-introduce/introduce.jpg) \n\n<!--more-->\n\n**为什么写这本书？**\n\n近年来，我一直从事与PostgreSQL相关的数据库内核开发工作，主攻方向是SQL引擎中的查询优化，对事务的了解仅停留在理论层面，虽然对事务的性质、隔离级别也能讲一番大道理，但终究华而不实，于探究事务的本质无益。所谓“纸上得来终觉浅，绝知此事要躬行”，在完成了《PostgreSQL技术内幕：查询优化深度探索》一书之后，我就开始了事务的探索之旅。\n\n探索的过程并非一帆风顺。事务的理论已经颇为复杂，在形成源代码之后更是有数十万行之多，对这些源代码做逐行分析的工作量非常大，一旦遇到不解的问题，还需查阅资料、翻阅讨论组中的邮件。入之愈深，其进愈难，则其见愈奇。以前根据事务理论想当然的一些理解会被具体实现中的精巧设计打破，而对这些设计细节的深刻理解能帮助我们快速地解决工作中遇到的问题，因此，我又产生了写第二本书的想法，希望对自己在探索过程中遇到的知识点做一个总结与分享。\n\n\n**为什么阅读这本书？**\n\n事务是关系数据库中最重要的内容之一，无论是对数据库内核进行开发，还是在数据库的基础上进行应用程序的开发，都需要对事务有深入的了解。本书细致地解读了PostgreSQL 数据库中与事务相关的大部分源码，对其中比较重要的理论给出了说明，相信已经足以让读者了解PostgreSQL中事务的全貌。\n\n\n\n**本书的组织结构**\n\n本书在章节的排布上可以分为两个部分：\n\n•基础篇（第1~4章）：主要介绍了事务的基本概念、并发控制的实现方法和故障恢复的实现方法；\n\n•进阶篇（第5~9章）：在事务理论的基础上，对物理复制、逻辑复制、SSI实现、新型Zheap引擎、2PC做了深入的解读。\n\n由于事务引擎和存储引擎关系密切，本书在附录中对存储引擎的一些知识点也做了相关介绍，方便读者加深理解。\n\n**纠错**\n\n在写作的过程中，我尝试尽量多地查阅相关资料，但限于作者的能力，书中难免出现一些错误，欢迎广大读者对本书提出批评和意见，这也有益于作者本身能力的提升。\n\n**致谢**\n\n孟庆钟博士和周兆琦博士通过视频会议的方式逐字逐句地审阅了书稿，多次批改书稿到深夜，提出了很多有益的意见，感谢二位辛苦的付出。\n\n本书是第二次和董英编辑合作，得到了董英编辑的大力支持，在此表示感谢。\n  \n李秀梅编辑是本书的责任编辑，在书稿写作过程中，秀梅编辑不厌其烦地解答了我很多问题，对我的拖稿行为也给予了极大的理解，感谢秀梅编辑。\n\n感谢我的父母、妻子，书稿的创作过程枯燥而冗长，占用了很多生活的时间，他们承担了所有的家务，为我提供了最好的写作环境。\n\n我的两个儿子也非常关心我的写作进度，经常询问我什么时候完成创作，并在我创作的过程中纠正了一些错别字，在此一并表示感谢。\n\n","slug":"postgresql-transaction-internals-introduce","published":1,"updated":"2021-08-05T15:58:35.000Z","_id":"ckruplv2w0000yu9k1vls2joj","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"https://item.jd.com/12898593.html\">京东地址</a><br><a href=\"http://product.dangdang.com/29277465.html\">当当地址</a><br><a href=\"https://detail.tmall.com/item.htm?spm=a1z10.3-b-s.w4011-22119638442.37.798d1b8b6TlJDS&id=651820819927&rn=215b8c029b06d654c30a5777273c979e&abbucket=1\">淘宝地址</a> </p>\n<p><img src=\"/2021/08/02/postgresql-transaction-internals-introduce/introduce.jpg\"> </p>\n<a id=\"more\"></a>\n\n<p><strong>为什么写这本书？</strong></p>\n<p>近年来，我一直从事与PostgreSQL相关的数据库内核开发工作，主攻方向是SQL引擎中的查询优化，对事务的了解仅停留在理论层面，虽然对事务的性质、隔离级别也能讲一番大道理，但终究华而不实，于探究事务的本质无益。所谓“纸上得来终觉浅，绝知此事要躬行”，在完成了《PostgreSQL技术内幕：查询优化深度探索》一书之后，我就开始了事务的探索之旅。</p>\n<p>探索的过程并非一帆风顺。事务的理论已经颇为复杂，在形成源代码之后更是有数十万行之多，对这些源代码做逐行分析的工作量非常大，一旦遇到不解的问题，还需查阅资料、翻阅讨论组中的邮件。入之愈深，其进愈难，则其见愈奇。以前根据事务理论想当然的一些理解会被具体实现中的精巧设计打破，而对这些设计细节的深刻理解能帮助我们快速地解决工作中遇到的问题，因此，我又产生了写第二本书的想法，希望对自己在探索过程中遇到的知识点做一个总结与分享。</p>\n<p><strong>为什么阅读这本书？</strong></p>\n<p>事务是关系数据库中最重要的内容之一，无论是对数据库内核进行开发，还是在数据库的基础上进行应用程序的开发，都需要对事务有深入的了解。本书细致地解读了PostgreSQL 数据库中与事务相关的大部分源码，对其中比较重要的理论给出了说明，相信已经足以让读者了解PostgreSQL中事务的全貌。</p>\n<p><strong>本书的组织结构</strong></p>\n<p>本书在章节的排布上可以分为两个部分：</p>\n<p>•基础篇（第1~4章）：主要介绍了事务的基本概念、并发控制的实现方法和故障恢复的实现方法；</p>\n<p>•进阶篇（第5~9章）：在事务理论的基础上，对物理复制、逻辑复制、SSI实现、新型Zheap引擎、2PC做了深入的解读。</p>\n<p>由于事务引擎和存储引擎关系密切，本书在附录中对存储引擎的一些知识点也做了相关介绍，方便读者加深理解。</p>\n<p><strong>纠错</strong></p>\n<p>在写作的过程中，我尝试尽量多地查阅相关资料，但限于作者的能力，书中难免出现一些错误，欢迎广大读者对本书提出批评和意见，这也有益于作者本身能力的提升。</p>\n<p><strong>致谢</strong></p>\n<p>孟庆钟博士和周兆琦博士通过视频会议的方式逐字逐句地审阅了书稿，多次批改书稿到深夜，提出了很多有益的意见，感谢二位辛苦的付出。</p>\n<p>本书是第二次和董英编辑合作，得到了董英编辑的大力支持，在此表示感谢。</p>\n<p>李秀梅编辑是本书的责任编辑，在书稿写作过程中，秀梅编辑不厌其烦地解答了我很多问题，对我的拖稿行为也给予了极大的理解，感谢秀梅编辑。</p>\n<p>感谢我的父母、妻子，书稿的创作过程枯燥而冗长，占用了很多生活的时间，他们承担了所有的家务，为我提供了最好的写作环境。</p>\n<p>我的两个儿子也非常关心我的写作进度，经常询问我什么时候完成创作，并在我创作的过程中纠正了一些错别字，在此一并表示感谢。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://item.jd.com/12898593.html\">京东地址</a><br><a href=\"http://product.dangdang.com/29277465.html\">当当地址</a><br><a href=\"https://detail.tmall.com/item.htm?spm=a1z10.3-b-s.w4011-22119638442.37.798d1b8b6TlJDS&id=651820819927&rn=215b8c029b06d654c30a5777273c979e&abbucket=1\">淘宝地址</a> </p>\n<p><img src=\"/2021/08/02/postgresql-transaction-internals-introduce/introduce.jpg\"> </p>","more":"<p><strong>为什么写这本书？</strong></p>\n<p>近年来，我一直从事与PostgreSQL相关的数据库内核开发工作，主攻方向是SQL引擎中的查询优化，对事务的了解仅停留在理论层面，虽然对事务的性质、隔离级别也能讲一番大道理，但终究华而不实，于探究事务的本质无益。所谓“纸上得来终觉浅，绝知此事要躬行”，在完成了《PostgreSQL技术内幕：查询优化深度探索》一书之后，我就开始了事务的探索之旅。</p>\n<p>探索的过程并非一帆风顺。事务的理论已经颇为复杂，在形成源代码之后更是有数十万行之多，对这些源代码做逐行分析的工作量非常大，一旦遇到不解的问题，还需查阅资料、翻阅讨论组中的邮件。入之愈深，其进愈难，则其见愈奇。以前根据事务理论想当然的一些理解会被具体实现中的精巧设计打破，而对这些设计细节的深刻理解能帮助我们快速地解决工作中遇到的问题，因此，我又产生了写第二本书的想法，希望对自己在探索过程中遇到的知识点做一个总结与分享。</p>\n<p><strong>为什么阅读这本书？</strong></p>\n<p>事务是关系数据库中最重要的内容之一，无论是对数据库内核进行开发，还是在数据库的基础上进行应用程序的开发，都需要对事务有深入的了解。本书细致地解读了PostgreSQL 数据库中与事务相关的大部分源码，对其中比较重要的理论给出了说明，相信已经足以让读者了解PostgreSQL中事务的全貌。</p>\n<p><strong>本书的组织结构</strong></p>\n<p>本书在章节的排布上可以分为两个部分：</p>\n<p>•基础篇（第1~4章）：主要介绍了事务的基本概念、并发控制的实现方法和故障恢复的实现方法；</p>\n<p>•进阶篇（第5~9章）：在事务理论的基础上，对物理复制、逻辑复制、SSI实现、新型Zheap引擎、2PC做了深入的解读。</p>\n<p>由于事务引擎和存储引擎关系密切，本书在附录中对存储引擎的一些知识点也做了相关介绍，方便读者加深理解。</p>\n<p><strong>纠错</strong></p>\n<p>在写作的过程中，我尝试尽量多地查阅相关资料，但限于作者的能力，书中难免出现一些错误，欢迎广大读者对本书提出批评和意见，这也有益于作者本身能力的提升。</p>\n<p><strong>致谢</strong></p>\n<p>孟庆钟博士和周兆琦博士通过视频会议的方式逐字逐句地审阅了书稿，多次批改书稿到深夜，提出了很多有益的意见，感谢二位辛苦的付出。</p>\n<p>本书是第二次和董英编辑合作，得到了董英编辑的大力支持，在此表示感谢。</p>\n<p>李秀梅编辑是本书的责任编辑，在书稿写作过程中，秀梅编辑不厌其烦地解答了我很多问题，对我的拖稿行为也给予了极大的理解，感谢秀梅编辑。</p>\n<p>感谢我的父母、妻子，书稿的创作过程枯燥而冗长，占用了很多生活的时间，他们承担了所有的家务，为我提供了最好的写作环境。</p>\n<p>我的两个儿子也非常关心我的写作进度，经常询问我什么时候完成创作，并在我创作的过程中纠正了一些错别字，在此一并表示感谢。</p>"},{"title":"让数据库从业者从实力的地位出发对美国说不！","date":"2021-08-05T15:31:43.000Z","_content":"\n[京东地址](https://item.jd.com/12898593.html)  \n[当当地址](http://product.dangdang.com/29277465.html)  \n[淘宝地址](https://detail.tmall.com/item.htm?spm=a1z10.3-b-s.w4011-22119638442.37.798d1b8b6TlJDS&id=651820819927&rn=215b8c029b06d654c30a5777273c979e&abbucket=1) \n\n![](./database-developer-say-no-to-us/buy_link.jpeg) \n\n几十年来，国外数据库巨头凭借先发优势形成的技术壁垒和理论壁垒垄断了数据库市场，卡住了中国乃至世界的脖子，《科技日报》曾推出系列文章报道制约我国工业发展的35项“卡脖子”技术，数据库管理系统就是其中的一项。虽然国产数据库近些年蓬勃发展，但只能在在周边领域打转，在金融关键核心系统上则屡败屡战，未尝一胜。\n\n**这其中的关键原因不难理解：技术不行。**\n\n<img src=\"./database-developer-say-no-to-us/have_no_tech.jpeg\" width=\"200\">\n \n<!--more-->\n \n数据库的两个关键指标是**“快”**和**“稳”**。其中“快”由优化器负责，它通过对用户输入查询进行代数优化、代价优化从而选择多快好省的执行路径；而“稳”则主要由事务负责，它通过并发控制和故障恢复理论保证数据库在执行的过程中满足原子性、一致性、隔离性、持久性，保证数据的不错不丢。\n\n无论是查询优化技术，还是事务处理技术，国产数据库和国外数据库巨头之间都有不小的差距，现在仍处于模仿中的技术创新阶段，少有真正原创的核心技术。一方面，随着云计算、大数据、互联网金融等信息技术的不断发展，对数据库等基础核心软件的要求越来越高，另一方面，国产数据库则后劲乏力、缺乏积极进取的精神，虽落后于世界但仍沾沾自喜。\n\n因此，当前数据库发展的主要矛盾就变成：**核心应用软件对数据库日益提高的性能、稳定、安全的需求和落后的国产数据库技术之间的矛盾。**\n\n2019年始，以美国为首的一些发达国家开始了对中国发展的围追堵截，中华民族又到了最危险的时候，此诚危急存亡之秋也。作为数据库的从业者自然也应该肩负责任、奋发图强、迎头赶上，撸起袖子加油干。\n\nPostgreSQL数据库作为世界上最先进的开源数据库，秉承了开源的开放奉献、追求进步的精神，不受控于任何公司、国家，是我们良师益友，全面的掌握PostgreSQL则有助于我们的发展和进步。\n\n2018年，电子工业出版社出版了《PostgreSQL技术内幕：查询优化深度探索》一书，已经对数据库中的“快”技术做了深度的剖析，帮助大量的数据库爱好者更深入的了解了数据库查询优化器的技术实现方法，让很多人对优化器有了更深层次的了解。\n\n2021年，应对数据库“稳”技术的《PostgreSQL技术内幕：事务处理深度探索》也将上市，为数据库的从业者提供充分的补给。本书分析了PostgreSQL数据库事务的实现机制，包括事务的基本概念、两阶段锁的原理及实现方法、多版本并发控制的原理及实现方法、故障恢复的实现方法等，然后通过介绍物理复制、逻辑复制、Zheap引擎的原理及实现、SSI的实现、两阶段提交的原理及实现增强读者对事务更深入的理解，从而使读者既能了解事务的原理，也能清楚事务的实现细节。\n\n\n\n相信《PostgreSQL技术内幕》系列丛书能够抛砖引玉，让越来越多的中华儿女投身到数据库内核事业中来，让越来越多的数据库从业者分享出自己的心得和理解，让越来越多的国产数据库能够屹立于世界之林。\n\n**男儿不展风云志，空负天生八尺躯，数据库从业者们，奋斗吧。**\n","source":"_posts/database-developer-say-no-to-us.md","raw":"---\ntitle: 让数据库从业者从实力的地位出发对美国说不！\ndate: 2021-08-05 23:31:43\ntags: database transaction\n---\n\n[京东地址](https://item.jd.com/12898593.html)  \n[当当地址](http://product.dangdang.com/29277465.html)  \n[淘宝地址](https://detail.tmall.com/item.htm?spm=a1z10.3-b-s.w4011-22119638442.37.798d1b8b6TlJDS&id=651820819927&rn=215b8c029b06d654c30a5777273c979e&abbucket=1) \n\n![](./database-developer-say-no-to-us/buy_link.jpeg) \n\n几十年来，国外数据库巨头凭借先发优势形成的技术壁垒和理论壁垒垄断了数据库市场，卡住了中国乃至世界的脖子，《科技日报》曾推出系列文章报道制约我国工业发展的35项“卡脖子”技术，数据库管理系统就是其中的一项。虽然国产数据库近些年蓬勃发展，但只能在在周边领域打转，在金融关键核心系统上则屡败屡战，未尝一胜。\n\n**这其中的关键原因不难理解：技术不行。**\n\n<img src=\"./database-developer-say-no-to-us/have_no_tech.jpeg\" width=\"200\">\n \n<!--more-->\n \n数据库的两个关键指标是**“快”**和**“稳”**。其中“快”由优化器负责，它通过对用户输入查询进行代数优化、代价优化从而选择多快好省的执行路径；而“稳”则主要由事务负责，它通过并发控制和故障恢复理论保证数据库在执行的过程中满足原子性、一致性、隔离性、持久性，保证数据的不错不丢。\n\n无论是查询优化技术，还是事务处理技术，国产数据库和国外数据库巨头之间都有不小的差距，现在仍处于模仿中的技术创新阶段，少有真正原创的核心技术。一方面，随着云计算、大数据、互联网金融等信息技术的不断发展，对数据库等基础核心软件的要求越来越高，另一方面，国产数据库则后劲乏力、缺乏积极进取的精神，虽落后于世界但仍沾沾自喜。\n\n因此，当前数据库发展的主要矛盾就变成：**核心应用软件对数据库日益提高的性能、稳定、安全的需求和落后的国产数据库技术之间的矛盾。**\n\n2019年始，以美国为首的一些发达国家开始了对中国发展的围追堵截，中华民族又到了最危险的时候，此诚危急存亡之秋也。作为数据库的从业者自然也应该肩负责任、奋发图强、迎头赶上，撸起袖子加油干。\n\nPostgreSQL数据库作为世界上最先进的开源数据库，秉承了开源的开放奉献、追求进步的精神，不受控于任何公司、国家，是我们良师益友，全面的掌握PostgreSQL则有助于我们的发展和进步。\n\n2018年，电子工业出版社出版了《PostgreSQL技术内幕：查询优化深度探索》一书，已经对数据库中的“快”技术做了深度的剖析，帮助大量的数据库爱好者更深入的了解了数据库查询优化器的技术实现方法，让很多人对优化器有了更深层次的了解。\n\n2021年，应对数据库“稳”技术的《PostgreSQL技术内幕：事务处理深度探索》也将上市，为数据库的从业者提供充分的补给。本书分析了PostgreSQL数据库事务的实现机制，包括事务的基本概念、两阶段锁的原理及实现方法、多版本并发控制的原理及实现方法、故障恢复的实现方法等，然后通过介绍物理复制、逻辑复制、Zheap引擎的原理及实现、SSI的实现、两阶段提交的原理及实现增强读者对事务更深入的理解，从而使读者既能了解事务的原理，也能清楚事务的实现细节。\n\n\n\n相信《PostgreSQL技术内幕》系列丛书能够抛砖引玉，让越来越多的中华儿女投身到数据库内核事业中来，让越来越多的数据库从业者分享出自己的心得和理解，让越来越多的国产数据库能够屹立于世界之林。\n\n**男儿不展风云志，空负天生八尺躯，数据库从业者们，奋斗吧。**\n","slug":"database-developer-say-no-to-us","published":1,"updated":"2021-08-05T16:01:00.000Z","_id":"ckrz3bn0k0000wx9k0u1o0cuc","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"https://item.jd.com/12898593.html\">京东地址</a><br><a href=\"http://product.dangdang.com/29277465.html\">当当地址</a><br><a href=\"https://detail.tmall.com/item.htm?spm=a1z10.3-b-s.w4011-22119638442.37.798d1b8b6TlJDS&id=651820819927&rn=215b8c029b06d654c30a5777273c979e&abbucket=1\">淘宝地址</a> </p>\n<p><img src=\"/2021/08/05/database-developer-say-no-to-us/buy_link.jpeg\"> </p>\n<p>几十年来，国外数据库巨头凭借先发优势形成的技术壁垒和理论壁垒垄断了数据库市场，卡住了中国乃至世界的脖子，《科技日报》曾推出系列文章报道制约我国工业发展的35项“卡脖子”技术，数据库管理系统就是其中的一项。虽然国产数据库近些年蓬勃发展，但只能在在周边领域打转，在金融关键核心系统上则屡败屡战，未尝一胜。</p>\n<p><strong>这其中的关键原因不难理解：技术不行。</strong></p>\n<img src=\"/2021/08/05/database-developer-say-no-to-us/have_no_tech.jpeg\" width=\"200\">\n\n<a id=\"more\"></a>\n\n<p>数据库的两个关键指标是<strong>“快”</strong>和<strong>“稳”</strong>。其中“快”由优化器负责，它通过对用户输入查询进行代数优化、代价优化从而选择多快好省的执行路径；而“稳”则主要由事务负责，它通过并发控制和故障恢复理论保证数据库在执行的过程中满足原子性、一致性、隔离性、持久性，保证数据的不错不丢。</p>\n<p>无论是查询优化技术，还是事务处理技术，国产数据库和国外数据库巨头之间都有不小的差距，现在仍处于模仿中的技术创新阶段，少有真正原创的核心技术。一方面，随着云计算、大数据、互联网金融等信息技术的不断发展，对数据库等基础核心软件的要求越来越高，另一方面，国产数据库则后劲乏力、缺乏积极进取的精神，虽落后于世界但仍沾沾自喜。</p>\n<p>因此，当前数据库发展的主要矛盾就变成：<strong>核心应用软件对数据库日益提高的性能、稳定、安全的需求和落后的国产数据库技术之间的矛盾。</strong></p>\n<p>2019年始，以美国为首的一些发达国家开始了对中国发展的围追堵截，中华民族又到了最危险的时候，此诚危急存亡之秋也。作为数据库的从业者自然也应该肩负责任、奋发图强、迎头赶上，撸起袖子加油干。</p>\n<p>PostgreSQL数据库作为世界上最先进的开源数据库，秉承了开源的开放奉献、追求进步的精神，不受控于任何公司、国家，是我们良师益友，全面的掌握PostgreSQL则有助于我们的发展和进步。</p>\n<p>2018年，电子工业出版社出版了《PostgreSQL技术内幕：查询优化深度探索》一书，已经对数据库中的“快”技术做了深度的剖析，帮助大量的数据库爱好者更深入的了解了数据库查询优化器的技术实现方法，让很多人对优化器有了更深层次的了解。</p>\n<p>2021年，应对数据库“稳”技术的《PostgreSQL技术内幕：事务处理深度探索》也将上市，为数据库的从业者提供充分的补给。本书分析了PostgreSQL数据库事务的实现机制，包括事务的基本概念、两阶段锁的原理及实现方法、多版本并发控制的原理及实现方法、故障恢复的实现方法等，然后通过介绍物理复制、逻辑复制、Zheap引擎的原理及实现、SSI的实现、两阶段提交的原理及实现增强读者对事务更深入的理解，从而使读者既能了解事务的原理，也能清楚事务的实现细节。</p>\n<p>相信《PostgreSQL技术内幕》系列丛书能够抛砖引玉，让越来越多的中华儿女投身到数据库内核事业中来，让越来越多的数据库从业者分享出自己的心得和理解，让越来越多的国产数据库能够屹立于世界之林。</p>\n<p><strong>男儿不展风云志，空负天生八尺躯，数据库从业者们，奋斗吧。</strong></p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://item.jd.com/12898593.html\">京东地址</a><br><a href=\"http://product.dangdang.com/29277465.html\">当当地址</a><br><a href=\"https://detail.tmall.com/item.htm?spm=a1z10.3-b-s.w4011-22119638442.37.798d1b8b6TlJDS&id=651820819927&rn=215b8c029b06d654c30a5777273c979e&abbucket=1\">淘宝地址</a> </p>\n<p><img src=\"/2021/08/05/database-developer-say-no-to-us/buy_link.jpeg\"> </p>\n<p>几十年来，国外数据库巨头凭借先发优势形成的技术壁垒和理论壁垒垄断了数据库市场，卡住了中国乃至世界的脖子，《科技日报》曾推出系列文章报道制约我国工业发展的35项“卡脖子”技术，数据库管理系统就是其中的一项。虽然国产数据库近些年蓬勃发展，但只能在在周边领域打转，在金融关键核心系统上则屡败屡战，未尝一胜。</p>\n<p><strong>这其中的关键原因不难理解：技术不行。</strong></p>\n<img src=\"/2021/08/05/database-developer-say-no-to-us/have_no_tech.jpeg\" width=\"200\">","more":"<p>数据库的两个关键指标是<strong>“快”</strong>和<strong>“稳”</strong>。其中“快”由优化器负责，它通过对用户输入查询进行代数优化、代价优化从而选择多快好省的执行路径；而“稳”则主要由事务负责，它通过并发控制和故障恢复理论保证数据库在执行的过程中满足原子性、一致性、隔离性、持久性，保证数据的不错不丢。</p>\n<p>无论是查询优化技术，还是事务处理技术，国产数据库和国外数据库巨头之间都有不小的差距，现在仍处于模仿中的技术创新阶段，少有真正原创的核心技术。一方面，随着云计算、大数据、互联网金融等信息技术的不断发展，对数据库等基础核心软件的要求越来越高，另一方面，国产数据库则后劲乏力、缺乏积极进取的精神，虽落后于世界但仍沾沾自喜。</p>\n<p>因此，当前数据库发展的主要矛盾就变成：<strong>核心应用软件对数据库日益提高的性能、稳定、安全的需求和落后的国产数据库技术之间的矛盾。</strong></p>\n<p>2019年始，以美国为首的一些发达国家开始了对中国发展的围追堵截，中华民族又到了最危险的时候，此诚危急存亡之秋也。作为数据库的从业者自然也应该肩负责任、奋发图强、迎头赶上，撸起袖子加油干。</p>\n<p>PostgreSQL数据库作为世界上最先进的开源数据库，秉承了开源的开放奉献、追求进步的精神，不受控于任何公司、国家，是我们良师益友，全面的掌握PostgreSQL则有助于我们的发展和进步。</p>\n<p>2018年，电子工业出版社出版了《PostgreSQL技术内幕：查询优化深度探索》一书，已经对数据库中的“快”技术做了深度的剖析，帮助大量的数据库爱好者更深入的了解了数据库查询优化器的技术实现方法，让很多人对优化器有了更深层次的了解。</p>\n<p>2021年，应对数据库“稳”技术的《PostgreSQL技术内幕：事务处理深度探索》也将上市，为数据库的从业者提供充分的补给。本书分析了PostgreSQL数据库事务的实现机制，包括事务的基本概念、两阶段锁的原理及实现方法、多版本并发控制的原理及实现方法、故障恢复的实现方法等，然后通过介绍物理复制、逻辑复制、Zheap引擎的原理及实现、SSI的实现、两阶段提交的原理及实现增强读者对事务更深入的理解，从而使读者既能了解事务的原理，也能清楚事务的实现细节。</p>\n<p>相信《PostgreSQL技术内幕》系列丛书能够抛砖引玉，让越来越多的中华儿女投身到数据库内核事业中来，让越来越多的数据库从业者分享出自己的心得和理解，让越来越多的国产数据库能够屹立于世界之林。</p>\n<p><strong>男儿不展风云志，空负天生八尺躯，数据库从业者们，奋斗吧。</strong></p>"},{"title":"【视频】PostgreSQL中的锁","date":"2021-10-07T01:01:40.000Z","_content":"\nPostgreSQL中的锁是数据库事务中的核心内容，本次我们尽量抛开源代码实现，从DBA的角度来分析锁的级别和PostgreSQL的锁的实现机制。\n\n{% raw %}\n<iframe src=\"//player.bilibili.com/player.html?aid=548425121&bvid=BV1nq4y1V7fs&cid=421451468&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n{% endraw %}\n\n","source":"_posts/postgresql-lock-vedio.md","raw":"\n---\ntitle: 【视频】PostgreSQL中的锁\ndate: 2021-10-07 09:01:40\ntags: PostgreSQL 事务 锁 数据库\n---\n\nPostgreSQL中的锁是数据库事务中的核心内容，本次我们尽量抛开源代码实现，从DBA的角度来分析锁的级别和PostgreSQL的锁的实现机制。\n\n{% raw %}\n<iframe src=\"//player.bilibili.com/player.html?aid=548425121&bvid=BV1nq4y1V7fs&cid=421451468&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n{% endraw %}\n\n","slug":"postgresql-lock-vedio","published":1,"updated":"2021-10-07T13:42:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckugzp4fo0000n19ka2f9dsyd","content":"<p>PostgreSQL中的锁是数据库事务中的核心内容，本次我们尽量抛开源代码实现，从DBA的角度来分析锁的级别和PostgreSQL的锁的实现机制。</p>\n\n<iframe src=\"//player.bilibili.com/player.html?aid=548425121&bvid=BV1nq4y1V7fs&cid=421451468&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p>PostgreSQL中的锁是数据库事务中的核心内容，本次我们尽量抛开源代码实现，从DBA的角度来分析锁的级别和PostgreSQL的锁的实现机制。</p>\n\n<iframe src=\"//player.bilibili.com/player.html?aid=548425121&bvid=BV1nq4y1V7fs&cid=421451468&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n\n\n"}],"PostAsset":[{"_id":"source/_posts/postgresql-optimizer-outline-2/1.jpg","slug":"1.jpg","post":"ckdchg8je0002r2s686meddyz","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-2/2.jpg","slug":"2.jpg","post":"ckdchg8je0002r2s686meddyz","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-4/1.png","slug":"1.png","post":"ckdgkb6d30000mvs61pjfd9kp","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-4/2.png","slug":"2.png","post":"ckdgkb6d30000mvs61pjfd9kp","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-7/1.jpg","slug":"1.jpg","post":"ckfszbzyj0000ro9kgeuy15hy","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-7/2.png","slug":"2.png","post":"ckfszbzyj0000ro9kgeuy15hy","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-7/3.png","slug":"3.png","post":"ckfszbzyj0000ro9kgeuy15hy","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-7/4.png","slug":"4.png","post":"ckfszbzyj0000ro9kgeuy15hy","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-7/5.png","slug":"5.png","post":"ckfszbzyj0000ro9kgeuy15hy","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-7/6.png","slug":"6.png","post":"ckfszbzyj0000ro9kgeuy15hy","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-9/1.png","slug":"1.png","post":"ckfszbzyo0003ro9k3ejk08ql","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-9/2.png","slug":"2.png","post":"ckfszbzyo0003ro9k3ejk08ql","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-9/3.png","slug":"3.png","post":"ckfszbzyo0003ro9k3ejk08ql","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-optimizer-outline-9/4.png","slug":"4.png","post":"ckfszbzyo0003ro9k3ejk08ql","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-lock-lwlock-implement/lockstate.jpg","slug":"lockstate.jpg","post":"ckrb9w1k70000g29khng9fbev","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-lock-lwlock-implement/sxlock.jpg","slug":"sxlock.jpg","post":"ckrb9w1k70000g29khng9fbev","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-lock-lwlock-implement/waitqueue.jpg","slug":"waitqueue.jpg","post":"ckrb9w1k70000g29khng9fbev","modified":0,"renderable":0},{"_id":"source/_posts/postgresql-transaction-internals-introduce/introduce.jpg","slug":"introduce.jpg","post":"ckruplv2w0000yu9k1vls2joj","modified":0,"renderable":0},{"_id":"source/_posts/database-developer-say-no-to-us/buy_link.jpeg","slug":"buy_link.jpeg","post":"ckrz3bn0k0000wx9k0u1o0cuc","modified":0,"renderable":0},{"_id":"source/_posts/database-developer-say-no-to-us/have_no_tech.jpeg","slug":"have_no_tech.jpeg","post":"ckrz3bn0k0000wx9k0u1o0cuc","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"ckfszbzyj0000ro9kgeuy15hy","tag_id":"ckfszbzyl0002ro9kanjefekl","_id":"ckfszbzyp0005ro9kggb76qu5"},{"post_id":"ckfszbzyk0001ro9kakdf920l","tag_id":"ckfszbzyp0004ro9k9lae9crw","_id":"ckfszbzyq0007ro9keajgbmig"},{"post_id":"ckfszbzyo0003ro9k3ejk08ql","tag_id":"ckfszbzyp0006ro9k9jwea22m","_id":"ckfszbzyq0008ro9k7gra9xwm"},{"post_id":"ckktgdw790000nj9k0mucc72m","tag_id":"ckktgdw7g0001nj9k7nue1o09","_id":"ckktgdw7l0002nj9kbinpaqe8"},{"post_id":"ckrb9w1k70000g29khng9fbev","tag_id":"ckrb9w1ke0001g29k7jpv9tik","_id":"ckrb9w1ki0002g29kbttg55wv"},{"post_id":"ckruplv2w0000yu9k1vls2joj","tag_id":"ckruplv360001yu9kf5qjeaym","_id":"ckruplv3c0002yu9k1bt7bdle"},{"post_id":"ckrz3bn0k0000wx9k0u1o0cuc","tag_id":"ckrz3bn0o0001wx9khd7x12ze","_id":"ckrz3bn0s0002wx9k39zthtvo"},{"post_id":"ckugzp4fo0000n19ka2f9dsyd","tag_id":"ckugzp4fu0001n19k6xk0e9yu","_id":"ckugzp4fx0002n19k9xtgh82c"}],"Tag":[{"name":"路径 Path 顺序扫描 索引扫描 位图扫描 Join","_id":"ckfszbzyl0002ro9kanjefekl"},{"name":"代价 启动代价 IO代价 CPU代价","_id":"ckfszbzyp0004ro9k9lae9crw"},{"name":"动态规划 自底向上 自顶向下","_id":"ckfszbzyp0006ro9k9jwea22m"},{"name":"lock spinlock transaction postgresql","_id":"ckktgdw7g0001nj9k7nue1o09"},{"name":"lock lwlock transaction postgresql","_id":"ckrb9w1ke0001g29k7jpv9tik"},{"name":"transaction 事务 新书 技术内幕 PostgreSQL","_id":"ckruplv360001yu9kf5qjeaym"},{"name":"database transaction","_id":"ckrz3bn0o0001wx9khd7x12ze"},{"name":"PostgreSQL 事务 锁 数据库","_id":"ckugzp4fu0001n19k6xk0e9yu"}]}}